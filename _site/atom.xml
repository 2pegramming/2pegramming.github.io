<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title></title>
 <link href="http://pepegramming.site/atom.xml" rel="self"/>
 <link href="http://pepegramming.site/"/>
 <updated>2024-09-16T13:55:42+03:00</updated>
 <id>http://pepegramming.site</id>
 <author>
   <name>Anton Davydov</name>
   <email></email>
 </author>

 
 <entry>
   <title>Как и почему использую Obsidian</title>
   <link href="http://pepegramming.site/questions/how-i-use-obsidian-and-why/"/>
   <updated>2024-09-14T00:00:00+03:00</updated>
   <id>http://pepegramming.site/questions/how-i-use-obsidian-and-why</id>
   <content type="html">&lt;h2 id=&quot;вопрос&quot;&gt;Вопрос&lt;/h2&gt;

&lt;div class=&quot;question-text&quot;&gt;
  &lt;blockquote&gt;
    &lt;p&gt;Привет!&lt;/p&gt;

    &lt;p&gt;Видел у тебя обсидиан, расскажи как пользуешься им и почему не выбран инструмент X?&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/div&gt;

&lt;p&gt;С одной стороны кажется, что можно только рассказать как раскидал файлы и делаю заметки в обсидиане. Но так не раскрою идею, почему обсидиан, а не другой редактор. Поэтому, давайте сначала абстрактно о базе знаний поговорим и разберемся в том, как выбрать подходящий инструмент под цели и стиль ведения заметок.&lt;/p&gt;

&lt;p&gt;Если хотите почитать как я обсидианом пользуюсь, не читая абстрактной мути, &lt;a href=&quot;#как-веду-базу-знаний&quot;&gt;вам в следующую часть текста&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Важно: так как тема связана с продуктивностью, давайте договоримся на берегу – в ответе опишу только личный опыт и то, как сам работаю с knowledge base и обсидианом. Я не гонюсь за продуктивностью (и не считаю себя экспертом в теме), реализовывать систему Лумана или Эшби 1 в 1 желания тоже нет. Плюс, у меня специфическое требование к базе знаний связанное со связями (дальше по тексту обсудим), поэтому повторять за собой не советую ибо больно и в 90% не требуется для решения рабочих задач. Еще один момент: предполагаю, что вы знаете что такое обсидиан (если нет, то либо пропустите ответ, либо сначала &lt;a href=&quot;https://help.obsidian.md/Home&quot;&gt;почитайте документацию&lt;/a&gt;).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TLDR для тех, кто рассматривает obsidian как замену notion: если используете ноушен как project management инструмент, либо для работы с другими людьми, либо для личной продуктивности – я бы посоветовал выбрать другой инструмент. Иначе потратите много времени на настройку и 1 в 1 функционал повторить не сможете. Хотя обратные примеры существуют: &lt;a href=&quot;https://www.vicyyn.com/blog/simple-obsidian-system&quot;&gt;раз&lt;/a&gt;, &lt;a href=&quot;https://cplong.org/2024/01/using-obsidian-notes-to-create-meaningful-productivity/&quot;&gt;два&lt;/a&gt;, &lt;a href=&quot;https://vanadium23.me/obsidian-anytype/&quot;&gt;три&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Всё, с душным введением закончил, давайте о заметках.&lt;/p&gt;

&lt;h2 id=&quot;выбираем-подходящий-инструмент-для-заметок&quot;&gt;Выбираем подходящий инструмент для заметок&lt;/h2&gt;

&lt;p&gt;Заметки и конспекты веду всю жизнь, начиная со школы. Когда занялся программированием, заметки тоже вел постоянно. Казалось, что если буду писать, пока учусь или работаю – сразу жизнь наладится, волосы станут шелковистыми, а каждую идею, которую прочту или услышу буду помнить годами.&lt;/p&gt;

&lt;p&gt;Но реальность оказалась другой: заметки превращались в кашу, которой пользоваться было невозможно. Не так давно нашел старые конспекты из института, и лучше бы потрогал траву, чем разбирался бы в обрывистых записях об определении реакций в шарнирных опорах балки, теоремах лагранжа и прочем. Причем, ситуация с «качеством» заметок касается не только институтских записей, но и заметок по программированию, документации проектов и информации по работе систем и остальным, что связанно с текстом в повседневной работе.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/knowledge-base-meme.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Краткое описание конспектов, заметок и документации, что я вел за последние 20+ лет&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Каждый раз проблема сводилась к бесцельному желанию писать заметки, т.е. что дальше с ними делать – не знал (сессию можно и без конспектов закрыть). Т.е. писал без цели и это было ошибкой.&lt;/p&gt;

&lt;h3 id=&quot;цели-и-заметки&quot;&gt;Цели и заметки&lt;/h3&gt;

&lt;p&gt;У решения должна быть проблема, которую будем решать. Выбор инструмента для заметок не исключение. Целей может быть много, например:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хочу почувствовать себя молодцом и сделать популярный блог о продуктивности и персональных баз знаний (валидная цель, без шуток);&lt;/li&gt;
  &lt;li&gt;Хочу перестать забывать информацию, например рецепты, которые готовятся раз в год;&lt;/li&gt;
  &lt;li&gt;Прошел &lt;a href=&quot;https://en.wikipedia.org/wiki/Warhammer_40,000:_Space_Marine_2&quot;&gt;Warhammer 40,000: Space Marine 2&lt;/a&gt; и теперь хочу разобраться в вахе и понять кто такие Адептус Астартес и при чем тут война с хорусом;&lt;/li&gt;
  &lt;li&gt;В институте заставили сдать конспекты, а без конспектов не поставят зачет;&lt;/li&gt;
  &lt;li&gt;Хочу собрать список на чтение, которого буду придерживаться год, а не хаотично изучать что попало;&lt;/li&gt;
  &lt;li&gt;Хочу персональную «вики» по вопросам с собесов, что бы устроиться в FAANG и подсматривать ответы в случае проблем;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Тут главное честно себе сказать, для чего заметки нужны, потому что ответ определяет что будем делать и как будем решать проблему. Т.е. если нужен список рецептов, то может хватить коллекционирования в бумажном блокноте. Если нужна «вики» для собеседований, то придется найти решение, которое позволит структурировать темы. А если хотим разобраться в лоре вахи (не хотим), то тут придется думать о вайтборде с перекрестными ссылками.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/pepe-silvia-meme.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Первое, что приходит в голову, когда думаю о человеке, который пытается разобраться в лоре adeptus astartes&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Тут приходим к тому, что нет одного подхода к ведению заметок, но можно выделить «стили» ведения заметок, которые помогут в решении проблем.&lt;/p&gt;

&lt;h3 id=&quot;стили-ведения-заметок&quot;&gt;Стили ведения заметок&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://nesslabs.com/how-to-choose-the-right-note-taking-app&quot;&gt;Сошлюсь на идею о разных видах «note-taking styles»&lt;/a&gt;, в которой автор систематизирует «архетипы заметкодеятелей». В статье выделяется три группы:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;The architect&lt;/strong&gt; – любят планировать, дизайнить процессы и использовать «фреймворки». От note-taking инструмента ждут простоту в структурировании идей. Упарываются на структуре и порядке;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;The gardener&lt;/strong&gt; – любят изучать, искать связи между идеями, подходами и прочим. От note-taking инструмента ждут возможность развивать и соединять идеи вместе. Упарываются в связи между идеями;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;The librarian&lt;/strong&gt; – любят коллекционировать, делать каталоги ресурсов. От note-taking инструмента ждут легкость нахождения собственных идей. Упарываются в сбор информации;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если упростить, то стиль сводится к выбору на чем будешь фокусироваться: структура, коллекционирование, связи. &lt;/p&gt;

&lt;p&gt;Дальше автор предлагает набор инструментов под каждый «стиль». Например, для структуры подойдет условный notion, coda и аналоги. Для тех, кто по связям упарывается – rome, obsidian, wiki-like штуки (&lt;a href=&quot;https://blinpete.github.io/wiki-graph/?lang=en&amp;amp;wordle=&amp;amp;query=Note-taking&quot;&gt;ссылка для тех кто удивился wiki в этой группе&lt;/a&gt;) и так далее. А для тех, кто любит коллекции – bear, evernote, OneNote.&lt;/p&gt;

&lt;p&gt;Важно отметить, что каждый из стилей важен и нужен. Т.е. нет плохого или хорошего подхода в работе с заметками. Идея в том, на чем нужно фокусироваться, пока ведешь заметки. Как пример, сравните вторую часть этого ответа и &lt;a href=&quot;https://vanadium23.me/obsidian-anytype/&quot;&gt;пост Вани об обсидиане&lt;/a&gt;, вроде два текста об одном инструменте, но стили использования инструмента отличаются. Еще один пример использования одного инструмента по разному – блоги. Например, предположу, что &lt;a href=&quot;https://ailev.livejournal.com/1689226.html&quot;&gt;Левенчук использует блог как gardener&lt;/a&gt;, а &lt;a href=&quot;https://blog.bytebytego.com/p/ep129-the-ultimate-walkthrough-of&quot;&gt;автор bytebytego собирает коллекции технических подходов как librarian&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Поэтому, не обязательно фокусироваться на одном стиле. Если идейно ближе фокусироваться на связях, то будет странно хранить список фильмов для просмотра в обсидиане в виде графа с кучей связей (если нет цели разбираться в сюжетах), каталог тут будет удобнее. Например, заметки с рецептами и заметки с «бытовой» информацией я веду в двух разных приложениях (не обсидиан).&lt;/p&gt;

&lt;h3 id=&quot;соединяем-цели-и-стили-вместе&quot;&gt;Соединяем цели и стили вместе&lt;/h3&gt;

&lt;p&gt;Если развивать эту идею со стилями, можно прийти к тому, что выбор инструмента будет проходить через три шага:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/3-steps-for-selecting-notetaking-tool.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Три шага, которые позволят понять, какой инструмент подойдет под конкретную задачу&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;И смысл подхода в том, что стоит рассматривать решение от проблемы, а не подгонять проблему под решение. Если хоть раз ловили себя на мысли, что если кто-то использует картотеку и много пишет, то значит тоже срочно надо завести физическую картотеку, то вот это чувство как раз о том, чтобы взять инструмент, а потом придумать под него проблему.&lt;/p&gt;

&lt;p&gt;Единственное, что не указал (так как ответ о персональных базах знаний) – кроме стиля, стоит подумать о том, сколько человек будет пользоваться инструментом. Потому что некоторые редакторы предполагают, что работать над заметками будет команда, а некоторые нет. Пожалуйста, учитывайте этот аспект тоже.&lt;/p&gt;

&lt;details class=&quot;collapse_block&quot;&gt;
  &lt;summary class=&quot;collapse_block__title&quot;&gt;Заумь: один убер инструмент или N специфичных инструментов&lt;/summary&gt;

  &lt;div class=&quot;collapse_block__content&quot;&gt;
    &lt;p&gt;Рано или поздно столкнетесь с выбором: &lt;del&gt;emacs или vim&lt;/del&gt; убер инструмент где можно сразу сделать нужную структуру, вести каталоги и находить связи, либо использовать разные инструменты, каждый под конкретную задачу.&lt;/p&gt;

    &lt;p&gt;Честно, тут дело вкуса и спор похож на споры &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_philosophy#Origin&quot;&gt;вокруг unix философии&lt;/a&gt;. Например, фанаты ноушена любят использовать приложение для всего, где и задачи и заметки и списки и связи. Попсовый пример – &lt;a href=&quot;https://www.notion.so/templates/aesthetic-matcha-student-planner&quot;&gt;matcha student planner&lt;/a&gt;. В обсидиане тоже так пытаются: &lt;a href=&quot;https://www.vicyyn.com/blog/simple-obsidian-system&quot;&gt;раз&lt;/a&gt;, &lt;a href=&quot;https://cplong.org/2024/01/using-obsidian-notes-to-create-meaningful-productivity/&quot;&gt;два&lt;/a&gt;. Ну или &lt;a href=&quot;https://vanadium23.me/obsidian-anytype/&quot;&gt;почитайте пример Вани&lt;/a&gt;, он из обсидиана убер комбайн сделал.&lt;/p&gt;

    &lt;p&gt;Проблем с таким подходом не вижу (главное чтобы работало, а не сжирало время на поддержку). Хотя мне ближе 1 инструмент под одну задачу и не мешать информацию по личным делам и рабочим. Банально, но голове так проще. Единственное исключение – todo app, в котором храню что рабочие, что личные задачи.&lt;/p&gt;
  &lt;/div&gt;
&lt;/details&gt;

&lt;h3 id=&quot;зачем-использую-заметки&quot;&gt;Зачем использую заметки&lt;/h3&gt;

&lt;p&gt;С абстрактным выбором инструмента закончили, теперь о личных проблемах, которые решаю заметками. Как писал выше, пока делал заметки, изначально я не ставил никакой цели, а просто писал, потому что так «принято» и «надо». Из-за этого заметки превращались в свалку, которая забывалась и выбрасывалась.&lt;/p&gt;

&lt;p&gt;На сегодня проблема сформировалась – по работе необходимо делать контент вокруг инженерных штук. Это как курсы, так и выступления, посты, обучающий материал для компаний, ADR, описание систем и собственный ресерч в темах, чтобы лучше разобраться и не запоминать тонну информации, названий инструментов и специфических особенностей использования паттернов или технологий.&lt;/p&gt;

&lt;p&gt;Т.е. цель – получить как можно больше материала и что важнее, связей. А после жонглировать информацией в зависимости от исходной цели требуемого контента. Выглядит это так: сначала собираю темы, связывая темы между собой, а потом, когда надо сделать что-то, выбираю нужные заметки и референсы, на основе которых пишу контент.&lt;/p&gt;

&lt;p&gt;Идейно это похоже на &lt;a href=&quot;https://en.wikipedia.org/wiki/Integrated_assessment_modelling&quot;&gt;integrated model&lt;/a&gt;, где создается модель, для которой генерируется projection под задачу. Если пользовались fusion360 или аналогичными CAD – это как из 3д модели получить чертеж для вида сбоку, либо направления сил, действующих на изделие. Вот с заметками аналогичная идея: сначала делаю полную «модель» информации, а потом, когда нужно ответить на вопрос – собираю projection из полученной модели, нужно сделать доклад – собираю другой projection из той же модели. Может показаться, что это выглядит как локальная вики, но на деле гуглить приходится много, потому что тем слишком много и не успеваешь разбирать каждую и добавлять к себе в базу.&lt;/p&gt;

&lt;p&gt;Благодаря этому для &lt;a href=&quot;https://tough-dev.school/system-analysis&quot;&gt;курса по анализу систем&lt;/a&gt; вышло 500 страниц А4 контента и 300+ референсных материалов на курс. А сам курс написал за пол года. Единственный минус – пришлось потратить еще 3+ года на то, чтобы собрать информацию которую потом использовал для курса.&lt;/p&gt;

&lt;p&gt;В целом, работа с заметками выглядит как два не связанных цикла:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/personal-knowledge-base-cycle.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Два цикла, которые не зависят друг от друга. В левом наполняю базу знаний, в правом использую накопленные записи для контента, а появляющиеся идеи или «знания» помещаю в базу знаний&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;что-использовать-для-поиска-связей-вместо-обсидиана&quot;&gt;Что использовать для поиска связей вместо обсидиана&lt;/h3&gt;

&lt;p&gt;В ответе упоминается только обсидиан. Но это не единственный инструмент, который помогает с поиском связей между заметками. Ниже список инструментов, что сам использовал и на что можно посмотреть:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://evernote.com&quot;&gt;Evernote&lt;/a&gt;. Первое note-taking приложение, что использовал. Так как не понимал что и зачем делаю, было не удобно. Знаю, что есть фанаты, но это не инструмент для поиска связей;&lt;/li&gt;
  &lt;li&gt;Приватный репозиторий с md файлами + любимый редактор. Идеальное во всем решение, кроме поиска связей между заметками;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.thebrain.com&quot;&gt;The Brain&lt;/a&gt;. В 2016 году часто слышал о приложении, даже пробовал сам. Не понравилось, что связывались концепции, а не заметки + работа в крупном графе вызывает вопросы с точки зрения удобства (ниже подробнее расскажу). Плюс, не было задачи для инструмента, поэтому забил;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.inkdrop.app&quot;&gt;InkDrop&lt;/a&gt;. Идейно ближе к evernote или bear. Со связями аналогично, сделать можно, а исследовать проблемно. Поэтому, &lt;a href=&quot;https://www.youtube.com/watch?v=a9SCmSKbSVs&quot;&gt;пытался сделать графовое отображение для заметок&lt;/a&gt;, что бы лучше связи искать;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://roamresearch.com&quot;&gt;Roam Research&lt;/a&gt;. Засматривался на приложение еще до появления обсидиана. Оттолкнула цена + работа только в браузере. Для локальной работы подойдет &lt;a href=&quot;https://github.com/foambubble/foam&quot;&gt;foam&lt;/a&gt;, который работает в vscode. Но было лень разбираться в деталях;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://logseq.com&quot;&gt;LogSeq&lt;/a&gt;. Модный на 2024 год oss инструмент, который продолжает идеи roam, плюс конкурирует с обсидианом, даже аналог canvas добавили. Пробовал сам, но не понравилось;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.devontechnologies.com/apps/devonthink&quot;&gt;DEVONthink&lt;/a&gt;. Не пользовался, но говорят, что там можно сделать что хочешь, даже развернуть zettelkasten. Только под мак;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://orgmode.org&quot;&gt;org-mode&lt;/a&gt;. Для сильных духом и тех, кто любит GNU и лисп. Если бы изначально использовал emacs, а не vim – остановился на org-mode;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kaorahi.github.io/howm/&quot;&gt;howm&lt;/a&gt;. Еще один mode для emacs, если бы не org-mode. Нишевая штука, которую придумал японец (документации не на японском не было до 2023 года). Подробнее лучше &lt;a href=&quot;https://github.com/Emacs101/howm-manual&quot;&gt;почитать в документации&lt;/a&gt;;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://znotes.thedoc.eu.org&quot;&gt;Zettel Notes&lt;/a&gt;. Попытка сделать инструмент под zettelkasten. Не использовал;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если не хватило – &lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_personal_information_managers&quot;&gt;в вики список еще больше&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;что-делать-если-цели-другие&quot;&gt;Что делать, если цели другие&lt;/h3&gt;

&lt;p&gt;Тут не подскажу, не рабочие заметки веду в &lt;a href=&quot;https://bear.app&quot;&gt;bear&lt;/a&gt;, рецепты &lt;a href=&quot;https://mela.recipes&quot;&gt;в отдельном приложении&lt;/a&gt;, а списки посмотреть/почитать/поиграть в экселе. Единственное, что могу посоветовать – определитесь с целями (делать контент мало кому нужно, если быть честным) и после выбрать подходящий стиль и под него инструмент. Если не знаете подходит ли инструмент под выбранный стиль – придется пробовать и искать самостоятельно, либо поискать ответ на reddit.&lt;/p&gt;

&lt;h2 id=&quot;как-веду-базу-знаний&quot;&gt;Как веду базу знаний&lt;/h2&gt;

&lt;p&gt;Для тех, кто не читал прошлую часть: держите в голове, что обсидиан использую только для создания нового контента. Это значит, что решения и способ использования обсидиана, которые буду описывать далее – крутятся только вокруг этой проблемы.&lt;/p&gt;

&lt;p&gt;Главное правило, которого придерживаюсь: в обсидиане только рабочая информация вокруг software систем, плюс смежные темы. Т.е. никаких дневников настроения, бытовых задач или заметок с рецептами.&lt;/p&gt;

&lt;p&gt; По структуре &lt;a href=&quot;https://help.obsidian.md/Plugins/Workspaces&quot;&gt;obsidian workspace&lt;/a&gt; не запариваюсь, раскидал &lt;a href=&quot;https://fortelabs.com/blog/para/&quot;&gt;файлы по PARA&lt;/a&gt;. Кроме файлов с заметками, использую whiteboard-ы где связываю темы в структуру материала (прямо как в фильмах о расследованиях), либо собираю термины во что-то осмысленное. Раньше использовал miro, но переехал на &lt;a href=&quot;https://help.obsidian.md/Plugins/Canvas&quot;&gt;obsidian canvas&lt;/a&gt;. Так как whiteboard нужен только для структуры, минимализма canvas хватает.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/ac-course-whiteboards.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Слева структура &lt;a href=&quot;https://tough-dev.school/system-analysis&quot;&gt;AC курса&lt;/a&gt;, которую сначала делал в миро, справа – структура того же курса, но уже перенесенная в canvas обсидиана&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;о-заметках&quot;&gt;О заметках&lt;/h3&gt;

&lt;p&gt;Само собой сложилось, что использую шесть видов заметок. Возможно через пару лет появятся новые виды, но на сегодня список такой:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Базовая заметка. Основной вид заметок, в которых мысль или тему раскрываю. О размере не парюсь, некоторые могут состоять из одного предложения, а другие – лонгридом;&lt;/li&gt;
  &lt;li&gt;Журнал. Список событий вокруг темы. Например, пока читаю книгу, делаю заметки по личному отношению к книге с датой. Потом смотрю как менялось мнение спустя время, что читал книгу. Каждая запись начинается с даты. Использую потом для восстановления контекста о процессе работы или учебы;&lt;/li&gt;
  &lt;li&gt;«Research заметки». Заметки в которые кидаю ссылки на материалы, которые нужно прочитать чтобы разобраться в теме. В будущем, когда сажусь ковыряться в теме, не приходится с нуля искать материалы. Так как уже собрал пачку материалов, благодаря которой начинаю изучение, а не трачу время на поиски;&lt;/li&gt;
  &lt;li&gt;Заметка по книге/пейперу/курсу. Заметка с названием книги, началом изучения, ожиданиями и ссылками на заметки которые возникли во время изучения материала (по главам). Похоже на &lt;a href=&quot;https://obsidian.rocks/quick-tip-quickly-organize-notes-in-obsidian/#Why-are-MOCs-so-life-changing&quot;&gt;MoC заметки&lt;/a&gt;, только собираю связи руками, а не через dataview. В заметках, которые появляются во время учебы, использую заметку по книге/курсу/пейперу как референс;&lt;/li&gt;
  &lt;li&gt;Канвас для создания структуры по контенту. Нужен для того, чтобы «раскидать» темы по «столу» и визуально понять как структурировать темы (визуально проще работать). Использую только для больших материалов. Для мелких – хватает отдельной заметки. Иногда канвас могу использовать для того, чтобы разобраться в сложной теме и сделать «концептуальную модель»;&lt;/li&gt;
  &lt;li&gt;Канбан доски. Использую только для регулярных проектов. Например, сделал доску, в которой держу список вопросов под &lt;a href=&quot;https://pepegramming.site/questions/&quot;&gt;pepegramming questions&lt;/a&gt;. При этом, задачи и менеджмент выношу из обсидиана в отдельные инструменты, а канбан доска нужна только для планирования о чем писать дальше;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Хоть и разделяю заметки по типам, но использую один и тот же темплейт, в котором 4 секции: текст заметки, вопросы по теме, референсы и ссылки на другие заметки, которые подходят по смыслу.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
tags:
  - new_note
created at: 
---

# 
&amp;gt; заметка понятна вне контекста

## Комментарий

## Вопросы
- #открытыйвопрос &amp;lt;Вопрос&amp;gt;

## Референс
&amp;gt; откуда взята цитата или идея, вплоть до номера страницы конкретной книги

1. ...
2. ...

[1]: ...
[2]: ...

## Ссылка на другую заметку

&amp;gt; как эта идея дополняет то, что я уже знаю?
&amp;gt; как этот X повлияет на Y?
&amp;gt; как я могу при помощи этой идеи объяснить Z?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Обязательное условие существования заметки (после связей) – референсы, где в нумерованном списке откуда взял референс, а в ссылке &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[1]:&lt;/code&gt; прямая ссылка на референс. Для заметок, которые появляются как результат чтения книги указываю источник с точностью до абзаца. Если статья – оставляю ссылку, если видео – ссылка и временная точка, если книга/пейпер/курс – указываю точное расположение (как в книгах). Если собственная заметка – указываю откуда появилась идея (ссылками на другие заметки).&lt;/p&gt;

&lt;p&gt;Еще один плюс референсов – можно искать связи в других статьях или идеях. Ну или наблюдать, как авторы повторяют друг друга из раза в раз.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/why-microservices-example.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Моя заметка, где собираю причины перехода на сервисы. Каждая цифра в начале – референс, где упоминалась причина&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;details class=&quot;collapse_block&quot;&gt;
  &lt;summary class=&quot;collapse_block__title&quot;&gt;Заумь: почему не zettelkasten&lt;/summary&gt;

  &lt;div class=&quot;collapse_block__content&quot;&gt;
    &lt;p&gt;Кажется что без упоминания zettelkasten, не обходится ни одна статья вокруг базы знаний и обсидиана, в частности. Исключения делать не буду.&lt;/p&gt;

    &lt;p&gt;Для себя не вижу смысла в подходе Лумана, так как подозреваю, что люди увидели что Луман много делал и собирал картотеку с заметками. Из-за чего возникла связь, что zettelkasten == продуктивности как у Лумана. Кажется, что тут сбилась причинно-следственная связь, и картотека не является причиной продуктивности (вполне допускаю, что подхо развивал изначальное стремление Лумана). Поэтому делаю как самому удобнее, а пробовать другие варианты уже нет и сил и времени. Но с «научной» точки зрения, интересно как подход работал и на чем строился.&lt;/p&gt;

    &lt;p&gt;При этом, верю, что точное следование подхода помогает людям, но в моем случае это выглядит как вещь в себе. Хотя идею с раскидыванием «карточек» на столе для сбора материала использую, правда в виде canvas. А вот в &lt;a href=&quot;https://qnnnp.substack.com/p/3e2&quot;&gt;собеседнике&lt;/a&gt; смысла не вижу.&lt;/p&gt;

    &lt;p&gt;Аналогично отношусь к другим подходам. В качестве примера можно вспомнить Уильяма Росса Эшби (психиатр, изучал кибернетику и сложные системы), который &lt;a href=&quot;https://fedorovpishet.ru/sistema-zapisej-uilyama-rossa-eshbi-bloknoty-na-maksimalkah/&quot;&gt;заметки вел в виде пачки нумерованных блокнотов с кросс ссылками&lt;/a&gt;. Хоть подход Эшби мне идейно ближе, но использовать рукописные блокноты для исследований в 2k24 кажется архаично.&lt;/p&gt;
  &lt;/div&gt;
&lt;/details&gt;

&lt;h3 id=&quot;о-связях&quot;&gt;О связях&lt;/h3&gt;

&lt;p&gt;Связи между заметками – самое ценное и важное, что есть в моей базе знаний. Это то, что помогает либо глубже разбираться в темах (как пример – &lt;a href=&quot;https://pepegramming.site/questions/data-model/&quot;&gt;ответ на вопрос с визуализацией бд&lt;/a&gt;), либо находить идейную дичь, которую потом можно раскрутить (например связь рефакторинга производства в factorio с рефакторингом software системы).&lt;/p&gt;

&lt;p&gt;Еще примеры связей, которые появились благодаря заметкам:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Используя две не связанных на первый взгляд темы с гранулярностью событий и state/delta событиями, появился ответ на &lt;a href=&quot;https://pepegramming.site/questions/make-events-small/&quot;&gt;вопрос с матрицей размера событий&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Если проходили курс по анализу систем, то идея с инстабилити появилась, потому что нашлись две заметки которые связались через инстабилити;&lt;/li&gt;
  &lt;li&gt;Если слышали от меня идею о system form и system function в контексте EventStorming и модели данных, то это тоже благодаря связям, которые появились в заметках во время ресерча system engineering;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Так как приходится искать связи между темами, что бы из этого получались идеи для контента, то мои заметки можно представить как систему, в которой чем выше каплинг между заметками, тем лучше система работает. Для этого использую три базовых вида связей, два вида валидирую и с одним играю в свободное время.&lt;/p&gt;

&lt;h4 id=&quot;базовая-связь-прямые-ссылки-между-заметками&quot;&gt;Базовая связь: прямые ссылки между заметками&lt;/h4&gt;

&lt;p&gt;Открываем заметку и вставляем явную ссылку на другую заметку. В моей картине мира это «явная» связь, так как ссылка будет доступна не только в обсидиане, но и в другом редакторе (и даже git репозитории). По этой же причине не люблю wiki style, поэтому ссылки использую как в маркдауне (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[]()&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Различаю два вида ссылок, которые похожи на то, что можно найти в википедии. Научных названий таких ссылок не знаю, поэтому назову «как чувствую»:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;«Референс ссылка». Использую в тексте заметки. Т.е. когда говорю о maintainability, ссылаюсь на заметку о maintainability;&lt;/li&gt;
  &lt;li&gt;«Связанные заметки». Похожие на нижний блок в вики странице, где указываются референсы на другие статьи по теме;&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/wiki-link-types-example.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Где икать каждый из двух видов ссылок в википедии&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;базовая-связь-теги&quot;&gt;Базовая связь: Теги&lt;/h4&gt;

&lt;p&gt;Каждой заметки ставлю набор тегов по ключевым идеям. Знаю, что есть подход, когда вместо тегов используют заметки, но слишком ленивый для такого.&lt;/p&gt;

&lt;p&gt;Когда надо найти заметки по теме – в первую очередь ищу по тегу. После смотрю связанные прямой ссылкой заметки, чтобы получить «месиво» информации.&lt;/p&gt;

&lt;p&gt;По тегам не заморачиваюсь. Т.е. никаких вложенных тегов не использую, строгого наименования не придерживаюсь. Иногда «рефакторю», когда понимаю, что &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#event&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#events&lt;/code&gt; один и тот же тег.&lt;/p&gt;

&lt;h4 id=&quot;базовая-связь-папки&quot;&gt;Базовая связь: папки&lt;/h4&gt;

&lt;p&gt;Так как придерживаюсь PARA, то использую 5 «базовых» папок:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Inbox&lt;/strong&gt; – инбокс, в которой попадают новые заметки, которые пока не понимаю где должны находиться (если сразу знаю – пропускаю inbox);&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Projects&lt;/strong&gt; – рабочие проекты в которых собираю либо информацию по проекту (если с работой связано), либо пишу текст (аутлайн для выступлений), если проект связан с контентом. Например, ответы на вопросы пишу в этой папке;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Areas&lt;/strong&gt; – Тут базовая информация по «области» в которой ведется работа. Это может быть как название компании где работаю, так и название конференции или еще чего;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;References&lt;/strong&gt; – тут заметки созданные во время изучения. Т.е. информация по характеристикам, системной инженерии и прочему, попадает сюда. Файлы раскидываю по вложенным папкам как сам считаю нужным, но чаще по темам: все вокруг анализа систем в одно место, вокруг солюшен архитектуры в другое и так далее;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Archive&lt;/strong&gt; – тут находятся закрытые проекты или компании, с которыми больше не работаю;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;связь-которую-валидирую-метатеги&quot;&gt;Связь которую валидирую: Метатеги&lt;/h4&gt;

&lt;p&gt;Берем заметку и указываем в метатегах кто автор, где опубликована, категорию (область), подкатегорию и какая проблема решается заметкой. После, получаем дополнительные связи по авторству, проблемам и так далее. Плюс в том, что одни и те же проблемы могут решаться в разных категориях, плюс можно посмотреть чем занимаются авторы и как авторы влияют на базу знаний.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/metatags-connections-example.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример того, как могут выглядеть «области» метатегов, где в каждой области свой набор заметок, который может лежать в разных папках и тегах. Картинку взял из статьи, которая вдохновила на эксперимент с метатегами&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;На словах звучит заманчиво, на деле – из-за количества заметок которые надо обновить ничего сказать не могу и пока только валидирую на сколько адекватно так заморачиваться. Идею &lt;a href=&quot;https://habr.com/ru/articles/806339/&quot;&gt;честно украл&lt;/a&gt;, может быть через пару лет смогу фидбек написать, но пока сказать нечего.&lt;/p&gt;

&lt;h4 id=&quot;связь-которую-валидирую-graph-analysis-plugin&quot;&gt;Связь которую валидирую: graph-analysis plugin&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/SkepticMystic/graph-analysis&quot;&gt;Для обсидиана сделали плагин, который анализирует граф связей&lt;/a&gt; используя алгоритмы для поиска подобия, co-citations, link prediction и поиска групп заметок. Иногда пользуюсь, но пользы пока не вижу, поэтому просто валидирую.&lt;/p&gt;

&lt;h4 id=&quot;балуюсь-в-свободное-время-векторное-подобие&quot;&gt;Балуюсь в свободное время: векторное подобие&lt;/h4&gt;

&lt;p&gt;Это скорее в планах ибо инструментов нормальных нет. Идея в том, что бы &lt;a href=&quot;https://www.couchbase.com/blog/what-is-vector-search/&quot;&gt;перевести заметки в векторы и после искать подобие&lt;/a&gt;. Благодаря этому можно найти связи, которые пропустил из-за того, что либо забыл о существовании заметки, либо потому что не нашел связь. &lt;/p&gt;

&lt;p&gt;Из того, что пробовал, самое похожее – &lt;a href=&quot;https://github.com/brianpetro/obsidian-smart-connections&quot;&gt;плагин smart connections&lt;/a&gt;. Но плагин работает только с английским языком (и одна модель для китайского), а локальную llama не поддерживает (но в планах), из-за чего жду развития. &lt;a href=&quot;https://khoj.dev&quot;&gt;Khoj&lt;/a&gt; похож, но требует отдельный сервис и нормально искать связи с плагином не получается.&lt;/p&gt;

&lt;h3 id=&quot;о-global-graph&quot;&gt;О global graph&lt;/h3&gt;

&lt;p&gt;Когда обсидиан появился – глобальный граф считался киллер фичей. Авторы любят показывать персональные графы, например такие:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/personal-obsidian-global-graph.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Если страдаете трипофобией – простите&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Сначала идея с глобальным графом нравилась, но когда заметок стало больше 500 штук –  граф потерял смысл из-за каши в визуализации (плюс электрон глючить начинает и фризить). Но, граф помогает с анализом «качества» прямых связей между заметками.&lt;/p&gt;

&lt;p&gt;Давайте на примере расскажу, что имею в виду.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/example-obsidian-global-graph.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Граф, который нашел в интернете. Попробуйте определить что тут не так с базой знаний&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Кажется, что граф как граф. На деле, по такой картинке можно найти два с половиной вида проблем:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;«Болтающиеся» заметки. Т.е. заметки, которые никак не связаны с другими заметками. Следовательно, используя такие заметки для создания контента, придется дополнительно думать как и с чем связаны записи, что время и силы, плюс меньше шансов найти нужную заметку;&lt;/li&gt;
  &lt;li&gt;«Цветы» в виде заметок, которые связаны только с корневой заметкой. Такие заметки появляются вокруг одной темы и это может говорить о двух проблемах: доп заметки в рамках темы не связаны между собой, либо эти заметки так же будет сложно использовать для создания контента;&lt;/li&gt;
  &lt;li&gt;Частный случай «цветов» –  отростки к одной заметке и без связей;&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/example-obsidian-global-graph-with-issues.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Красное – «цветы», синее – «болтающиеся» заметки&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Сразу скажу, что у меня присутствуют те же проблемы, что описаны выше. Можно заметить, что в моих заметках выделяется «core» часть, которую стараюсь держать максимально связанной и границы, где все не так хорошо, как могло бы быть:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/personal-obsidian-global-graph-issues.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;В центре связанность высокая, но по границам много «цветов» и болтающихся заметок в воздухе&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Вот благодаря глобальному графу можно быстро определить проблемы среди заметок и фиксить конкретные места. Например, раз в пол года, я выделяю себе пару недель чтобы поправить эти места, но раз и навсегда такое не исправить, что огорчает.&lt;/p&gt;

&lt;h3 id=&quot;о-dataview&quot;&gt;О dataview&lt;/h3&gt;

&lt;p&gt;Знаю, что в комьюнити обсидиана любят &lt;a href=&quot;https://blacksmithgu.github.io/obsidian-dataview/&quot;&gt;dataview&lt;/a&gt;. Проблема тут в том, что связи, которые получаются через dataview становятся не явными (т.е. нельзя увидеть по тексту или перекрестным ссылкам ну и вне обсидиана dataview не работает). Из-за этого теряются связи во время работы над контентом. Плюс, нет гарантий, что dataview будет жить вечно и появится в других заметках (если обсидиан отвалится в будущем).&lt;/p&gt;

&lt;p&gt;Из-за этого использую dataview только для анализа: поиска заметок без тегов, без связей, либо с небольшим количеством связей и так далее. Если бы чаще требовались каталоги и MoC (Map of Content) заметки – использовал чаще.&lt;/p&gt;

&lt;h3 id=&quot;о-плагинах&quot;&gt;О плагинах&lt;/h3&gt;

&lt;p&gt;Еще при работе с vim привык использовать по минимуму плагинов. С обсидианом ситуация аналогичная. Помимо dataview, smart connections и канбан досок, каждый день использую еще три плагина:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/esm7/obsidian-vimrc-support&quot;&gt;Obsidian Vimrc Support Plugin&lt;/a&gt;. Тут без комментариев, 12+ лет в виме меняют личность;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ozntel/oz-image-in-editor-obsidian&quot;&gt;Ozan’s Image in Editor Plugin&lt;/a&gt;. Мне не нравится разделение на edit/view для заметок. Особенно бесит, что надо открывать view мод что бы картинки посмотреть (так было 3 года назад, как сейчас – не знаю). Плагин рендерит картинки в edit моде обсидиана;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Vinzent03/find-unlinked-files&quot;&gt;Find orphaned files&lt;/a&gt;. Пользуюсь редко, но пару раз в год верифицирую заметки на наличие проблем в ссылках;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;как-использую-заметки-для-создания-контента&quot;&gt;Как использую заметки для создания контента&lt;/h3&gt;

&lt;p&gt;В самом начале выбираю тему для контента. Если это рабочий документ, то повезло. Но если это выступление, пост или курс, то тут начинаются проблемы. &lt;/p&gt;

&lt;p&gt;Знаю, что есть люди, которым придумывать темы легко, но это не мой случай. Либо выбираю тему, которая самому интересна или которой занимаюсь в текущий момент, либо прошу других придумать темы. Так, могу написать организаторам конференции с вопросом «о чем стоит рассказать», либо собрать проблемы в компании, либо посмотреть вопросы из канала (&lt;a href=&quot;https://goo.gl/forms/iUd1Gufq6WnTsaO62&quot;&gt;вопрос можно написать тут&lt;/a&gt;). Иногда помогает вести список тем, с которыми хочется разобраться, но лично такой список понадобился 1 раз и после был удален. Пробовал выбирать темы по рандомному открытию заметок, но не помогло.&lt;/p&gt;

&lt;p&gt;Если нет строгого дедлайна, могу сделать заметку по теме и в свободное время накидывать туда материал для изучения или ссылки, которые хочу использовать для ресерча в будущем. Тогда заметка становится «ресерч заметкой».&lt;/p&gt;

&lt;p&gt;После выбора темы, делаю пустую заметку (или canvas) с которой буду работать. Заметку использую когда контент небольшой (например, ответы на вопросы или ADR), canvas – когда тема большая (чаще курсы). В этот момент начинается этап наполнения заметки материалом: собираю заметки которые нахожу в базе знаний, если чего-то нет или о теме ничего не знаю – иду исследовать и попутно добавляю информацию в обсидиан.&lt;/p&gt;

&lt;p&gt;Собственные заметки ищу любым доступным способом: прямой поиск по словам, теги, метатеги. Иногда помню, что есть нужная заметка в определенном месте. А для каждой заметки просматриваю связанные записи и каждую подходящую добавляю в «месиво» информации.&lt;/p&gt;

&lt;p&gt;После начинаю разбирать полученное «месиво» и делаю первую версию &lt;a href=&quot;https://www.eapfoundation.com/writing/process/outline/&quot;&gt;аутлайна&lt;/a&gt; из заметок, т.е. примерный план того, о чем будет контент. При этом, если заметки нужной нет по теме, то могу словами написать, чего не хватает. Это выглядит как список или план, который в будущем станет table of context. При этом, аутлайн может еще тысячу раз поменяться. Например, первоначальный аутлайн для этого ответа выглядел следующим образом (сравните с тем, что по итогу вышло):&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Зачем мне нужна база знаний нужна
## Целепологание
## Свалка для всего vs только специфичная информация
## Зачем база знаний для генерации контента
## Что делать, если цели другие
# Как веду базу знаний
## базовые принципы
## Советы
## Трейдоффы с которыми живу
## О каких подходах рассказать
## Про датавью
## Про темплейты
# Как использую базу знаний для создания контента
# Выводы
# Ссылки
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Если контент большой, отдельная заметка с темами превратится в кашу, которую будет сложно поддерживать. В этот момент выручает whiteboard в виде canvas.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/aa-course-outline.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример аутлайна для &lt;a href=&quot;https://tough-dev.school/architecture&quot;&gt;новой версии АА курса&lt;/a&gt;. После аутлайн дополняется заметками из базы знаний. А после уже пишется контент&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;После того, как появилась черновой аутлайн – начинаю писать. Для этого копирую текст из связанных заметок, что бы получился черновик.После этого &lt;a href=&quot;http://maximilyahov.ru/blog/all/meatballs/&quot;&gt;наполняю «мясом» текст&lt;/a&gt;, редактирую, вычитываю и переписываю. В случае с выступлениями, делаю аналогичную работу, только презентация основывается на аутлайне, который сделал ранее.&lt;/p&gt;

&lt;h3 id=&quot;риски-и-проблемы-с-которыми-живу&quot;&gt;Риски и проблемы с которыми живу&lt;/h3&gt;

&lt;p&gt;Может показать, что обсидиан решает любые проблемы и лучше ничего нет для ресерча и поиска связей. На деле проблем хватает:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Чем выше каплинг (а это цель), тем сложнее работать с заметками, т.е. добавлять и связывать сложнее становится, на это тратится время. «Голый» обсидиан не помогает. Единственное, жду момента, когда llm модели научаться нормально работать с обсидианом для поиска потенциальных связей между заметками. Благодаря чему, надеюсь, сил на добавление заметок будет уходить меньше;&lt;/li&gt;
  &lt;li&gt;Приходится тратить время на саму базу знаний и ситуации в духе «добавлю заметку, может потом понадобиться». По ощущениям выходит около 95% работы с базой знаний и 5% написания контента. Я смирился, но задумываюсь о цене такого подхода;&lt;/li&gt;
  &lt;li&gt;Приходится регулярно убирать техдолг: проставлять ссылки, проставлять теги, добавлять что-то, убирать лишнее, разбирать заметки состоящие только из одной ссылки и так далее. Без этого база знаний начинает «протухать». С другой стороны, работа над тех долгом сжирает кучу сил и времени, что приводит к фрустрации;&lt;/li&gt;
  &lt;li&gt;Переезжать между инструментами – боль. Т.е. либо делаете заметки, либо постоянно пробуете новые инструменты. Аналогично с подходами. В текущем виде мне сложно метатеги проставить для связей, а переехать на зетелькастен или другой «фреймворк» – непосильная задача;&lt;/li&gt;
  &lt;li&gt;Электрон – боль. Global graph лагает и иногда возникают странности в поведении. Vim keybindings работают криво, не все цветовые схемы корректно работают с плагинами. Зато любой элемент можно в девтулзах подправить;&lt;/li&gt;
  &lt;li&gt;Работа с мобильных устройств вызывает только апатию. Изначально думал, что с телефона или планшета будет комфортно работать с заметками вне дома. Но чуда не произошло, проще быстро написать идею в saved messages в тг, а потом обработать с компа. Читать книги и делать заметки с айпада без клавиатуры смысла нет, но тогда возникает вопрос, почему не взять ноутбук;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tips--tricks&quot;&gt;Tips &amp;amp; tricks&lt;/h3&gt;

&lt;h4 id=&quot;учеба-и-работа-с-базой-знаний&quot;&gt;Учеба и работа с базой знаний&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Верифицируйте, что заметки решают проблему. Т.е. если решили делать контент и для этого занимаетесь базой – делайте контент регулярно, а не раз в пять лет. Например, ответы на вопросы – регулярная проверка того, что текущей базой можно пользоваться;&lt;/li&gt;
  &lt;li&gt;Учиться лучше каждый день и регулярно, чем 1 день в неделю по 3.5 часов. Если времени нет, могу сам себе позволить абзац книги прочитать или одну статью. Так появляется привычка и нет «раскачки»;&lt;/li&gt;
  &lt;li&gt;Забейте на размер заметок. Лучше написать лонгрид с 10 идеями, чем два часа думать как разбить заметки на атомарные идеи. В крайнем случае, лонгрид можно будет «отрефакторить» после. Иногда помогает сделать конспект статьи в одной заметке, а потом раскидать на атомарные заметки. С пейперами так получается продуктивнее;&lt;/li&gt;
  &lt;li&gt;Совет, который  игнорирую. Отдых важен, если каждый день учиться, через два месяца тошнить будет. Поэтому, 1 день в неделю лучше отдохнуть, иначе можно быстро выгореть;&lt;/li&gt;
  &lt;li&gt;Указывайте референсы. Т.е. откуда взяли заметку и в каких условиях (кто посоветовал, как нашли и так далее). Даже если это обсуждение в чате, либо ссылка на вики. Потом проще перечитать будет, если надо будет дополнить информацию, плюс можно референс в конце контента делать, не тратя время на поиски;&lt;/li&gt;
  &lt;li&gt;Журналы, как заметки во времени, полезная штука, но польза появляется только в будущем. Например, когда хочется понять по какой причине появилась запись. Благодаря этому сохраняется контекст, в котором появилась мысль, что идейно близко к ADR;&lt;/li&gt;
  &lt;li&gt;Личное предпочтение. Лучше явная связь через линк, чем не явная по датавью. Связанно это с тем, что явную связь проще найти в тексте поиском, плюс нет гарантий, что завтра датавью будет работать так же как и сегодня;&lt;/li&gt;
  &lt;li&gt;Иногда хочется сохранить ссылку на будущее, что бы прочитать и для этого делается «пустая» заметка только с ссылкой. Спустя время такие заметки начинают только мешать ибо смысла не имеют. Советую добавлять контекст, для которого не придется читать текст: почему ссылка понравилась, что стоит прочитать, где планируете воспользоваться информацией и почему считаете, что информация из ссылки полезна;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;обсидиан&quot;&gt;Обсидиан&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Переименовывайте картинки так, чтобы в названии было объяснение к чему картинка. Позволит быстро понять что к чему и не запутаетесь, если в папке много картинок. Плюс по ним будет работать поиск;&lt;/li&gt;
  &lt;li&gt;Можно добавлять pdf файл с книгой/пейпером к MoC заметке с названием книги/пейпера. Благодаря этому не придется каждый раз искать книгу, что бы проверить оригинал;&lt;/li&gt;
  &lt;li&gt;Global graph может показаться бессмысленным, когда заметок много. Но если использовать граф для контроля качества базы знаний, можно экономить время;&lt;/li&gt;
  &lt;li&gt;Выделяйте время на рефакторинг заметок. Если забить, то можно придти к тому, что заметки не имеют никакого смысла. Под рефакторингом подразумеваю: заполнение пустых заметок, проставление тегов, метатегов и прочего, чистка дублей или не нужных заметок и так далее;&lt;/li&gt;
  &lt;li&gt;Плагин на превью картинок мастхев. Без него замучаетесь переключаться между edit/view;&lt;/li&gt;
  &lt;li&gt;Вместо того, чтобы сразу ставить 100+ плагинов, попробуйте воспользоваться «голым» приложением, после чего ставить плагины под возникающие проблемы (если собираете комбайн – можно проигнорировать). Так, dataview поставил спустя 3 года после начала использования обсидиана;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;выводы&quot;&gt;Выводы&lt;/h2&gt;

&lt;p&gt;Три вывода, которые хочется донести:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Выбирайте инструмент под задачу, а не задачу под инструмент. Для этого придется честно ответить самому себе что за проблема появилась и стоит ли на нее тратить силы. После, стоит выбрать стиль, которым задача будет решена, а потом уже думать об инструменте;&lt;/li&gt;
  &lt;li&gt;Если нужно искать связи - обсидиан рабочий инструмент. Не идеальный, с проблемами и заскоками, но пользоваться можно. Если думаете что выбрать из 2+ инструментов – попробуйте каждый и только после выбирайте. Если привыкли писать от руки – посмотрите на метод Уильяма Росса Эшби, который &lt;a href=&quot;https://fedorovpishet.ru/sistema-zapisej-uilyama-rossa-eshbi-bloknoty-na-maksimalkah/&quot;&gt;заметки вел в виде пачки нумерованных блокнотов с кросс ссылками&lt;/a&gt;;&lt;/li&gt;
  &lt;li&gt;Используйте обсидиан как хотите, тут нет гайдов и «стандартов» (ну или я не видел). Можете попробовать описанный в ответе вариант, можете взять за основу чужой. Тут важнее не структуру и подходы настраивать и менять, а получать выгоду от заметок решая проблемы из первого вывода, при этом используя инструмент так, как удобнее;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ведение заметок - труд и серьезная инвестиция. При этом, инструмент не влияет на качество заметок и качество использования базы знаний, поэтому выбирайте то, что ближе или нравится внешне больше. Тратить силы на базу знаний или нет – решать вам, но если бы не создание контента, я бы лучше тратил время на путешествия;&lt;/p&gt;

&lt;h2 id=&quot;ссылки&quot;&gt;Ссылки&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;[ru] Специфический &lt;a href=&quot;https://habr.com/ru/users/flowing_abyss/publications/articles/&quot;&gt;блог на хабре&lt;/a&gt;, где автор дотошно расписывает темы связанные с продуктивностью. Читаю каждый пост, но советую изучать идеи, а не описанные реализации&lt;/li&gt;
  &lt;li&gt;[ru] Если интересуетесь темой заметок, &lt;a href=&quot;https://qnnnp.substack.com&quot;&gt;знаете блог&lt;/a&gt;. Если нет – автор занимается занимается изучением принципов и приёмов учебной и научной деятельности. Тематика вращается вокруг систем управления знаниями. Советую две статьи об инструментах для заметок: &lt;a href=&quot;https://qnnnp.substack.com/p/pkm&quot;&gt;первая&lt;/a&gt; и &lt;a href=&quot;https://qnnnp.substack.com/p/f20&quot;&gt;вторая&lt;/a&gt;;&lt;/li&gt;
  &lt;li&gt;[ru] Базовый &lt;a href=&quot;https://vas3k.club/post/25661/&quot;&gt;гайд по logseq&lt;/a&gt;, который объяснит идеи и концепции приложения. Только для тех, кто решит попробовать приложение;&lt;/li&gt;
  &lt;li&gt;[ru] Тема журналов продолжает &lt;a href=&quot;https://ailev.livejournal.com/1513051.html&quot;&gt;подход «мышление письмом»&lt;/a&gt; и помогает в ситуации, когда понимаете, что застряли. Т.е. выгружаете мысли из головы в текст во временном порядке. Потом к чему-то придете, но записи остануться и к ним можно будет вернуться в будущем. Например подкорректировать и сделать из этого пост, либо ADR;&lt;/li&gt;
  &lt;li&gt;[ru] Если захотите с zettelkasten разобраться – &lt;a href=&quot;https://fedorovpishet.ru/all-about-zettel/&quot;&gt;советую статью в которой собраны ресурсы по теме&lt;/a&gt;. Плюс &lt;a href=&quot;https://vas3k.club/post/3040/&quot;&gt;гайд из vas3k.club&lt;/a&gt; (советую посмотреть связанные посты);&lt;/li&gt;
  &lt;li&gt;[ru] Если хотите посмотреть процесс работы с заметками, &lt;a href=&quot;https://t.me/niceandeasyme/3275&quot;&gt;Тимур в своем тг канале иногда выкладывает записи того, как работает над заметками&lt;/a&gt;;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Как уменьшить размер события в асинхронных коммуникациях</title>
   <link href="http://pepegramming.site/questions/make-events-small/"/>
   <updated>2024-08-30T00:00:00+03:00</updated>
   <id>http://pepegramming.site/questions/make-events-small</id>
   <content type="html">&lt;h2 id=&quot;вопрос&quot;&gt;Вопрос&lt;/h2&gt;

&lt;div class=&quot;question-text&quot;&gt;
  &lt;blockquote&gt;
    &lt;p&gt;Привет!&lt;/p&gt;

    &lt;p&gt;Вопрос: что делать если требуется чтоб в message bus были максимально короткие сообщения?&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/div&gt;

&lt;p&gt;Так как вопрос абстрактный, то можно выделить две ситуации, в которой необходимо «короткое» событие:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хочу короткие сообщения, потому что так «принято»;&lt;/li&gt;
  &lt;li&gt;Есть проблема с брокером/трафиком/деньгами, и нужно решение для уменьшения размера payload в событии. При этом, концептуально событие корректно;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Давайте рассмотрим каждый из вариантов.&lt;/p&gt;

&lt;details class=&quot;collapse_block&quot;&gt;
  &lt;summary class=&quot;collapse_block__title&quot;&gt;Заумь: душный кусок, который задает понятийный аппарат и который можно пропустить&lt;/summary&gt;

  &lt;div class=&quot;collapse_block__content&quot;&gt;

    &lt;p&gt;К сожалению, без духоты, в виде зауми, могут появиться додумки или недопонимания, поэтому лучше договориться на берегу.&lt;/p&gt;

    &lt;p&gt;Дальше по тексту будут использоваться три термина связанных с событиями, поэтому давайте договоримся на берегу, что подразумевается под каждым из терминов.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Событие (event)&lt;/strong&gt; – факт того, что произошло в прошлом. Всегда именуется глаголом в прошедшем времени, причем безвозвратным. Например, если что-то покупается в интернет магазине, то событие будет “заказ оформлен”;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Команда (command)&lt;/strong&gt; – действие которое кто-то должен выполнить, обозначаются глаголом в настоящем времени. Если вернуться к примеру с заказом, то “оформить заказ”, как действие, можно отправить асинхронно. Для команд, текст ниже также валиден;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Payload&lt;/strong&gt; – кроме названия того, что произошло, нужен и контекст, который добавляет конкретной информации, что именно произошло. Т.е. если мы “оформили заказ”, то желательно знать что это за заказ (хотя бы его id), кто это сделал, когда, какие товары были в заказе, какая стоимость (общая и каждого товара) и так далее. Все это является контекстом события, который находится в payload-е события. Для команды аналогично;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Событие в общем виде можно представить так

event ItemAddedToCart { # ItemAddedToCart - название события
  id: int, # тут описываем payload
  # ... 
}

# Команда выглядит так

command AddItemToCart { # AddItemToCart - название команды, которую кто-то выполнит
  id: int, # тут описываем payload
  # ... 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Бизнес событие&lt;/strong&gt; – событие которое говорит о том, что какой-то бизнес процесс завершился с каким-то результатом. Если знакомы с EventStorming – оранжевый стикер с событием будет аналогом. Если знакомы с DDD – domain event близок по смыслу;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Продьюсинг и консьюминг (producing/consuming)&lt;/strong&gt; – терминология из кафки (и аналогов). Producer отправляет события, consumer потребляет. В кролилке любят использовать publisher/subscriber терминологию, что одно и тоже. Но в ответе будет использоваться терминология из кафки;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Брокер (message broker)&lt;/strong&gt; – очередь/распределенный лог/стриминг платформа используемый для передачи событий из A в B;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;Вот об уменьшении payload-а события и поговорим в контексте вопроса.&lt;/p&gt;

  &lt;/div&gt;
&lt;/details&gt;

&lt;h2 id=&quot;хочу-короткие-сообщения-потому-что-так-принято&quot;&gt;Хочу короткие сообщения, потому что так «принято»&lt;/h2&gt;

&lt;p&gt;Первое, с чего надо начинать, когда дело касается размера payload в событии – определиться с двумя концепциями: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state (fact) vs delta (action) events&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;event granularity&lt;/code&gt;. Чаще эти два понятия даются отдельно и не связывают между собой. Но сегодня особый случай – будем рассматривать концепции в связке.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/fine-coarse-state-delta-matrix.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;«Матрица» связи state/delta и event granularity концепций, которую будем использовать дальше&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;state-fact-vs-delta-action-events&quot;&gt;State (fact) vs delta (action) events&lt;/h3&gt;

&lt;p&gt;Существует два подхода к хранению состояния в событиях:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;State (or fact) event – хранит полное состояние агрегата/бизнес события на момент продьюсинга;&lt;/li&gt;
  &lt;li&gt;Delta (or action) event – хранит только изменения которые произошли в событие на момент продьюсинга;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/state-vs-delta-events.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример двух одинаковых событий: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ItemAddedToOrder&lt;/code&gt;. В delta событии показывается только то, что изменилось, в state – указывается весь «снапшот» &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order&lt;/code&gt; агрегата&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Дополнение:&lt;/strong&gt; считается, что событие не может быть наполовину state и на половину delta. Но в реальности встречал ситуации, когда передавался полный агрегат + изменения только вложенных данных. Поэтому считаю значения не бинарными в этом ответе.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;плюсы-и-минусы-state-events&quot;&gt;Плюсы и минусы state events&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Плюсы&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Так как не надо считать состояние из кучи delta событий (которые могут быть разбросаны по разным очередям/топикам), то можно пропустить прошлые события, чтобы получить текущий слепок состояния;&lt;/li&gt;
  &lt;li&gt;Если меняется схема событий – проще исправить одно state событие, чем пачку delta;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Минусы&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cобытие может оказаться слишком большим (наш случай);&lt;/li&gt;
  &lt;li&gt;Не понятно что изменилось, если ордеринг событий нарушится. Из-за этого можно будет обновить новые данные на старые и получить не консистентный стейт;&lt;/li&gt;
  &lt;li&gt;Если изменения частые, может быть действительно слишком много лишних данных об одном и том же;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;плюсы-и-минусы-delta-events&quot;&gt;Плюсы и минусы delta events&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Плюсы&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;События будут меньше по размеру, в отличии от state событий, так как там не будет ничего лишнего;&lt;/li&gt;
  &lt;li&gt;Если изменения частые – можно выиграть в трафике и количестве данных, которые храняться на стороне консьюмера;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Минусы&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Исправление проблем со схемой событий может стать еще большей проблемой. Частный случай – решение проблемы GDPR и другие “удаления” данных могут быть проблемными;&lt;/li&gt;
  &lt;li&gt;Придется следить за event ordering;&lt;/li&gt;
  &lt;li&gt;Если для обработки события нужен полный агрегат (все данные агрегата) – придется хранить локальное состояние агрегата;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;event-granularity&quot;&gt;Event granularity&lt;/h3&gt;

&lt;p&gt;Вторая концепция раскрывает идею state/delta событий, но в плоскости полезности и полноты события. Для этого вводятся понятия coarse и  fine событий.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/fine-vs-coarse-events.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример двух одинаковых событий с добавлением товара в корзину. В coarse событии слишком много не понятно зачем относящихся данных, fine событие слишком специфичное и мелкое&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;coarse-событие&quot;&gt;Coarse событие&lt;/h4&gt;

&lt;p&gt;Такие события большие и общие (т.е. обо всем сразу), содержат дженерик нейминг и кучу данных не обязательных (и местами не нужных) для работы консьюмера.&lt;/p&gt;

&lt;p&gt;Иногда встречаются ситуации, когда событие так себе называется и контекст того, что произошло, можно понять только через чтение данных. Из-за этого бизнес логика просачивается на сторону консьюмера.&lt;/p&gt;

&lt;h4 id=&quot;fine-событие&quot;&gt;Fine событие&lt;/h4&gt;

&lt;p&gt;Такие события слишком мелкие и специфичные. Чаще нормально называются, но слишком в них мало информации для работы бизнес логики&lt;/p&gt;

&lt;p&gt;Считается, что такое событие не юзабельно без других событий, следовательно приходится их комбинировать и это может привести к проблемам, что потенциально может привести к проблемам с event ordering.&lt;/p&gt;

&lt;h3 id=&quot;собираем-концепции-вместе&quot;&gt;Собираем концепции вместе&lt;/h3&gt;

&lt;p&gt;Если соединить две концепции, то появляется пространство выбора, в котором можно определить как оптимальный размер события, так то, на сколько общим (generic) событие будет в системе.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/fine-coarse-state-delta-matrix-event-size.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Примерное описание того, какой размер события ожидать в каждом из мест «матрицы». Цветом показал ожидаемый размер события. Fine delta событие будет самым мелким, поэтому стикер зеленый&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;В таком ключе, вся работа над размером событий сводится к тому, что бы сначала сначала определяется какой вид события нужен: state или delta. После чего определяем проблему гранулярности события и решаем найденную проблему.&lt;/p&gt;

&lt;p&gt;Благодаря этому можно выбирать размер события. Что приводит к тому, что каждое событие будет оптимально по размеру и контексту под заданные требования и ограничения. Благодаря чему можно отказаться от «моды»/советов на delta события без данных, просто потому что в компании Х используется такой подход по дефолту.&lt;/p&gt;

&lt;p&gt;Но у такого подхода присутствует и минус: придется думать над каждым событием, что может привести к разногласиям в команде, либо же к проблемам, если разработчики не скиловые. Можно решить что хватит delta/fine события, а потом окажется, что не попали в требования. Из-за чего придется заниматься дорогой и сложной эволюцией схемы события.&lt;/p&gt;

&lt;h2 id=&quot;событие-корректное-по-размеру-но-слишком-большое-для-системы&quot;&gt;Событие корректное по размеру, но слишком большое для системы&lt;/h2&gt;

&lt;p&gt;К сожалению, использование концепции &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state (fact) vs delta (action) events&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;event granularity&lt;/code&gt; не спасает в 100% случаев от проблем с размером события. Возможна ситуация, когда необходим state event, который при этом должен быть coarse. Т.е. вообще никак не выбрать ничего другого. А размер события должен быть максимально небольшим ибо специфика брокера/нет денег на инфру/etc.&lt;/p&gt;

&lt;p&gt;Чтобы решить эту проблему перечислю точечные подходы, которые разбиваются на две группы:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;уменьшаем payload сообщения с помощью паттернов *;&lt;/li&gt;
  &lt;li&gt;увеличиваем допустимые размеры сообщения в брокере;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;* Для некоторых вариантов придется подумать о консистентности данных в payload, ибо не все варианты работают со strong consistency.&lt;/p&gt;

&lt;h3 id=&quot;уменьшение-размера-сообщений-без-потери-гранулярности&quot;&gt;Уменьшение размера сообщений без потери гранулярности&lt;/h3&gt;

&lt;h4 id=&quot;убрать-лишние-данные-в-ручную&quot;&gt;Убрать лишние данные в ручную&lt;/h4&gt;

&lt;p&gt;Очевидное решение, пересекающее с концепциями из первой части ответа: берем событие, смотрим какие данные нужны в каждом консьюмере события, после чего, ковыряясь в payload, выкидываем лишние данные. Т.е. делаем событие больше fine чем coarse:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/less-coarse-event.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Может оказаться, что событие надо сделать не таким coarse, следовательно, по «матрице» оно опустится чуть ниже&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;event-notification&quot;&gt;Event notification&lt;/h4&gt;

&lt;p&gt;Если получали смс «осторожно, будет шторм», а потом шли смотреть где шторм, когда и кого зацепит – значит знакомы с паттерном.&lt;/p&gt;

&lt;p&gt;По сути, паттерн частный случай delta события. Идея такая: отправляем событие, что что-то произошло, но контекст просим получить с помощью синхронного вызова. Подход нужен в двух случаях: когда необходимо передать большое количество данных, либо когда нужно максимально консистеные данные получить в событии. В контексте ответа на вопрос интересен первый случай.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/event-notification-example.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример реализации event notification паттерна. Сначала отправляется событие с ссылкой на ресурс. После этого, консьюмер, делает запрос за данными и получает контекст&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Подобным образом можно передавать аттачменты в событиях: кидаем файл в s3, получаем ссылку, а после ссылку передаем в событии, благодаря чему можно не грузить гигабайты видео и картинок в брокер.&lt;/p&gt;

&lt;p&gt;Из минусов подхода – появляется дополнительный каплинг за счет синхронной связи, что влияет на reliability, availability и другие характеристики.&lt;/p&gt;

&lt;h4 id=&quot;воспользоваться-бинарной-сериализацией&quot;&gt;Воспользоваться бинарной сериализацией&lt;/h4&gt;

&lt;p&gt;Если удалять из схемы payload нечего, а использовать синхронный вызов не позволяют характеристики, можно ужать само сообщение. Для этого берем бинарный серелизатор и упаковываем payload. По итогу получаем ужатую строку, которая меньше на 25-50% чем оригинальный payload (больше данных - больше ужимает).&lt;/p&gt;

&lt;p&gt;Из минусов - без десериализации человек такую бинарную строку быстро не прочитает, в отличии от human-readable форматов (json, xml, etc). Еще из минусов – придется думать как консьюмер поймет какую схему использовать для десерелизации (либо 1 событие на топик/очередь, либо название события в headers кафки прокидывать).&lt;/p&gt;

&lt;p&gt;Популярные серелизаторы: &lt;a href=&quot;https://github.com/protocolbuffers/protobuf&quot;&gt;protobuf&lt;/a&gt; (в grpc используется), &lt;a href=&quot;https://github.com/apache/avro&quot;&gt;avro&lt;/a&gt;, &lt;a href=&quot;https://github.com/apache/thrift&quot;&gt;apache thrift&lt;/a&gt;. В некоторых языках реализованы решения из коробки, &lt;a href=&quot;https://www.erlang.org/doc/apps/erts/erl_ext_dist.html&quot;&gt;например в erlang&lt;/a&gt; (использовать только тем, кто контрибьютил в пакет).&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/avro-vs-protobuf-size-comparison.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Разработчик решил проверить, что будет если &lt;a href=&quot;https://cristian-matei-toader.medium.com/compressing-a-year-of-reddit-with-apache-avro-and-google-protobuf-c9e40cf90444&quot;&gt;ужать датасет kaggle 2015 года от reddit&lt;/a&gt;. Скриншот выше – итоговый результат, который мало говорит о том, что лучше, но показывающий как можно уменьшить размер события&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;message-chunking&quot;&gt;Message chunking&lt;/h4&gt;

&lt;p&gt;Если описанные выше варианты не подошли, можно воспользоваться идеей передачи больших данных в синхронных вызовах: поделить сообщение на чанки меньшего размера и вместо одного жирного события получить N мелких.&lt;/p&gt;

&lt;p&gt;Из минусов – проблемы с strong consistency для payload события, плюс проблемы упаковки чанков в событие на стороне консьюмера.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/message-chunking-example.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример из вики apache pulsar. Идея в том, что событие разбивается на чанки (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M1-C1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M1-C2&lt;/code&gt;), после чего консьюмер собирает из чанков исходное событие&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;передавать-часть-данных-в-других-событиях&quot;&gt;Передавать часть данных в других событиях&lt;/h4&gt;

&lt;p&gt;На первый взгляд решение может показаться идентичным message chunking, но концепция чуть отличается.&lt;/p&gt;

&lt;p&gt;Идея в том, что можно разделить связи между элементами в плоскости &lt;a href=&quot;https://en.wikipedia.org/wiki/Form,_fit_and_function&quot;&gt;system function и system form&lt;/a&gt;. Благодаря чему появится два вида связности: по данным (это form) и на уровне поведения (function). Это приводит к идее, что если присутствует событие, которое говорит о поведении, для обработки которого нужны данные, эти данные можно передать через system form связь.&lt;/p&gt;

&lt;p&gt;Для определения system form можно воспользоваться &lt;a href=&quot;https://pepegramming.site/questions/data-model/&quot;&gt;концептуальной data model&lt;/a&gt;, а для определения system function – любой моделью, описывающей поведение, например EventStorming.&lt;/p&gt;

&lt;h3 id=&quot;тюнинг-брокера&quot;&gt;Тюнинг брокера&lt;/h3&gt;

&lt;p&gt;Сразу скажу – не эксперт в инфраструктуре, поэтому накину идей. Лучше идите к DevOps инженерам или админам (сам так делаю).&lt;/p&gt;

&lt;p&gt;Как могу судить, тут два подхода: либо крутить конфиг брокера, либо использовать специфичные инструменты реализованные в брокере:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Если возникла проблема, что событие не влезает в брокер, то можно накрутить конфиг &lt;a href=&quot;https://stackoverflow.com/questions/21020347/how-can-i-send-large-messages-with-kafka-over-15mb&quot;&gt;кафки&lt;/a&gt; или &lt;a href=&quot;https://www.cloudamqp.com/blog/what-is-the-message-size-limit-in-rabbitmq.html&quot;&gt;кролика, но тут лимит в 128 мб&lt;/a&gt;. Для других брокеров думаю можно найти аналогичные настройки;&lt;/li&gt;
  &lt;li&gt;Если используете кафку, советую посмотреть в сторону &lt;a href=&quot;https://www.confluent.io/blog/apache-kafka-message-compression/&quot;&gt;message compression&lt;/a&gt;. Подход сработает для xml, json и прочего, что легко компрессируется и содержит дубли. По сути, аналог серелизации из списка выше;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Знаете еще варианты? Пишите в комментариях к тг посту, соберем список, а я дополню эту часть ответа.&lt;/p&gt;

&lt;h2 id=&quot;выводы&quot;&gt;Выводы&lt;/h2&gt;

&lt;p&gt;Уменьшение объема payload события не тривиальная задача, которую в первую очередь лучше решать через &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state (fact) vs delta (action) events&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;event granularity&lt;/code&gt; концепции. Но даже так, возникают ситуации, когда приходится точечно исправлять ситуацию, с чем помогают как паттерны, так и прямой конфиг брокера (если возможен).&lt;/p&gt;

&lt;p&gt;А чтобы собрать ответ в кучу, сделал decision flow диаграмму, которую сам использую, когда проектирую события, надеюсь поможет.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/event-size-decision-flow.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Флоу выбора решения, который использую, если дело касается размера payload события&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Хотя, в идеале, лучше жить в мире, в котором денег много, а инструменты не ограничивают в размере событий.&lt;/p&gt;

&lt;h2 id=&quot;ссылки&quot;&gt;Ссылки&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;[en]  &lt;a href=&quot;https://barryosull.com/blog/event-granularity-modelling-events-in-event-driven-applications/&quot;&gt;Статья, которая рассказывает о концепции event granularity с fine и coarse событиями&lt;/a&gt;. При этом, автор объясняет почему появляются те или иные виды событий события;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[en]  &lt;a href=&quot;https://developer.confluent.io/courses/event-design/fact-vs-delta-events/&quot;&gt;Статья о state и delta событиях&lt;/a&gt;. Текста много, но и объясняется куча нюансов;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;[en]  &lt;a href=&quot;https://www.funnel-labs.io/2022/08/26/data-serialization-apache-avro-vs-google-protobuf/&quot;&gt;Сравнение avro и protobuf серелизаторов&lt;/a&gt; между собой;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://dataintensive.net&quot;&gt;4 глава DDIA&lt;/a&gt; посвящена сериализации данных. Если не читали – рекомендую;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[en]  &lt;a href=&quot;https://cristian-matei-toader.medium.com/compressing-a-year-of-reddit-with-apache-avro-and-google-protobuf-c9e40cf90444&quot;&gt;Статья, в которой автор вдохновился DDIA и решил ужать датасет реддита&lt;/a&gt;, чтобы понять какой сериализатор лучше. Результат проверки найдете картинкой в ответе выше;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[en]  Советы по работе с большими сообщениями, которые описаны в вики apache pulsar. &lt;a href=&quot;https://github.com/apache/pulsar/wiki/PIP-37:-Large-message-size-handling-in-Pulsar#option-2-producer-publish-marker-message-after-publishing-all-chunked-messages&quot;&gt;Message chunking – один из вариантов решения&lt;/a&gt;;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[ru] Подробнее о разделении коммуникаций на поведение и данные (form, function) можно &lt;a href=&quot;https://f213.notion.site/dfa7f424ed8440d99a21c328cc8c5c65&quot;&gt;почитать в открытом уроке курса&lt;/a&gt;, по анализу систем, который сделал;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;[en] Автор дает &lt;a href=&quot;https://jcdubs.medium.com/aws-large-payload-pattern-e3e4c57d402d&quot;&gt;советы тем, кто использует aws инфраструктуру и хочет работать с большими событиями&lt;/a&gt;. Примеры кода на js;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Как слежу за большими проектами</title>
   <link href="http://pepegramming.site/questions/graph-as-a-project-managment-tool/"/>
   <updated>2024-08-16T00:00:00+03:00</updated>
   <id>http://pepegramming.site/questions/graph-as-a-project-managment-tool</id>
   <content type="html">&lt;h2 id=&quot;вопрос&quot;&gt;Вопрос&lt;/h2&gt;

&lt;div class=&quot;question-text&quot;&gt;
  &lt;blockquote&gt;
    &lt;p&gt;Привет!&lt;/p&gt;

    &lt;p&gt;Вопрос: как планируешь и следишь за долгими проектами? Особенно интересно что используешь для долгих проектов, которые дляться от года и больше, потому что в какой-то момент перестаю видеть «лес» за тасками в трекере.&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/div&gt;

&lt;p&gt;Давайте разбираться. Важно: я не менеджер, людьми не управляю. Отчеты по работе и планированием спринтов тоже не занимаюсь. Поэтому буду говорить с позиции solution architect и касаемо только рабочих проектов.&lt;/p&gt;

&lt;p&gt;При этом, описываться будет личный опыт, из-за чего допускаю, что ответ подойдет далеко не всем: кто-то следит за проектами в «джире», кто-то получает результат от менеджеров. Поэтому буду рад если описанный подход либо вдохновит, либо поможет в текущей ситуации.&lt;/p&gt;

&lt;p&gt;И еще одно уточнение: в тексте буду использовать «джира» как обобщенное слово для любого PM инструмента. О jira тоже поговорим.&lt;/p&gt;

&lt;h2 id=&quot;контекст-в-котором-приходится-планировать-работу&quot;&gt;Контекст в котором приходится планировать работу&lt;/h2&gt;

&lt;p&gt;Для начала стоит описать контекст в котором нахожусь как solution architect. С этим поможет первая глава &lt;a href=&quot;https://www.oreilly.com/library/view/solution-architecture-foundations/9781780175676/&quot;&gt;Solution Architecture Foundations&lt;/a&gt;, в которой описываются активности роли. Из списка хочется выделить три:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;управление доставкой решения, в которое входит роадмап из текущей ситуации в будущее, где проблема решена;&lt;/li&gt;
  &lt;li&gt;Организация процесса, в который входит коммуникации между стейкхолдерами на разные темы;&lt;/li&gt;
  &lt;li&gt;Взаимодействие со стейкхолдерами проекта, в которое входят как получение информации, которая потом шарится будет;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Как можете понять, я не занимаюсь менеджментом разработчиков и людей (да и не хочу). Поэтому мне не надо считать сторипоинты, гадать сколько эпиков влезет в спринт и продавать &lt;a href=&quot;https://community.atlassian.com/t5/App-Central/3-tools-to-analyze-Cycle-and-Lead-Time-in-the-Jira/ba-p/1403775&quot;&gt;красивые графики по распределению времени работы&lt;/a&gt;. С другой стороны, во время работы необходимо понимать в каком состоянии находится проект, где затыки, объяснение почему что-то долго происходит и другие вещи, связанные с обсервабилити работы. Что бы было нагляднее, покажу на &lt;a href=&quot;https://en.wikipedia.org/wiki/V-model&quot;&gt;v-model&lt;/a&gt;, в какие моменты приходится наблюдать за тем, что делают другие.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/v-model-and-personal-managment.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Дизайн, имплементация и верификация – три фазы, на которых приходится «держать руку на пульсе»&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Т.е. задача сводится к трем вещам:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;На этапе дизайна помочь спланировать работу и провалидировать, что план понятен и устраивает каждого стейкхолдера. А также проверить, что план влезает в ресурсы и цена решения будет приемлемой;&lt;/li&gt;
  &lt;li&gt;На этапе имплементации знать в каком состоянии находится проект и какие проблемы появляются. Плюс знать когда приступать к работе над другими частями системы (если требуется);&lt;/li&gt;
  &lt;li&gt;На этапе верификации нужно проверить, что система будет провалидирована перед тем, как оказаться в проде;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;По итогу, нужен инструмент который решает следующие проблемы:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Помогает в быстром прототипировании этапов работы и валидации этих этапов с каждым из стейкхолдеров проекта (бизнесом и разработчиками);&lt;/li&gt;
  &lt;li&gt;Инструмент должен работать для разных команд/отделов. Т.е. встречаются проекты, которые затрагивают от двух команд из разных отделов и необходимо синхронизировать последовательность работ между ними;&lt;/li&gt;
  &lt;li&gt;Важно как можно быстрее понять в каком состоянии проект на выбранный момент времени, или как быстро происходит требуемая эволюция. Т.е. в идеале, нужен инструмент, который позволит работать с «концептуальной» моделью работы над проектом (о концептуальной/логической/технической модели можно прочитать &lt;a href=&quot;https://pepegramming.site/questions/data-model/&quot;&gt;в прошлом ответе&lt;/a&gt;);&lt;/li&gt;
  &lt;li&gt;Так как ко мне могут прийти и спросить либо почему так долго выполняются работы, либо просто спросить что происходит – нужен артефакт для стейкхолдеров, который покажу и от меня отстанут;&lt;/li&gt;
  &lt;li&gt;Решение должно быть кросс-платформенное. Связано со спецификой работы, так как за последние четыре года использовались следующие инструменты: бейскамп, джира, редмайн, асана, миро (не спрашивайте), пяток штук для рисования ганта, гитхаб доски, трелло и другие. Если инструмент окажется вендорлоком - я не смогу решение протащить в другой проект;&lt;/li&gt;
  &lt;li&gt;Инструмент должен хранить задачи, которые вроде как надо бы сделать, но пока не понятно как, когда и нужно ли это вообще;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Дополнительные пожелания:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Чем меньше элементов и информации, тем лучше. Т.е. сроки, таймлайны и прочее хотелось бы убрать. Этим пусть занимаются тимлиды с командами;&lt;/li&gt;
  &lt;li&gt;Хочется иметь инструмент для собственной рефлексии:
  - Понимать на сколько изначальные планы отличаются от того, что получилось в конце эволюции;
  - Нужна ретроспектива, что бы быстро понимать как долго делаются задачи и замечать проблемы. Плюс понимать как сильно ошибался в начале и в конце работы (видеть как много добавилось нового во время работы)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;почему-project-management-tools-не-сработают&quot;&gt;Почему project management tools не сработают&lt;/h3&gt;

&lt;p&gt;Может показаться, что под требования подойдет любой продукт для project planning/management. На деле, подобные инструменты только усложняют работу и связано это с тем, что списки задач не работают для высокоуровневого планирования.&lt;/p&gt;

&lt;p&gt;Проблема тут в том, что задачи редко когда связаны последовательно между собой. В качестве примера можно привести «базовую» задачу по выносу кода из монолита в новый сервис. Если сильно не упарываться, то список шагов можно представить как такую последовательность: &lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Сделать новый сервис с копией логики существующего модуля монолита

1. поднять новую базу данных
2. поднять болванку с пустым сервисом
3. настроить деплоймент
4. настроить observability (метрики, логи, etc)
5. настроить репликацию данных из монолита в новую базу данных
6. проверить, что данные валидны и соответствуют реальности
7. реализовать бизнес логику в сервисе
8. проверить, что бизнес логика работает корректно с данными
9. перевести трафик с монолита на новый сервис
10. проверить что итоговое решение работает корректно
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Вроде кажется, что работа последовательна и тут нечего параллелить, достаточно сделать проекты под каждый шаг и фигачить пару месяцев.  Но если представить шаги как «граф», то оказывается, что есть как минимум три трека, в которых задачи могут быть распараллелены, а сам процесс не так линеен, как кажется на первый взгляд&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-service-extraction-final.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Тот же список по выносу логики из монолита, который теперь выглядит как граф, а не последовательные работы&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;В тех инстурментах, что я знаю или использовал (jira, asana, basecamp, clubhouse, redmine, любая kanban доска, etc) нельзя быстро понять связь между задачами. Т.е. настроить и посмотреть связанные задачи можно, но в голове придется рисовать картинку выше, что отнимает время и силы. А в больших проектах, где задействуются команды из разных отделов, подобные действия могут превратиться в дни анализа. Хотя не исключаю, что я не преисполнился мудростью и плохо знаю инструменты, так как не менеджер.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/jira-go-brrr.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Подозреваю, что прошаренные менеджеры как-то так воспринимают этот текст&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;мой-подход&quot;&gt;Мой подход&lt;/h2&gt;

&lt;p&gt;В 2019 году, пока работал в toptal, попробовал схему с графом, которая прижилась и которую использую до сих пор. Идейно подход напоминает &lt;a href=&quot;https://en.wikipedia.org/wiki/Directed_acyclic_graph&quot;&gt;DAG&lt;/a&gt;, который используется как визуализатор задач в пайплайнах CI/CD или ETL. Единственное отличие, граф рисую руками, вместо использования &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;as a code&lt;/code&gt; подхода.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/airflow-dag-visualizator.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Airflow DAG visualizator, который «рисует» шаги data flow в виде графа, где визуально понятно какая задача за какой вызывается и какой статус у каждой задачи&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Главный плюс подхода – работает в любом инструменте. Я чаще использую lucidchart, но можно взять draw.io или аналоги, возможно даже diagram as code подойдет (не пробовал). Главное, чтобы выполнялись следующие условия:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Можно рисовать квадраты разных цветов;&lt;/li&gt;
  &lt;li&gt;Есть возможность связывать стрелками квадраты между собой;&lt;/li&gt;
  &lt;li&gt;Можно добавлять отдельный элемент для комментариев (в идеале стикер);&lt;/li&gt;
  &lt;li&gt;Наличие отдельных вкладок для версионирования (об этом дальше);&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Сам процесс работы с графом состоит из трех шагов:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Планирование;&lt;/li&gt;
  &lt;li&gt;Наблюдение;&lt;/li&gt;
  &lt;li&gt;«Рефлексия»;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Давайте, на примере выноса кода в отдельный сервис, пройдем по каждому из шагов&lt;/p&gt;

&lt;h3 id=&quot;шаг-1-планирование&quot;&gt;Шаг 1: планирование&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;Предупреждаю: скорее всего сам план будет не корректен, но у меня цель идею показать, а не «правильно» спланировать работу.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Первым делом придется понять что за задачи нужно выполнить. В примере выносом кода в отдельный сервис можно сразу сказать три задачи которые необходимо выполнить:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Поднять новый и пустой сервис&lt;/li&gt;
  &lt;li&gt;Перенести логику в сервис&lt;/li&gt;
  &lt;li&gt;Перевести трафик с монолита на новый сервис&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В виде графа это будет выглядеть следующим образом:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-step-1-base.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Каждый шаг – отдельная нода графа, связи – показывают что за чем выполнять по плану&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Дальше наступает этап анализа, когда оказывается, что каждый из трех шагов состоит из специфичных действий: поднять новый сервис включает в себя поднятие необходимой базы, инстанса приложения, создания репозитория, настройку CI/CD, observability. При этом, без observability перевод трафика не будет иметь смысл.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-step-1-first-improvements.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Раскрываем «большие» задачи на конкретные шаги, которые необходимо выполнить&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Когда будут +- понятные задачи, советую отдельно подумать о двух вещах: интеграции и валидации.&lt;/p&gt;

&lt;p&gt;Под интеграции попадает все, что связывает два элемента вместе: вызов внешнего API, перенос данных из базы в базу, вызов API внутреннего сервиса, перенос данных из старой схемы в новую схему в рамках одной бд, наполнение данными нового сервиса/новой базы и так далее. Об интеграциях забывают в планировании, но как подсказывает практика, тут больше всего риска провалиться: сорвать срок, получить не консистентность и затянуть с работой. &lt;/p&gt;

&lt;p&gt;А под валидации попадает вся левая часть v-model: валидация адекватности данных, которые перенесли, валидация что решение работает, валидация что сервис правильно раскатался, валидация интеграций и так далее. Также как и в интеграциях, валидации забываются и тут много рисков/проблем, которые чаще выстреливают, чем нет.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-step-1-integration-and-validation.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Белые квадраты – интеграции и валидации о которых забывают, но которые не менее важны, чем написание кода и деплой&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Как сделаете план, важно согласовать шаги с командой. Тут два ключевых стейкхолдера: те, кто будут выполнять работу (чаще разработчики, тестировщики, дизайнеры и так далее) и менеджеры, которые будут выбивать ресурсы под работу. Возможно граф станет еще больше или часть задач изменится, это нормально. Важно, чтобы каждый согласился работать по представленному плану.&lt;/p&gt;
&lt;h4 id=&quot;советы&quot;&gt;Советы&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Есть риск скатиться в дробление задач на супер мелкие куски. Не вижу ничего плохого в этом, особенно если опыта мало. Подобные задачи можно схлопнуть или выкинуть на ревью. Единственное исключение – низкоуровневые технические задачи, которые стоит оставлять только если задачи супер критичные для проекта. Если нет, лучше использовать чеклисты для валидации (например сделать чеклист для изменения схемы бд с шагами и проверками);&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Всегда&lt;/strong&gt; (это важно) думайте о необходимых интеграциях и валидациях, без которых проект не запустится. Помните, что есть разница между сделать и заставить работать без ошибок;&lt;/li&gt;
  &lt;li&gt;Согласование такой же необходимый шаг, как и создание графа. Если придти и с ноги сказать кто, что и как делать будет – велик риск саботажа. Плюс другие люди могут указать о том, что вы забыли добавить или что часть работы можно выкинуть;&lt;/li&gt;
  &lt;li&gt;Один из возможных «smell-ов» по задачам – появление задачи, которая ни с чем не связана. Т.е. у задачи может быть либо входящая, либо исходящая связь (либо две сразу), но полное отсутствие стрелок является знаком, что что-то не так и стоит посмотреть внимательно (исключение – задачи в будущее, которые важно помнить, но непонятно когда и как их делать);&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;шаг-2-наблюдение&quot;&gt;Шаг 2: наблюдение&lt;/h3&gt;

&lt;p&gt;Нудный и в тоже время важный шаг. Каждый спринт встречаемся с исполнителями, проходим по каждой задачи из графа, оставляем комментарии и добавляем новые задачи, если оказалось что они нужны. Плюс отмечаем что было сделано и что в работе на момент ревью. Для этого использую цвета: зеленый – сделали, желтый – в работе, красный – отменили.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/real-example-full-graph.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Реальный граф связанный с рефакторингом сервиса. Комментарии оставляю как стикер, тут нет стандартизации. К сожалению шакально по причине NDA, но идею по картинке понять можно&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Тут важно сохранять прошлую версию графа отдельно. Для этого делаю копию, ставлю текущую дату (версию) и заполняю скопированный граф&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/real-example-graph-versions.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Каждая вкладка – новая версия графа, которая изменяется&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Благодаря такому версионированию, можно ретроспективно посмотреть как долго задачи делаются, что добавилось нового и исследовать процесс выполнения работы.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;https://leonardo.osnova.io/6c44e586-3769-4c22-4270-a326d823ea8c/-/format/mp4#t=0.1&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;В 2020 году, Самат &lt;a href=&quot;https://vc.ru/services/151374-s-pomoshyu-diagramm-mozhno-obyasnit-chto-ugodno-tem-bolee-dlya-etogo-est-klassnye-instrumenty&quot;&gt;написал статью&lt;/a&gt;, где показывал граф выполнения работ (в самом низу), видео как раз из статьи&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Кроме отметок по задачам, использую секцию «Проблемы/вопросы/комментарии», куда добавляю все, о чем говорят исполнители. В будущем секция помогает в анализе и ретро.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/real-example-pros-cons-ideas.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример секции «Проблемы/вопросы/комментарии» из проекта выше. Красное – проблемы, зеленое – комментарии, желтым обозначаю вопросы&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;По итогу, получаем гибкий инструмент, который можно использовать для ответа «в каком статусе проект» и «почему долго делается ХХХ?!».&lt;/p&gt;

&lt;h4 id=&quot;советы-1&quot;&gt;Советы&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Как я уже сказал - наблюдение важный шаг. Но при этом и сложный из-за регулярности и желания пропустить и забить. Советую хотя бы раз попробовать выполнить проект не забивая на этот шаг и после уже решать, подходит подход или нет;&lt;/li&gt;
  &lt;li&gt;Версионирование графа – ключ к успеху, особенно для шага с анализом;&lt;/li&gt;
  &lt;li&gt;Не бойтесь добавлять новые задачи. Невозможно сразу описать план идеально. В моей практике, в итоговой версии графа оказывается на ~40% больше задач, чем в изначальной версии;&lt;/li&gt;
  &lt;li&gt;Секция с проблемами не обязательна, но помогает сохранить контекст на будущее;&lt;/li&gt;
  &lt;li&gt;У каждого стейкхолдера должен быть доступ к графу в любое время. Разработчики смогут быстро посмотреть что делать дальше, а у бизнеса появится обсервабилити над проектом в любой необходимый момент времени;&lt;/li&gt;
  &lt;li&gt;В теории, можно раз в неделю открывать «джиру» и отмечать самому что в работе, а что планируется. Но у такого подхода есть минус – шаги не просматриваются исполнителями и нет контакта, благодаря которому можно поговорить о косяках в планировании или проблемах в реализации;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;шаг-3-рефлексия&quot;&gt;Шаг 3: «рефлексия»&lt;/h3&gt;

&lt;p&gt;Это опциональный пункт. Идея в том, что по завершению проекта, любят устраивать ретро. Если проект длится больше 6 месяцев – шансы вспомнить что было в начале нулевые. Но благодаря графу можно быстро посмотреть как долго делались задачи, выписать какие проблемы возникли (с решениями) и посмотреть на сколько ожидания разошлись с реальной работой.&lt;/p&gt;

&lt;h2 id=&quot;advanced-использование-графа&quot;&gt;Advanced использование графа&lt;/h2&gt;

&lt;p&gt;Чтобы накидать ещё больше пользы в ответ, решил еще добавить секцию связанную с анализом. Тут будут идеи из личного опыта, поэтому не ждите хардскилового менеджмента.&lt;/p&gt;

&lt;h3 id=&quot;поиск-проблем&quot;&gt;Поиск проблем&lt;/h3&gt;

&lt;p&gt;В секции с шагом планирования упоминались «висящие» задачи. Кроме этого есть еще один «smell». Связан он с ситуацией, когда задача блокирует другие задачи, например вот так:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-task-blocker.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Центральная задача блокирует правые. При этом, центральная задача ждет левые&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Проблема тут в том, что нельзя распараллелить выполнение работ из-за центрального блокера. Это не всегда плохо, но советую подумать, как можно блокер разбить на несколько задач, которые позволят разблокировать параллельность.&lt;/p&gt;

&lt;h3 id=&quot;как-срокиресурсы-считать&quot;&gt;Как сроки/ресурсы считать&lt;/h3&gt;

&lt;p&gt;Сразу скажу, делал такое 2 раза в жизни, но оба раза срабатывало. Идея в том, что сначала проставляется оценка задачам, после чего планируется, сколько команд надо для работы. В результате можно предположить сколько людей и в какой последовательности будут происходить работы. Благодаря чему заранее выбить капасити каждой команды и предположить сколько времени займет работа (немного точнее, чем просто «пальцем в небо»).&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-resource-planning.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Что бы вынести сервис из монолита нужно 4 команды (каждый цвет – отдельная команда), причем левые три команды могут работать параллельно, а последняя нужна только в самом конце и до реализации бизнес логики может отдыхать&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Подход полезен в двух случаях: когда надо посчитать «пальцем в небо» стоимость и когда проект реализуется сразу несколькими командами и нужно кросс командное взаимодействие.&lt;/p&gt;

&lt;h3 id=&quot;как-понять-почему-по-срокам-не-укладывайтесь&quot;&gt;Как понять, почему по срокам не укладывайтесь&lt;/h3&gt;

&lt;p&gt;Специально для ситуаций, когда бизнес не понимает, почему изначальный коммит был на полгода, а прошло уже 2 года и проект не приносит денег. Благодаря графу можно наглядно показать как увеличился пул задач или какие задачи долго висели в блоке. Судя по опыту, это выглядит намного нагляднее для не-менеджеров, чем графики «джиры».&lt;/p&gt;

&lt;p&gt;Плюс, если за 2-3 спринта задачи только добавляются в граф, а прогресса нет – время бить тревогу и пинать менеджмент/бизнес, что проблемы начались.&lt;/p&gt;

&lt;h3 id=&quot;используем-реальный-анализ-графов&quot;&gt;Используем реальный анализ графов&lt;/h3&gt;

&lt;p&gt;Так как это граф, можно применить научные методики анализа из теории графов. Но тему не раскручивал, поэтому оставлю идею для самостоятельного изучения. Если что-то придумаете, напишите пожалуйста, буду рад обсудить.&lt;/p&gt;
&lt;h3 id=&quot;как-использовать-project-management-tools-с-таким-графом&quot;&gt;Как использовать project management tools с таким графом&lt;/h3&gt;

&lt;p&gt;Если взять &lt;a href=&quot;https://pepegramming.site/questions/data-model/#data-modelling&quot;&gt;идею conceptual/logical/physical data models&lt;/a&gt;, то можно представить граф как концептуальную модель, PM tool как логическую, а реализацию в виде кода как физическую&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/conceptual-logical-phisical-models.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Наглядное сравниение каждой data model и планирования работы&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Из этого сравнения получается, что есть условный «эпик», который описывается графом. Каждая нода графа – отдельный проект в «джире», а каждый таск из проекта – отдельный PR/MR, который на шаг ближе закрывает эпик.&lt;/p&gt;

&lt;p&gt;Благодаря такому разделению, можно использовать viewpoints для каждого стейкхолдера: список задач для команды, гант диаграмму по эпику, статус проекта для бизнеса, задачи для конкретного разработчика и так далее.&lt;/p&gt;

&lt;p&gt;А если используете &lt;a href=&quot;https://habr.com/ru/articles/831922/&quot;&gt;трассировку требований&lt;/a&gt;, сможете линковать между собой. Единственный минус подхода, для графа нет автоматизации.&lt;/p&gt;

&lt;h2 id=&quot;плюсы-и-минусы-использования-графа-для-планирования&quot;&gt;Плюсы и минусы использования графа для планирования&lt;/h2&gt;
&lt;p&gt;Начну с плюсов:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Появляется хоть какая-то системность в планировании и выполнении проекта. Благодаря чему каждый из стейкхолдеров может рассматривать &lt;a href=&quot;https://creatime.me/MediaLibrary/UchebnyeMaterialy-2/Stati/PodsistemyI&quot;&gt;либо подсистемы либо надсистемы&lt;/a&gt; в зависимости от собственных интересов;&lt;/li&gt;
  &lt;li&gt;Лично доволен таким подходом, за пять лет проблем не было;&lt;/li&gt;
  &lt;li&gt;Когда проектов больше пяти – помогает быстро получить контекст в каком состоянии реализация каждого;&lt;/li&gt;
  &lt;li&gt;Судя по опыту, бизнес любит такую наглядность. Разработчики страдают от того, что сложно хайлевел задачи декомпозировать и понять что за чем – поэтому декомпозицию можно обсудить заранее. Пару раз ребята говорили спасибо, ибо понимали что их дальше ждет и могли заранее подготовить код к будущей работе;&lt;/li&gt;
  &lt;li&gt;Из-за концептуальности и простоты решения – супер гибкое решение. Выбираете удобный вам инструмент для диаграмм и работаете. Только помните, что в случае вайтбордов придется решить, как версионировать графы. Плюс, с добавлением трассировки требований, можно быстро делать кросс линки между задачами и другими артефактами работы;&lt;/li&gt;
  &lt;li&gt;Концептуальный план делается быстро и легко правится. После можно сделать «логический» план в виде задач или эпиков в джире и сразу начать работать, вместо того, что бы тратить время на реализацию концептуального плана в PM tool;&lt;/li&gt;
  &lt;li&gt;Хорошо показывает себя в проектах, где есть четкая цель, которая не поменяется через пол года и которую долго делать. Например, когда знаете, что надо вынести сервис, отрефакторить кусок кода или реализовать фичу с определенным DoD. Один раз сделали, знаете конец и дальше работаете, раз в спринт сверяясь;&lt;/li&gt;
  &lt;li&gt;Судя по опыту, работает для ретро лучше, чем список задач из джиры (возможно ошибка выжившего). Связано с тем, что подход добавляет концепцию «журнала» связанного с проблемами, хорошими вещами и вопросами. После чего, на ретро, открываем нужный спринт и смотрим, что там происходило;&lt;/li&gt;
  &lt;li&gt;Не совсем о подходе, но скорее в целом о полном плане работ: включается &lt;a href=&quot;https://fs.blog/amateurs-professionals/&quot;&gt;мышление второго порядка&lt;/a&gt;. Особенно, если план валидировать через результат каждого шага + вопроса “что произойдет после этого”;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;После плюсов может показаться, что инструмент серебряная пуля, но минусов у графа тоже много:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;К концу релиза начинается каша и велик риск забить на диаграмму. Нужен высокий уровень самоконтроля и постоянно пушить исполнителей. Из этого следует главный минус – без контроля и ревью, подход не работает;&lt;/li&gt;
  &lt;li&gt;Не сработает, когда высокая неопределенность в работе. Т.е. когда сделав задачу, планы меняются и становятся другими, например сегодня выносите сервис, а завтра оказывается, что денег больше нет и надо гипотезы делать по две штуки в день;&lt;/li&gt;
  &lt;li&gt;Это придуманный подход, его нет нигде. Поэтому допускаю проблемы с объяснением и обучением, так как нет описания. Т.е. кроме куска из курса о системах и этого текста, в интернете информации нет (если ошибаюсь и знаете аналоги, буду рад ссылке);&lt;/li&gt;
  &lt;li&gt;Придется заморочиться с трассировкой требований, если нужна интеграция с проектной документацией. Это лишняя работа и цена;&lt;/li&gt;
  &lt;li&gt;Подход придется продавать бизнесу, менеджерам и исполнителям работы. Продажа подхода – одна из причин, почему появился этот текст;&lt;/li&gt;
  &lt;li&gt;Из инструментов – кривые плагины для конфлюенса и аналогов, либо делать руками. Если используете диаграммы - нет фильтрации по проектам/командам и автоматической генерации других viewpoints;&lt;/li&gt;
  &lt;li&gt;Подход не о сроках и датах. Если сроки важны, придется либо делать отдельный viewpoint (например ганта), либо использовать другой инструмент;&lt;/li&gt;
  &lt;li&gt;Менеджерам будет не хватать асайнов на людей, фильтрации и сроков/статусов;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;выводы&quot;&gt;Выводы&lt;/h2&gt;

&lt;p&gt;Использование подобного графа оправданно, если необходим «концептуальный» уровень для планирования проектов, а условная «джира» не справляется. Так как подход максимально гибок, можно использовать любые инструменты для диаграмм или вайтбордов (можно даже лист бумаги и ручку взять). Важно помнить, что стоит делать квадраты похожими на проект из GTD и следить за связями. При этом, кроме работы над планом, стоит потратить время на регулярное обновление статуса по проекту, что в будущем окупится аналитикой и ретро.&lt;/p&gt;

&lt;p&gt;Ну и еще раз напишу, что описанный подход планирования и слежения за проектами не единственный и не серебрянная пуля. Ну и помните главное правило: если устраивает текущая ситуация в компании – лучше ничего не трогать и не гнаться за новым подходом, ради подхода.&lt;/p&gt;

&lt;p&gt;Кроме этого, если используете «концептуальный» вью в PM инструментах, буду рад, если поделитесь секретом в комментариях. А если захотите воспользоваться описанным выше подходом и останутся вопросы или захотите поделиться фидбеком – буду рад в два раза больше.&lt;/p&gt;

&lt;h2 id=&quot;доп-ссылки&quot;&gt;Доп ссылки&lt;/h2&gt;

&lt;p&gt;Инструменты, представляющие работу над задачей в виде графа:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://about.i.ntention.app&quot;&gt;Intention&lt;/a&gt;, работает на андроиде и в вебе (если понял правильно). &lt;a href=&quot;https://news.ycombinator.com/item?id=22591311&quot;&gt;Обсуждение на ycombinator&lt;/a&gt; тоже присутствует;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://eyen.fr/taskheat/&quot;&gt;Приложение за которым долго слежу&lt;/a&gt; и от которого были большие ожидания для персональных проектов, но так и не зашло. Возможно попробую еще раз через пару лет. Работает только на apple устройствах и больше о персональных проектах, т.е. конкурент для things3/todois/ticktick/etc;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.gameplan.global&quot;&gt;PM tool, о котором никогда не слышал&lt;/a&gt; (нашел, пока ответ писал). Кажется, что если используете что-то другое, переехать на «нонейм» решение будет сложно;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.easyredmine.com/redmine-wbs-plugin&quot;&gt;Плагин для редмайна&lt;/a&gt; с похожей функциональностью;&lt;/li&gt;
  &lt;li&gt;Два плагина для джиры с похожим функционалом: &lt;a href=&quot;https://marketplace.atlassian.com/apps/1216207/issue-links-viewer&quot;&gt;первый&lt;/a&gt; и &lt;a href=&quot;https://whiteboards.io&quot;&gt;второй&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Как визуализировать схему базы данных</title>
   <link href="http://pepegramming.site/questions/data-model/"/>
   <updated>2024-08-01T00:00:00+03:00</updated>
   <id>http://pepegramming.site/questions/data-model</id>
   <content type="html">&lt;h2 id=&quot;вопрос&quot;&gt;Вопрос&lt;/h2&gt;

&lt;div class=&quot;question-text&quot;&gt;
  &lt;blockquote&gt;
    &lt;p&gt;«Возникла проблема, что нужно визуализировать данные, но не понятно с чего начать. Что в таких случаях делаешь и какие есть инструменты для этого?»&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/div&gt;

&lt;p&gt;Так как вопрос без конкретики, выделю два случая:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Проект только в голове и хочется понять как связаны данные между собой&lt;/li&gt;
  &lt;li&gt;Проект уже реализован в коде и хочется понять, что из себя представляет схема бд&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Поэтому, вместо короткого ответа «используй ERD», поговорим о каждом из вариантов. Но сначала разберемся с data modelling, благодаря которому можно определить нужный вид диаграммы для задачи.&lt;/p&gt;

&lt;h2 id=&quot;data-modelling&quot;&gt;Data modelling&lt;/h2&gt;

&lt;p&gt;Может показаться, что взять и начать фигачить SQL схему описывающую данные для проекта может быть разумной идеей. На деле это не так:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Так как нет структуры данных в голове, можно запутаться и упороться в вечное редактирование. А если данных много и связей еще больше - получится хаос который не влезет в голову;&lt;/li&gt;
  &lt;li&gt;Полученную модель данных придется валидировать, причем с бизнесом/доменным экспертом. Не разработчикам будет сложно и валидация может затянуться;&lt;/li&gt;
  &lt;li&gt;Когнитивная нагрузка увеличивается: работая с текстом, придется этот текст представить в виде модели в голове и потом обратно, из модели в текст;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-01-data-model/schema-vs-visualisation.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Слева - схема в dbml, которая представлена в виде диаграммы (справа). Когда разбираешься с новым проектом – мне проще сразу картинкой (моделью) оперировать&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;В целом, выглядит надежно, как швейцарские часы. Поэтому придумали процесс, который назвали &lt;a href=&quot;https://en.wikipedia.org/wiki/Data_model&quot;&gt;data modeling&lt;/a&gt;. Data modeling помогает с определением релевантных для системы данных, связью между этими данными и как данные работают вместе, т.е. создать data model для системы. Главное, что стоит вынести из этой идеи – моделирование можно разбить на три «перспективы»:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Conceptual_schema&quot;&gt;Концептуальная&lt;/a&gt; говорит о том, какие данные используются системой и как данные связаны между собой. Т.е. тут о том, что необходимо бизнесу без привязки к конкретной реализации хранения данных в конкретной бд&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_schema&quot;&gt;Логическая&lt;/a&gt; говорит о том, как данные структурируются в приложении. Т.е. берем любой язык описания схемы (будь то SQL, dbml или еще что) и описываем таблицы/колонки/классы/etc.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Physical_schema&quot;&gt;Физическая&lt;/a&gt; говорит о том, как данные физически храниться будут. Т.е. берем логическое описание и говорим где данные будут находиться физически и как все будет работать в реальности;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-01-data-model/conceptual-vs-logical-models.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Сравнение концептуальной (правая) и логической (левая) схем, где пример из самого начала. Возможно, я сделал концептуальную модель не корректно, но задача показать идею, а не сделать корректную модель&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;При использовании концептуальной модели данных можно отказаться от «технической» информации и оставить только необходимое для реализации бизнесовой модели. Т.е. можно не запариваться с pk, fk и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;created_at&lt;/code&gt; для каждого объекта и не думать о таблицах. Так, в примере выше, указан продукт как «элемент», к которому привязаны отдельные «элементы»: цена, тег и статус. Эта информация необходима для бизнес логики, хотя в реальности, если опуститься на логический уровень – данные оказываются в одной таблице.&lt;/p&gt;

&lt;p&gt;Теперь, используя информацию о data modeling, можно вернуться к оригинальному вопросу.&lt;/p&gt;

&lt;h2 id=&quot;случай-1-проект-только-в-голове-и-хочется-понять-как-связаны-данные-между-собой&quot;&gt;Случай 1: Проект только в голове и хочется понять как связаны данные между собой&lt;/h2&gt;

&lt;p&gt;Возможно бизнес с нуля делает систему, либо же нужно разобраться в уже работающей бизнес логике (доменной модели). Для этого придется разбираться с данными: какие элементы, как элементы связаны. Если в этот момент думать о том, где какая таблица будет и что в этой таблице должно находиться – выглядит как доп нагрузка которая усложняет работу. Поэтому для первого случая концептуальное представление предпочтительнее: меньше когнитивная нагрузка, проще работать, можно показать бизнесу не объясняя что это за &lt;a href=&quot;https://www.datensen.com/blog/er-diagram/one-to-many-relationships/&quot;&gt;вилка&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;виды-нотаций-концептуальных-моделей&quot;&gt;Виды нотаций концептуальных моделей&lt;/h3&gt;

&lt;p&gt;Тут список может быть большой, опишу только то, что сам знаю и видел. Подробно на каждой нотации останавливаться не буду, оставлю это на самостоятельное изучение.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://studme.org/77224/informatika/notatsiya_idef&quot;&gt;Нотация IDEF 1х&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://studme.org/77225/informatika/notatsiya_uml&quot;&gt;PlantUml&lt;/a&gt;, тут используется &lt;a href=&quot;https://en.wikipedia.org/wiki/Class_diagram&quot;&gt;class diagram&lt;/a&gt;, что сомнительно, но для общего развития пусть будет.&lt;/li&gt;
  &lt;li&gt;Cтоит упомянуть &lt;a href=&quot;http://www.modelsphere.com/org/index.html&quot;&gt;Open ModelSphere&lt;/a&gt;, это oss инструмент, который помогает с моделированием данных не только концептуально, но и логически/физически
 
Отдельно хочется рассказать еще о двух нотациях:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Первая нотация – &lt;a href=&quot;https://en.wikipedia.org/wiki/Entity–relationship_model&quot;&gt;ER model&lt;/a&gt; (иногда встречается как &lt;a href=&quot;https://studme.org/77222/informatika/notatsiya_pitera_chena&quot;&gt;нотация Питера Чена&lt;/a&gt;) и тут важно не путать с ER diagram. Модель создана Питером Ченом в 1976 году для абстрактного описания данных. При этом, модель предоставляет абстракции для концептуального/логического/физического моделирования. Интересный факт: эта одна из нотаций, которые повлияли на UML.&lt;/p&gt;

&lt;p&gt;Вторая – &lt;a href=&quot;https://martinfowler.com/books/ap.html&quot;&gt;нотация концептуальной модели Мартина Фаулера из книги&lt;/a&gt;, о которой преступно мало знают.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-01-data-model/martin-fowler-notation.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Так выглядит нотация используемая Фаулером, она описана прямо на первых страницах книги&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Что выбрать – решайте сами. Расскажу о том, что сам использую и почему редко использую описанные выше модели.&lt;/p&gt;

&lt;h3 id=&quot;что-сам-использую&quot;&gt;Что сам использую&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://tough-roadway-bb5.notion.site/1-1-6adfeb2e07eb4269b5966ffb742d7fad#34413c7cc27b4e1da6ee31177875b93b&quot;&gt;Я использую сильно упрощенную нотацию, состоящую только из квадратов и стрелок&lt;/a&gt;, которую сам и «придумал». При этом, вместо использования сложных видов стрелок, подписываю вид связи который нужен (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;has_one&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;has_many&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;optional_has_one/many&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;many_to_many&lt;/code&gt;). Плюс использую цветовое обозначение для данных, которые используются в разных контекстах.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-01-data-model/data-model-example.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример модели из рабочего проекта. Тут кусок модели, &lt;a href=&quot;https://vc.ru/fedorandsamat/1103649-kak-my-perezapuskali-medicinskuyu-informacionnuyu-sistemu&quot;&gt;связанный с работой дантистов&lt;/a&gt;&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Такой выбор обусловлен двумя причинами:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Концептуальную модель приходится валидировать с бизнесом/доменными экспертами. Чем сложнее нотация, тем больше шансов, что человек запутается. Плюс грузить и без этого занятых людей так себе подход.&lt;/li&gt;
  &lt;li&gt;Внимательность – не обо мне, поэтому с большим шансом запутаюсь или пропущу стрелку/форму и по итогу получится фигня. Рисковать и проверять себя по 10 раз не хочется.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если в компании уже есть стандарт, либо хотите использовать распространенный стандарт – лучше забыть эту часть текста и использовать то, что уже принято. Если ничего такого нет, возможно стоит скопировать мое решение, а после, если этого окажется мало, выбрать любую из описанных выше нотаций.&lt;/p&gt;

&lt;h3 id=&quot;советы-для-моделирования-данных-не-схемы-бд&quot;&gt;Советы для моделирования данных (не схемы бд)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Забудьте о таблицах и реализации в бд. Начните с данных, которые необходимы для работы бизнес модели. Главная причина такого категоричного совета – проще замапить корректную концептуальную модель на реализацию конкретной базы данных, чем упороться с реализацией и потерять важные данные. Это может привести к тому, что решение не будет бизнес задачу решать, а будет подстраиваться под техническое решение, вокруг которого зацепитесь;&lt;/li&gt;
  &lt;li&gt;Вытекает из первого совета: в концептуальной модели не нужны данные, которые окажутся в базе данных. Поэтому о &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pk&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fk&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;created_at&lt;/code&gt;, etc можно забыть. Только если это не часть доменной модели;&lt;/li&gt;
  &lt;li&gt;Не важно какую нотацию выбрали, модель без легенды – деньги на ветер;&lt;/li&gt;
  &lt;li&gt;Валидируете модель с бизнесом/доменным экспертом;&lt;/li&gt;
  &lt;li&gt;Между дублированием элементов и уменьшением стрелок – выбирайте дублирование. Так можно снизить когнитивную нагрузку, которая появится из-за стрелочного хаоса. По этой же причине старайтесь избегать пересечения стрелок;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;С моделированием разобрались. Давайте поговорим о генерации картинок из схемы бд.&lt;/p&gt;

&lt;h2 id=&quot;случай-2-проект-уже-реализован-в-коде-и-хочется-понять-что-из-себя-представляет-схема-бд&quot;&gt;Случай 2: Проект уже реализован в коде и хочется понять, что из себя представляет схема бд&lt;/h2&gt;

&lt;p&gt;В данном случае, если нужна концептуальная модель – инструментов не знаю, к сожалению. Поэтому, для проектов с реализованной схемой бд, рисую концептуальные модели «руками».&lt;/p&gt;

&lt;p&gt;Но если хватит логической модели, можно найти решение. Из того что знаю – ER diagram (которая, является подмножеством ER model). Существует новомодный dbml, который тоже использовал. Еще стоит упомянуть &lt;a href=&quot;https://studme.org/77223/informatika/notatsiya_martina_crows_foot&quot;&gt;Нотацию Мартина (Crow’s Foot)&lt;/a&gt;, но в живую не наблюдал. Если знаете другие варианты – буду рад комментариями, ибо самому интересно, а быстро нагуглить альтернативы не вышло.&lt;/p&gt;

&lt;p&gt;Для генерации «картинки» я использую следующие подходы:&lt;/p&gt;

&lt;h3 id=&quot;генерация-модели-из-кода&quot;&gt;Генерация модели из кода&lt;/h3&gt;

&lt;p&gt;В эту секцию входят:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;инструменты diagram as a code: &lt;a href=&quot;https://graphviz.org/Gallery/neato/ER.html&quot;&gt;graphiz&lt;/a&gt;, &lt;a href=&quot;https://mermaid.js.org/syntax/entityRelationshipDiagram.html&quot;&gt;mermaid&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;библиотеки для разных языков (&lt;a href=&quot;https://github.com/drivendataorg/erdantic&quot;&gt;python&lt;/a&gt;, &lt;a href=&quot;https://github.com/voormedia/rails-erd&quot;&gt;ruby&lt;/a&gt;, &lt;a href=&quot;https://github.com/fuelen/ecto_erd&quot;&gt;elixir/ecto&lt;/a&gt;, &lt;a href=&quot;https://github.com/gmarik/go-erd&quot;&gt;golang&lt;/a&gt;, &lt;a href=&quot;https://www.npmjs.com/package/prisma-erd-generator&quot;&gt;js/prisma&lt;/a&gt;, etc) которые под капотом используют graphiz.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;С вероятностью в 99% там будет ERD. А подход подойдет в двух случаях:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Если схема данных меньше ~15 таблиц и хочется быстро подключить генератор, а после забыть и получать каждый релиз новый артефакт;&lt;/li&gt;
  &lt;li&gt;Если модель нужна для поста или показать идею;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Плюсы:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Работает для схем, где таблиц меньше ~15 или когда связей мало между таблицами;&lt;/li&gt;
  &lt;li&gt;Библиотеки работают из коробки и легко настраиваются;&lt;/li&gt;
  &lt;li&gt;Если говорим о библиотеках – нет проблем с обновлением схемы после изменений, так как генерируется новый файл;&lt;/li&gt;
  &lt;li&gt;Легко шарить между коллегами. Отправляем картинку в чат, добавляем в репозиторий или конфлюенс/ноушен/etc;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Из минусов:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Нельзя поменять положение элементов или связей. А автоматическая генерация не поддается логике;&lt;/li&gt;
  &lt;li&gt;На больших схемах получается не читаемая каша. Особенно, когда дело касается связей;&lt;/li&gt;
  &lt;li&gt;Генерируется векторная картинка, если схема увесистая – может шакалить;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;генерация-erd-в-инструментах-для-диаграм&quot;&gt;Генерация ERD в инструментах для диаграм&lt;/h3&gt;

&lt;p&gt;Lucidchart предоставляет &lt;a href=&quot;https://www.lucidchart.com/pages/examples/er-diagram-tool&quot;&gt;инструмент, который генерирует ERD по загруженной схеме бд&lt;/a&gt;. Дальше получаете диаграмму, в которой можно двигать элементы, стрелки, добавлять новые элементы, менять цвета и делать что угодно.&lt;/p&gt;

&lt;p&gt;Draw.io реализовали &lt;a href=&quot;https://www.drawio.com/doc/faq/sql-plugin&quot;&gt;аналогичный инструмент&lt;/a&gt;. Только для работы придется вставлять SQL код. После, с полученной схемой, также можно производит манипуляции с диаграммой.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-01-data-model/erd-bad-example.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример сгенерированной ERD в lucidchart. Получи такое картинкой – сразу бы отказался от проекта&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Плюсы:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;В отличии от векторной картинки – можно делать с полученной моделью что угодно;&lt;/li&gt;
  &lt;li&gt;Если не хватит сгенерированных элементов – можно добавить (например стикеры и комментарии);&lt;/li&gt;
  &lt;li&gt;Если схема большая – можно двигать каждую связь или элемент, плюс выручает поиск по модели;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Из минусов:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Могут теряться связи между элементами, особенно если связи указаны в коде, но не учтены в схеме бд. Пару раз попадался на эту уловку и приходилось руками достраивать модель, что малоприятно;&lt;/li&gt;
  &lt;li&gt;Хоть с диаграммой можно делать что угодно, но первичная генерация хаотична. Поэтому для «наведения порядка» придется самостоятельно двигать элементы;&lt;/li&gt;
  &lt;li&gt;Специфичный импорт, из-за чего придется под новую версию схемы делать новую диаграмму. А если добавили что-то кастомное, придется дублировать руками;&lt;/li&gt;
  &lt;li&gt;Шарить модель может быть проблемно, особенно если используете lucid и душит жаба платить за кучу людей (но для конфлюенса был плагин);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Заметка: помните, что генераторы ERD присутствуют не везде. Например, &lt;a href=&quot;https://miro.com/diagramming/er-diagram/&quot;&gt;в miro нет ERD генераторов&lt;/a&gt;, вместо этого, получите только элементы для того, чтобы самостоятельно рисовать модель. &lt;/p&gt;

&lt;h3 id=&quot;использование-dbml&quot;&gt;Использование dbml&lt;/h3&gt;

&lt;p&gt;Персональное открытие прошлого года. Вместо рассказа, &lt;a href=&quot;https://dbdiagram.io/d&quot;&gt;лучше посмотреть самостоятельно&lt;/a&gt; (в верхнем левом углу, где лого, можно загрузить advanced sample, который использовался в примерах в начале статьи).&lt;/p&gt;

&lt;p&gt;При этом, так как dbml схема типизирована, можно написать конвертер из erd в dbml и получить генерацию схемы из кода (делал так для &lt;a href=&quot;https://github.com/voormedia/rails-erd&quot;&gt;erd-rails&lt;/a&gt; генератора). После, вставляем схему в редактор и изучаем схему баз данных.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Плюсы:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Из-за динамичности, можно двигать элементы, что работает с большими схемами;&lt;/li&gt;
  &lt;li&gt;Diagram as a code. Можно &lt;a href=&quot;https://dbml.dbdiagram.io/cli#convert--a-sql-file-to-dbml&quot;&gt;генерировать dbml схему по SQL&lt;/a&gt;, присутствует &lt;a href=&quot;https://github.com/stepanic/parse-server-SCHEMA-to-DBML&quot;&gt;библиотека для монги (не проверял)&lt;/a&gt;, &lt;a href=&quot;https://github.com/hamedsj/DbmlForDjango&quot;&gt;для джанги&lt;/a&gt; библиотека существует;&lt;/li&gt;
  &lt;li&gt;Предпросмотр работает в браузере, не надо ничего ставить локально;&lt;/li&gt;
  &lt;li&gt;Так как генерация из кода – можно избежать ситуации, когда связи не отображаются, так как связей нет в схеме бд, но есть на уровне кода;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Из минусов:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Нет нормальной экосистемы. Библиотеки придется писать самому, в частности для мало популярных языков;&lt;/li&gt;
  &lt;li&gt;Еще один язык описания схемы, который придется изучить;&lt;/li&gt;
  &lt;li&gt;Если хотите хранить и смотреть модели командой, придется платить. Хотите селфхостед – на 2023 год находил аналоги, но каждый оставлял желать лучшего;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;генерация-из-редактораide&quot;&gt;Генерация из редактора/IDE&lt;/h3&gt;

&lt;p&gt;Так как всю жизнь просидел в vim, без возможности выхода, то особо ничего сказать о генерации схем из редактора и инструментов для этого. Знаю, что инструменты существуют и пользователи jetbrains &lt;a href=&quot;https://www.jetbrains.com/help/datagrip/creating-diagrams.html#db_diagrams&quot;&gt;могут смотреть на схему не выходя из редактора&lt;/a&gt;. Лучше погуглить самостоятельно.&lt;/p&gt;

&lt;h2 id=&quot;итоги&quot;&gt;Итоги&lt;/h2&gt;

&lt;p&gt;Если необходимо смоделировать данные, то важно разобраться с целью модели, так как каждое представление закрывает определенные потребности:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Концептуальная модель – говорит о том, какие данные используются системой и как данные связаны между собой. Подойдет если важно понять что за данные нужны в бизнес логике и как данные связаны между собой;&lt;/li&gt;
  &lt;li&gt;Логическая модель – говорит о том, как данные структурируются в приложении. Поможет описать или посмотреть на схему бд. Можно сгенерировать автоматически;&lt;/li&gt;
  &lt;li&gt;Физическая модель – говорит о том, как данные физически храниться будут. Сам не использовал, но допускаю, что поможет в инфраструктурных документах;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если нужно визуализировать схему бд, то тут два варианта: для мелких схем или для примеров лучше взять генераторы или diagram as a code инструменты, а для больших схем лучше либо взять инструменты для диаграм, либо посмотреть в сторону dbml, который можно использовать и в качестве генератора.&lt;/p&gt;

&lt;h2 id=&quot;что-еще-почитать-по-теме&quot;&gt;Что еще почитать по теме&lt;/h2&gt;

&lt;p&gt;Если тема data model заинтересовала, собрал четыре ссылки, по которым можно погрузиться в тему глубже. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[en] В статье не рассказывал про archimate. Хотя там так же &lt;a href=&quot;https://eaprincipals.com/data-modeling-with-archi/&quot;&gt;можно сделать нужную data model&lt;/a&gt;. Если используете archi - ничего нового не узнаете, скорее всего;&lt;/li&gt;
  &lt;li&gt;[en] &lt;a href=&quot;https://www.mongodb.com/basics/data-modeling&quot;&gt;Статья из блога mongoDB, в которой рассказывается data modelling&lt;/a&gt;. В тексте найдете описание подхода, виды представлений, описание процесса, советы и еще больше инструментов и так далее;&lt;/li&gt;
  &lt;li&gt;[en] &lt;a href=&quot;https://www.thoughtspot.com/data-trends/data-modeling/conceptual-data-model-examples&quot;&gt;Статья о том, как сделать концептуальную модель&lt;/a&gt;, какие виды есть и в чем ее преимущества;&lt;/li&gt;
  &lt;li&gt;[en] Серия статей о визуализации бд. По &lt;a href=&quot;https://minimalmodeling.substack.com/p/visual-language-and-database-visualization&quot;&gt;ссылке третья часть&lt;/a&gt;, где упоминаются разные приложения для визуализации: MySQL Workbench,  Anchor,  TLDraw и Arrows.app;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Ретроспектива: ecommerce</title>
   <link href="http://pepegramming.site/blogposts/retrospection-ecommerce/"/>
   <updated>2020-06-03T00:00:00+03:00</updated>
   <id>http://pepegramming.site/blogposts/retrospection-ecommerce</id>
   <content type="html">&lt;p&gt;Год назад я ушел из healthcare стартапа, который являлся ecommerce для лекарств в штатах. Сразу после ухода я написал черновик с советами самому себе о том, что стоит делать сразу, а на что обратить внимание.&lt;/p&gt;

&lt;p&gt;Черновик забылся на год, но, найдя записи в блокноте, выложил в паблик как ретроспективу основанную на опыте и боли. Каждый пункт -  субъективный опыт и не претендуют на единственно верное решение. Если у вас есть похожие советы связанные с ecommerce - пишите комментарии, хочется собрать целый список. В будущем, можно будет сделать подобные списки и для других видов проектов.&lt;/p&gt;

&lt;h2 id=&quot;ордер-и-цены&quot;&gt;Ордер и цены&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cart&lt;/code&gt; - частный случай &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order&lt;/code&gt;. Вместо двух сущностей можно взять &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order&lt;/code&gt;  со статусом &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;created&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Купоны появятся. Делать купон отдельной сущностью - усложняет логику и добавит условий в чекаут и рефанд логику. Сегодня, если нужно будет делать добавить купоны в систему - сделаю купон отдельным айтемом с отрицательной ценой (скидкой).&lt;/li&gt;
  &lt;li&gt;В &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order_items&lt;/code&gt; линковался на &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;item&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;price&lt;/code&gt; из базы. Также, аналитики постоянно меняли цены на товары. Такая ситуация привела к мутациям ордера и было тяжело сказать, что и сколько стоило для ордера годичной давности. А пользователь получал не предсказуемый UX, так как возникала гипотетическая ситуация, что в момент чекаута цена на товар меняется и пользователь заплатит больше или меньше чем ожидает. Сегодня я бы помести в каждый &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order_item&lt;/code&gt;  JSONB поле для цены которое выглядело следующим образом &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSONB: { added_at: &apos;&apos;, price: ... }&lt;/code&gt;. В таком случае нет непредвиденных мутаций, появляется версионирование данных. К тому же, это больше информации для аналитиков.&lt;/li&gt;
  &lt;li&gt;Датасайнтисты захотят менять цены, используя сложные паттерны расчета цены и кучу условий. Это приводит к постоянным изменениям цен в базе данных. Поэтому сформировалось правило, все что относится к ценам стоит как можно раньше изолировать в отдельный домен, сервис, rails engine, что угодно. Разделять стоит не только на уровне логики, но и на уровне данных. Вариант с JSONB полем - частный случай такого разделения.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;обсервабилити&quot;&gt;Обсервабилити&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Мониторинг и логирование добавляют контроля и скажут что происходит или подскажут где проблема. Покрывать логами и мониторингом каждую строчку  дорого, поэтому top1 кандидаты: все что связанно с деньгами, checkout&amp;amp;refund flow, изменения в данных, интеграции с партнерами, которые приносят деньги. Подход коррелирует с правилом “знайте, что происходит в частях системы, которые приносят деньги”.&lt;/li&gt;
  &lt;li&gt;Работу с деньгами стоит начинать с логов. Если нет ELK или хранилища для логов в котором можно найти информацию без боли - используйте базу данны. Решение для старта - отдельная аудит таблица куда будет попадать информация от платежного шлюза. Такая информация будет полезна как в дебаге, так и аналитикам для создания моделей.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;архитектура&quot;&gt;Архитектура&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Если в системе присутствуют мобильные устройства и другие виды клиентов (например b2b интеграции), значит стоит подумать о версионировании и заложить работу с версиями с самого начала. Кроме версионирования контроллера есть версионирование бизнес логики и версионирование данных.&lt;/li&gt;
  &lt;li&gt;Если клиентов больше двух рекомендую  почитать о &lt;a href=&quot;https://samnewman.io/patterns/architectural/bff/&quot;&gt;BFF паттерне&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Если событий нет в коде - вероятность появления крайне высока. Sidekiq не предназначен для event driven architecture, хотя помогает отодвинуть переход на новую архитектуру и работает для бэкграунд процессинга или в самом начале работы проекта. Поэтому стоит заложить в имплементацию последующее использование событий вне сайдкика.&lt;/li&gt;
  &lt;li&gt;Код без событий для бизнеса и аналитиков - деньги на ветер. Стоит с самого старта проекта заложить, что события относящиеся к работе бизнеса нужно отправлять. Не обязательно использовать сложные решения или платить за SaaS продукты. Например, в собственных проектах шлю события в телеграм, а некоторые пишу в базу.&lt;/li&gt;
  &lt;li&gt;Kafka как брокер событий с самого старта - провал. Это дорого и очень дорого. Если хоститесь в клауде - sqs или google pub/sub могут стать хорошим началом. Если нет - выбирайте из селфхостед аналогов. Также, стоит сразу подумать о прямой и обратной совместимости данных в событиях, а также о schema registry. Как хак подойдет отдельный репозиторий со схемами событий.&lt;/li&gt;
  &lt;li&gt;Временное остаётся навсегда. Так технология добавленная на 2 спринта осталась в проекте на 2 года.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;данные-и-etl&quot;&gt;Данные и ETL&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;В маркете возникает ситуация, когда регулярно надо загружать новые данные. Пример - цены на товары и сама информация по товарам. Вместо создания rake тасков для загрузки csv в базу, стоит посмотреть на ETL и заложить работу с ним в архитектуру. Из  аналогов можно посмотреть на &lt;a href=&quot;https://github.com/thbar/kiba&quot;&gt;kiba&lt;/a&gt; (написан на руби) и &lt;a href=&quot;https://airflow.apache.org&quot;&gt;Apache Airflow&lt;/a&gt;, написанный на питоне.&lt;/li&gt;
  &lt;li&gt;Желательно подумать о том, как выгружать данные из приложения аналитикам заранее. Шарить дамп БД может оказаться быстрым вариантом, но в долгосрочной перспективе принесет проблемы совместимости между схемой данных в базе и схемой данных у аналитиков. Как альтернативное решение может подойти событийный подход. Но стоит заранее подумать о схеме данных, версионировании и обратной совместимости между версиями.&lt;/li&gt;
  &lt;li&gt;Аналитики хотят видеть динамику по данным и делают из дампов за разные дни список изменений. Событийный обмен данными также поможет в этой проблеме.&lt;/li&gt;
  &lt;li&gt;Если в домене присутствует специфический ID с определенной структурой - сделайте эту структуру на уровне базы и приводите к этой структуре в бизнес логике. Например, у нас был &lt;a href=&quot;https://en.wikipedia.org/wiki/National_Drug_Code&quot;&gt;National Drug Code&lt;/a&gt;. Это строка которая может содержать &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxxx-xxxx-xx&lt;/code&gt; (10 знаков), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxxxx-xxx-xx&lt;/code&gt; (10 знаков), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxxxx-xxxx-x&lt;/code&gt; (10 знаков) или &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxxxx-xxxx-xx&lt;/code&gt; (11 знаков) значения. Спустя год разработки вскрылось, что система содержит три формата этого кода и часть системы поддерживает только десятизначный формат, а на одиннадцатизначном падает с ошибкой. Договорились о стандарте &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5-4-2&lt;/code&gt; (11 знаков), сделали триггер на базу данных, чтобы лефтпадить значение до 11 чисел в строке (недостающие значения забивать нулями) и констрейн в базу данных на не больше 11 символов. В бизнес логике значение через лефтпад приводим к строке 11 символов (с нулями). В таком случае продюсер присылает данные в своем формате, а мы не боимся что в бд будет не валидное значение.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Нашли опечатку или ошибку? Буду рад если &lt;a href=&quot;https://github.com/2pegramming/2pegramming.github.io/tree/master/posts&quot;&gt;пошлете PR в гитхаб&lt;/a&gt;.&lt;/p&gt;
</content>
 </entry>
 

</feed>
