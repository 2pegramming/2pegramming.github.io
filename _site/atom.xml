<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title></title>
 <link href="http://pepegramming.site/atom.xml" rel="self"/>
 <link href="http://pepegramming.site/"/>
 <updated>2024-11-17T17:45:34+03:00</updated>
 <id>http://pepegramming.site</id>
 <author>
   <name>Anton Davydov</name>
   <email></email>
 </author>

 
 <entry>
   <title>Как «предсказать» какой система окажется в будущем</title>
   <link href="http://pepegramming.site/questions/system-evolution-prediction/"/>
   <updated>2024-11-18T00:00:00+03:00</updated>
   <id>http://pepegramming.site/questions/system-evolution-prediction</id>
   <content type="html">&lt;h2 id=&quot;вопрос&quot;&gt;Вопрос&lt;/h2&gt;

&lt;div class=&quot;question-text&quot;&gt;
  &lt;blockquote&gt;
    &lt;p&gt;Пытаюсь представить какой система будет в будущем, чтобы написать заранее код под нее. Но каждый раз трачу слишком много времени на то, что в итоге бизнесу не нужно. Как быть в такой ситуации?&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/div&gt;

&lt;div class=&quot;question-text&quot;&gt;
  &lt;blockquote&gt;
    &lt;p&gt;Как разработчикам принимать сложные решения, если даже бизнес не знает какой система будет в будущем?&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/div&gt;

&lt;p&gt;На первый взгляд кажется, что есть два пути как «предсказывать» будущее: использовать научный метод «пальцем в небо» (иногда может встречаться название «я так думаю»), либо использовать хардкор в духе &lt;a href=&quot;https://ru.wikipedia.org/wiki/Предсказательная_аналитика&quot; target=&quot;_blank&quot;&gt;предиктивной аналитики&lt;/a&gt;. И если предиктивная аналитика требует знаний, ресурсов и данных, то вариант с рандомом сложно продать другим, что может сказываться на принятии решений.&lt;/p&gt;

&lt;p&gt;Поэтому расскажу о еще одном подходе, который доказуемее чем «пальцем в небо», но менее затратном, чем анализ датасетов, использования теории игр, машинного обучения и изучения прошлого.&lt;/p&gt;

&lt;p&gt;Ну и важно сразу сказать, хоть буду использовать слово «предсказание», на деле, подход сводится к отсечению возможных вариантов развития через анализ ограничений. Благодаря чему можно предположить в каких границах нужна система, чтобы вписаться в требуемые ограничения и требования. И полученный результат зависит от «правильности» выбора людей и списка систем, которые будут изучаться.&lt;/p&gt;

&lt;p&gt;Хоть в ответе буду опираться на техническую систему (код, который крутится в виде приложения), но хочется рассказать абстрактную идею, так как идея и подходы работают не только в технических системах. Поэтому, первая часть ответа абстрактная, а во второй появится конкретика с названием подходов и моделей.&lt;/p&gt;

&lt;h2 id=&quot;как-угадать-будущее&quot;&gt;Как «угадать» будущее&lt;/h2&gt;

&lt;p&gt;К сожалению, угадать будущее нельзя. Как минимум, сколько не старайтесь, но точные требования к системе, которые станут необходимы через полгода, не узнать (а если узнаете – еще 10 раз требования поменяются). Аналогично работают «заверения» от бизнеса, что через пол года будет х100 клиентов. Поэтому, вместо попытки угадать требования под систему в будущем, можно определить «границу» в которой система развивается и на основе этой «границы» предполагать, что в системе будет происходить и заранее подготовиться к этому моменту. Ну либо решить, на сколько текущие решения будут подходить под границу из будущего.&lt;/p&gt;

&lt;p&gt;Но для понимания «границы», придется вернуться &lt;a href=&quot;https://pepegramming.site/questions/how-to-be-sure-about-technical-decision/&quot; target=&quot;_blank&quot;&gt;в прошлый ответ о валидации технического решения&lt;/a&gt;, где обсуждали, что любое изменение кода (эволюция) под новые требования (как функциональные, так и связанные со свойствами) похоже на «путешествие» из точки А в точку Б.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-11-18-system-evolution-prediction/system-evolution-base.jpeg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример эволюции из прошлого ответа. Текущий код (точка А) перестал удовлетворять требованиям, поэтому придется изменять код (т.е. «переместить» код в точку Б)&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;При этом, в эволюции, важно попасть в конкретное место в пространстве, где требования будут соблюдены. Если «промахнуться», то код перестанет удовлетворять требованиям и смысла для бизнеса от системы не будет. Причем, это касается не только кода, но и других систем (natural, technical, social и так далее), поэтому дальше буду говорить о системах в целом.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-11-18-system-evolution-prediction/system-evolution-reality.jpeg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Если уложились в требования бизнеса и попали в точку Б – получим премию. В реальности, не зная требований попасть в нужную область будет проблемотично&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Если в прошлом ответе рассматривали единичный случай эволюции, то сегодня рассмотрим полное развитие, где перемещения создают «цепочку» изменений, по которой движется система. Т.е. система постоянно меняется, тем самым добавляются новые и новые точки изменений.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-11-18-system-evolution-prediction/evolution-chain.jpeg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Сделали бизнес процесс (точка А), который не подошел. Пошли реализовывать другой процесс (точка Б), потом пошли исправлять что есть (точка С), после решили улучшить работающий процесс (точка Д). Благодаря этому появляется «цепочка» постоянных изменений&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Эта цепочка – результат эволюции в течении времени в прошлом. Но, на текущий момент времени интерес представляет следующий шаг развития, чтобы заранее заложить подходящую архитектуру или избежать проблем с технологией/паттерном. Т.е. хочется узнать куда дальше будет развиваться система, чтобы заранее подготовиться и «подстелить соломы», либо изменить систему так, чтобы система продолжала удовлетворять требованиям без переписывания и ругани с менеджерами. Популярный пример – продаем бизнесу идею микросервисов, через пол года узнаем, что бизнес думал, что микросервисы помогут с высоким ТТМ, а не с перфомансом, как изначально предполагалось.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-11-18-system-evolution-prediction/evolution-chain-next-step.jpeg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Долго меняли систему и пришли в «настоящее время» (точку Е). Теперь, чтобы выбрать оптимальное техническое решение, хотелось бы узнать куда будет развиваться система дальше&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;При этом, система эволюционирует не хаотично (избегаю обсуждения стартапов и PoC проектов, о чем поговорим далее). Чаще развитие целенаправленно и ограниченно требованиями или другими ограничениями, которые задаются бизнесом или внешними обстоятельствами. Это могут быть как юридические ограничения, так и цели бизнеса по увеличению времени проведенном клиентами на сайте в пять раз.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-11-18-system-evolution-prediction/evolution-chain-boundary.jpeg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Если проанализировать развитие системы, можно заметить, что есть «коридор» в котором происходят изменения. Если резкие развороты и случаются, то благодаря &lt;a href=&quot;https://ru.wikipedia.org/wiki/Чёрный_лебедь_(концепция)&quot;&gt;«черным лебедям»&lt;/a&gt;&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Самое страшное, что можно сделать – преждевременно предположить куда будет развиваться система не разобравшись в «границах» развития и выйти за эти границы. Например, заняться преждевременной оптимизацией низкоуровневого кода, где ключевая цель компании – найти больше клиентов, чтобы получить больше денег или закрыть раунд инвестиций. &lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-11-18-system-evolution-prediction/evolution-chain-wrong-expectation.jpeg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Решили, что время заняться тюнингом перфоманса (красная точка Д), а на деле бизнес пытается найти процесс, который принесет денег (черная точка Д). По итогу получаем конфликт и проблемы. Время потрачено, а за бессмысленную работу спасибо не скажут&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Следовательно, «предсказание» о будущем системы сводится к поиску границ, в которой рассматриваемая система будет развиваться, а не поиску конкретной точки. Т.е. вместо того, чтобы ждать, точных чисел по нагрузке через год, можно предположить, что бизнес будет делать всё для увеличения клиентов, следовательно нагрузка будет выше, следовательно стоит о scalability (или elasticity) задуматься заранее, пока еще есть время. &lt;/p&gt;

&lt;p&gt;И из этого возникает главная проблема: каким образом определить границу, в которой будет развиваться система и не ошибиться. А с этим опять могут помочь идеи из системной инженерии и системный контекст в частности.&lt;/p&gt;

&lt;h3 id=&quot;при-чем-тут-системный-контекст&quot;&gt;При чем тут системный контекст&lt;/h3&gt;

&lt;p&gt;Кроме эволюции, &lt;a href=&quot;https://pepegramming.site/questions/how-to-be-sure-about-technical-decision/#смотрим-шире&quot; target=&quot;_blank&quot;&gt;в прошлом вопросе&lt;/a&gt;, обсуждалась концепция систем, надсистем и подсистем. Если в качестве примера взять задеплоенный код, то приложение не крутиться в вакууме: есть люди, которые пишут код, есть юзеры разных ролей, а есть бизнес, который нанял людей, чтобы написанный код закрывал потребности бизнеса. Группы людей и бизнес – такие же системы, находящиеся «над» рассматриваемой технической системой.&lt;/p&gt;

&lt;p&gt;Но кроме надсистем, придется воспользоваться еще одной идеей – &lt;a href=&quot;https://sebokwiki.org/wiki/Introduction_to_Systems_Engineering_Fundamentals#System_Context&quot; target=&quot;_blank&quot;&gt;системным контекстом (system context)&lt;/a&gt;. Т.е. связи «внешнего мира» с конкретной системой, которую рассматриваем (в умных книгах такая система называется System of Interest, SoI).&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-11-18-system-evolution-prediction/system-context.jpg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Концептуальная модель системного контекста. System of Interest (SoI) – система, контекст которой интересен для анализа&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;В качестве примера, давайте рассмотрим базовый интернет магазин который продает физические товары. Нас будет интересовать непосредственно техническая часть, которая состоит из модуля магазина (для клиентов), модуля оплаты, склада и доставки. В данном случае магазин – система интереса (SoI), поведение которой будем предсказывать.&lt;/p&gt;

&lt;p&gt;Кроме технической составляющей бизнес состоит из других систем, которые связаны с технической: склады в городе, люди которые работают, бухгалтерия, поставщики и так далее. Вроде бы кажется, что этого хватит, но бизнес тоже не в воздухе существует: есть разные обстоятельства, которые влияют на бизнес. Например, законы страны, где бизнес работает, мода, строение городов и логистика, инвестиции и прибыль, рынок и конкуренты и так далее.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-11-18-system-evolution-prediction/system-context-example-shop.jpg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Абстрактная концептуальная схема контекста технической системы (зеленая), которая интересна для «предсказания» будущего. Но техническая система не живет сама по себе, система часть большей системы бизнеса (синий). А еще, на бизнес влияет внешний мир&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Понимая контекст системы, можно определить как каждая из систем будет влиять на SoI, тем самым «ограничивать» пространство, в котором система может развиваться.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-11-18-system-evolution-prediction/system-context-example-shop-limitations.jpeg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Каждая система из системного контекста накладывает свои ограничения или требуют своих свойств от системы, т.е. определяют границы в которых может развиваться система. Они могут как наслаиваться, так и болтаться в воздухе&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Следовательно, определив ограничения, можно предположить в какую сторону будет двигаться эволюция системы.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-11-18-system-evolution-prediction/system-context-example-shop-limitations-space-for-evolution.jpeg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Вот этот странный заштрихованный кусок – пространство, где интересующая система развивается. Опять же, если не случится черный лебедь&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Из этой идеи следует, что магия «предсказания» сводится к трем шагам:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Определить контекст рассматриваемой системы;&lt;/li&gt;
  &lt;li&gt;Определить ограничения и свойства, которые накладываются другими системами (как внешними, так и теми, что внутри бизнеса);&lt;/li&gt;
  &lt;li&gt;Скорректировать контекст и ограничения спустя N времени. Связано с тем, что система меняется, следовательно контекст также изменится. При этом, ограничения тоже меняются со временем (новые законы, цели и стратегия компании меняется, появляются новые привычки пользователей), что также придется учитывать;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Важный момент, связанный со сроком ««предсказания»: чем дальше будущее, тем больше вероятности ошибиться. Т.е. предсказать что будет с системой через десять лет будет сложнее (и выводы абстрактнее), чем предсказать, что будет с системой через пол года. Но так как, для большинства решений, необходимо понимать, что будет с системой через 6-12 месяцев, подход будет работать. Что связано с инертностью бизнеса (кроме стартапов) и окружения, влияющего на бизнес. Т.е. изменения происходят не за один день, опять же, кроме «черных лебедей».&lt;/p&gt;

&lt;h2 id=&quot;на-что-обратить-внимание-для-понимания-контекста-и-ограничений&quot;&gt;На что обратить внимание для понимания контекста и ограничений&lt;/h2&gt;

&lt;p&gt;Идея выше может показаться абстрактной, поэтому стоит рассказать как искать системы и где искать ограничения. В виду формата ответов на вопросы, подробно описывать каждый пункт не осилю, так как для этого &lt;a href=&quot;https://tough-dev.school/system-analysis&quot; target=&quot;_blank&quot;&gt;придется написать курс&lt;/a&gt;. Но хочется верить, что этого хватит для самостоятельного обучения. Если есть что добавить – пишите в комментариях, буду рад дополнить ответ.&lt;/p&gt;

&lt;h3 id=&quot;как-найти-контекст&quot;&gt;Как найти контекст&lt;/h3&gt;

&lt;p&gt;Предложу 4 варианта:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Решение в лоб, когда надо быстро и опыта в других подходах нет. Берем (или создаем) список стейкхолдеров и отделов бизнеса. После смотрим из чего состоит бизнес, общаясь со стейкхолдерами. Во время общения спрашиваем об интеграциях с которыми взамодействует стейкхолдер. В моделе системного контекста указываем как стейкхолдеров, так и интеграции (внешние и внутренние), благодаря чему получаем требуемый контекст;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.marketlinks.org/good-practice-center/value-chain-wiki/value-chain-mapping-process&quot; target=&quot;_blank&quot;&gt;Value chain map&lt;/a&gt;, который основан на цепочке добавленной стоимости. Поможет в будущем для создания wardley map;&lt;/li&gt;
  &lt;li&gt;Определение поддоменов и контекстов из стратегического DDD. &lt;a href=&quot;https://stackoverflow.com/questions/73077578/what-actually-is-a-subdomain-in-domain-driven-design&quot; target=&quot;_blank&quot;&gt;Пример «картинки» можно посмотреть в вопросе со SO&lt;/a&gt;;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.strategyzer.com/library/the-business-model-canvas&quot; target=&quot;_blank&quot;&gt;Business model canvas&lt;/a&gt;;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.trinion.org/blog/idef0-znakomstvo-s-notaciey-i-primer-ispolzovaniya&quot; target=&quot;_blank&quot;&gt;Использовать IDEF0&lt;/a&gt;;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Важный момент&lt;/strong&gt;: легко провалиться в поиск только технических систем (нет кода == нет системы). Например, отдел маркетинга может вариться в собственном мире со своими технологиями, которые не связаны с отделом разработки, но для полного контекста такой отдел стоит указать в модели. Т.е. важно описать каждую систему, что есть в бизнесе и всё, что влияет на бизнес извне, не важно, связанно это с кодом и технической системой или нет.&lt;/p&gt;

&lt;h3 id=&quot;где-искать-ограничения&quot;&gt;Где искать ограничения&lt;/h3&gt;

&lt;p&gt;Список зависит от знаний и фантазии. Опишу только места, которые стоит проверить в первую очередь. Если предложите другие места, буду рад и добавлю в ответ.&lt;/p&gt;

&lt;h4 id=&quot;бизнес-стратегия&quot;&gt;Бизнес стратегия&lt;/h4&gt;

&lt;p&gt;Цель – понять как бизнес каждый элемент из которого состоит (поможет с reliability, availability, scalability и другими характеристиками) и как часто придется менять элемент (влияет на maintainability/modifiability). Например, зная, что бизнес хочет постоянно менять магазин в ближайшем году, будет разумно заранее вкладываться в поддерживаемость кода и его модульность.&lt;/p&gt;

&lt;p&gt;Четыре варианта куда можно посмотреть, чтобы получить стратегию:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;На прямую попросить бизнес (или каждый отдел) поделиться стратегией. После смотрим как каждый отдел планирует развиваться (какие задачи на ближайший год, как часто меняться будет, сколько денег у отдела и так далее);&lt;/li&gt;
  &lt;li&gt;Определить виды поддоменов (это о core, generic, supporting). Можно использовать &lt;a href=&quot;https://github.com/ddd-crew/core-domain-charts&quot; target=&quot;_blank&quot;&gt;core domain chart&lt;/a&gt;. Идея в том, что благодаря поддоменам можно определить как часто будут меняться элементы системы (влияет на maintainability/modifiability), на сколько важны части системы (может говорить о reliability) и так далее;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/wardleymaps/on-being-lost-2ef5f05eb1ec&quot; target=&quot;_blank&quot;&gt;Wardley mapping&lt;/a&gt;. Аналогично поиску типов поддоменов;&lt;/li&gt;
  &lt;li&gt;Из &lt;a href=&quot;https://www.strategyzer.com/library/the-business-model-canvas&quot; target=&quot;_blank&quot;&gt;business model canvas&lt;/a&gt; можно вытащить ограничения;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Как и в секции с контекстом, тут важно не провалиться в технические детали. Плюс, бизнесовая стратегия не подразумевает описание того, что будет делаться, скорее ждите описание того, что ожидается от каждой части бизнеса.&lt;/p&gt;

&lt;h4 id=&quot;stakeholder-requirements-и-стратегия&quot;&gt;Stakeholder requirements и стратегия&lt;/h4&gt;

&lt;p&gt;Любой бизнес (в общем смысле) включает в себя людей или заинтересованные стороны (стейкхолдеры). Каждый из стейкхолдеров ожидает свое от системы и пытается реализовать собственные ожидания (не всегда успешно). Поэтому выделяют отдельный набор требований – &lt;a href=&quot;https://systems.education/biz-req#rec229736836&quot; target=&quot;_blank&quot;&gt;stakeholder requirements&lt;/a&gt;, которые, вместе с бизнес требованиями превращаются в функциональные требования и NFR.&lt;/p&gt;

&lt;p&gt;При этом, у стейкхолдеров есть собственная стратегия, как и у бизнеса. Наша задача как раз понять что ждут и чего хотят стейкхолдеры, чтобы из этого получить дополнительные ограничения. Кроме этого, у стейкхолдеров можно спросить личную модель системного контекста с ограничениями/свойствами, чтобы убедиться в корректности модели системного контекста, что также полезно.&lt;/p&gt;

&lt;h4 id=&quot;специфика-домена&quot;&gt;Специфика домена&lt;/h4&gt;

&lt;p&gt;Помним об ограничениях, которые по дефолту зашиты в предметную область. Это может быть как &lt;a href=&quot;https://www.hhs.gov/hipaa/index.html&quot; target=&quot;_blank&quot;&gt;HIPAA&lt;/a&gt; для медицины, так и &lt;a href=&quot;https://listings.pcisecuritystandards.org/documents/PCI_DSS-QRG-v3_2_1.pdf&quot; target=&quot;_blank&quot;&gt;PCI DSS&lt;/a&gt; для фин доменов. Кроме комплаенсов, можно встретить ограничения для моделей данных (стоит сразу о графах подумать для anti-froud систем, а для справочных систем о документо-ориентированной модели данных).&lt;/p&gt;

&lt;p&gt;Так как отсутствуют общие гайды для каждого бизнеса в конкретном домене (в виду специфики), то лучше сразу идти к доменному эксперту. И уже из эксперта вытаскивать ограничения и требования, которые накладываются на системный контекст в целом.&lt;/p&gt;

&lt;h4 id=&quot;этапы-развития-системы&quot;&gt;Этапы развития системы&lt;/h4&gt;

&lt;p&gt;Начинаем со стартапа, развиваемся до бизнеса, который расширяется, после становимся энтерпрайзом. На каждом из этапов жизни компании нужны определенные свойства и будут уникальные ограничения. Будет странно вкладывать ресурсы в кодовые абстракции в стартапе, где скорость реализации новых гипотез критична для выживаемости компании. Плюс, зная что бизнес перешел в новую стадию, можно заранее предположить, что будет требоваться от технической системы. Подробнее об этапах жизни можно &lt;a href=&quot;https://corporatefinanceinstitute.com/resources/valuation/business-life-cycle/&quot; target=&quot;_blank&quot;&gt;почитать в интернете&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;технические-ограничения&quot;&gt;Технические ограничения&lt;/h4&gt;

&lt;p&gt;Это касается как языка и экосистемы, так и версий технологий и используемых подходов. Связано с тем, что фреймворки могут накладывать ограничения, в которых система развивается (привет &lt;a href=&quot;https://en.wikipedia.org/wiki/Convention_over_configuration&quot;&gt;convention over configuration&lt;/a&gt;){:target=”_blank”}. А иногда старые версии критически важных библиотек не позволяют изменить систему так, как требуется по требованиями.&lt;/p&gt;

&lt;h4 id=&quot;государства-законы-и-социокультурные-особенности&quot;&gt;Государства, законы и социокультурные особенности&lt;/h4&gt;

&lt;p&gt;Бизнес крутиться в конкретной юрисдикции, значит наша цель – понять что может и не может делать бизнес как в юридических, так и в социо-культурных рамках. Вопросы лучше задавать доменным экспертам.&lt;/p&gt;

&lt;h4 id=&quot;команда-разработки-и-люди&quot;&gt;Команда разработки и люди&lt;/h4&gt;

&lt;p&gt;Так как software systems – &lt;a href=&quot;https://pepegramming.site/questions/how-to-be-sure-about-technical-decision/#смотрим-шире&quot; target=&quot;_blank&quot;&gt;социо-техническая система&lt;/a&gt;, то в контекст системы попадут люди. Это как команда разработки, так и отделы, которые используют техническую систему для собственных нужд. И если отделы влияют на техническую систему больше с позиции доменных ограничений, то с командами разработки дело обстоит сложнее. Придется думать о навыках персонала, бюджетах на найм и развитие, моральном состоянии команд, отношении людей к технологиям и так далее. Так, если нет возможности обучения или найма квалифицированных разработчиков, которые умеют в распределенные системы, то будет странно предполагать переехать на микросервисы.&lt;/p&gt;

&lt;p&gt;Тут помогут тимлиды и менеджеры. Но кроме расспроса людей, можно обратиться к &lt;a href=&quot;https://habr.com/ru/companies/otus/articles/761302/&quot; target=&quot;_blank&quot;&gt;team topology&lt;/a&gt; – набору инструментов для создания socio-technical архитектуры с помощью двух паттернов: 4 видов команд и 3 видов взаимодействия команд.&lt;/p&gt;

&lt;h4 id=&quot;финансы-компании&quot;&gt;Финансы компании&lt;/h4&gt;

&lt;p&gt;В зависимости от вида заработка (инвестиции или окупаемость без внешних инвестиций), компания будет выбирать разную стратегию развития. Зная сколько денег компания готова тратить на разработку, будет проще определить дорогое и дешевое решение. Если компания сидит на инвестициях, то с большей вероятностью, развитие компании будет строиться вокруг выполнения условий под нового раунда.&lt;/p&gt;

&lt;h2 id=&quot;риски-подхода&quot;&gt;Риски подхода&lt;/h2&gt;

&lt;p&gt;Хоть описанный подход, вокруг системного контекста и ограничений, помогает доказуемо обосновывать принятие долгосрочных решений, два с половиной риска учитывать придется.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;«Черные лебеди». Нельзя предсказать, нельзя подготовиться. Если подобное происходит (например ковид), то в этот момент контекст и ограничения поменяются, из-за чего старые решения и вектор развития может оказаться некорректным. В таком случае придется по новой анализировать и определять границы развития;&lt;/li&gt;
  &lt;li&gt;Подход зависит от «корректности» системного контекста и найденных требований и ограничений. При этом, выбор стейкхолдеров также важен, так как легко забыть важное заинтересованное лицо. Т.е. опыт по выбору изначальных условий для анализа необходим;
  - Урок из жизни: в одной компании, где попросили помочь с проектом, проанализировал контекст и нашел вроде корректные требования и ограничения, на основе которых выбирались технические решения. Все было хорошо первые пол года, пока не оказалось, что забыли об инвесторе, о котором знало три человека (я не входил в это число). При этом, у инвестора было собственное видение бизнеса и ожидания, которые сильно отличались от того, что было проанализировано. В виду этого технические решения оказались «немного» не корректными.&lt;/li&gt;
  &lt;li&gt;Из пункта выше вытекает еще один риск: стейкхолдеры могут слишком сильно поверить в собственные прогнозы. Пример из жизни: попросили помочь с системой, которую планировал сделать врач, после выхода сериала со своим участием. Врач думал, что сериал выстрелит и будут клиенты у бизнеса. На деле, ничего не вышло и клиентов не было (как я знаю). Тут поможет только работа с рисками;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;советы&quot;&gt;Советы&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;«Черных лебедей» нельзя предсказать (на то и черные лебеди), поэтому модульность и изолированность вечные друзья. Единственное, важно правильно выбрать границы элементов, по опыту определение границ по бизнес элементам/процессам работает в 80% случаев;&lt;/li&gt;
  &lt;li&gt;В стартапах нельзя предсказать во что превратиться бизнес (так ютуб из сайта знакомств стал ютубом и другие примеры). Поэтому по дефолту придерживайтесь модульности через low coupling, high cohesion. При этом, на качество кода в модуле можно забить. А модули лучше выбирать через бизнес гипотезы/фичи (чтобы не уменьшать ТТМ);&lt;/li&gt;
  &lt;li&gt;Помните, что ограничения и требования не обязательно собирать самостоятельно. Стоит попросить аналитиков, менеджеров, СТО, архитекторов или кого-то еще помочь;&lt;/li&gt;
  &lt;li&gt;Если работаете разработчиком и нет аналитиков или архитекторов – не заморачивайтесь с ограничениями. Лучше попросите стратегию бизнеса на требуемую часть системы (не путать с техническим сервисом) на ближайшее время. Обычно у бизнеса готов либо документ, либо есть представление в голове куда надо идти и что делать как минимум на полгода вперед. Плюс спросите СТО что по технической стратегии. Этого хватит;&lt;/li&gt;
  &lt;li&gt;Системный контекст подойдет не только для «предсказаний», но и для создания технической стратегии в компании. Например, &lt;a href=&quot;https://en.wikipedia.org/wiki/Zachman_Framework&quot; target=&quot;_blank&quot;&gt;zachman framework&lt;/a&gt; использует похожие идеи;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;выводы&quot;&gt;Выводы&lt;/h2&gt;

&lt;p&gt;Чтобы понять, что ожидать от технической системы, стоит помнить, что система не болтается в пустоте. О чем говорит системный контекст, т.е. набор других систем (или надсистем), которые взаимодействуют с системой, которая анализируется. При этом, контекст накладывает ограничения и требования, благодаря которым можно предположить границы, в которых система будет развиваться. А благодаря границам, можно улучшить качество принимаемых решений.&lt;/p&gt;

&lt;p&gt;Может показаться, что описанный подход заточен только для технических систем. Но на деле идею можно использовать для любых видов систем, например для менеджмента команд (чтобы понимать что с командой будет твориться в ближайшее время, кто нужен и в каком количестве). Как пример не из ИТ: в моде можно найти таких людей как тред хантеры, которые «предсказывают» что будет модно. Пример анализа, который понравился – &lt;a href=&quot;https://paris.premierevision.com/en&quot; target=&quot;_blank&quot;&gt;изучение выставки тканей в Париже&lt;/a&gt;. Идея в том, что ткань для модных вещей покупается заранее (где-то за год) и благодаря этой информации можно предсказать, какие цвета и текстура будет показана через год. Т.е. такое же изучение контекста системы и ограничений.&lt;/p&gt;

&lt;p&gt;Хоть подход и помогает объяснить почему в будущем система будет такой, но подход не отменяет важности использования других видов анализа: теории игр, анализа данных, регрессионного анализа и других методов, которые тоже стоит изучить. Скорее это еще один инструмент в копилку, который стоит комбинировать с другими методами. При этом, нельзя гарантировать, что не настанет «черный лебедь» который сломает «предсказание». И лучшая стратегия  для нивелирования подобных рисков – модульность (на уровне процессов) для быстрого изменения куска системы, а не всей системы целиком.&lt;/p&gt;

&lt;h2 id=&quot;дополнительные-ссылки&quot;&gt;Дополнительные ссылки&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;[en] Если будете использовать core domain chart, советую посмотреть &lt;a href=&quot;https://medium.com/nick-tune-tech-strategy-blog/visualising-sociotechnical-architecture-with-ddd-and-team-topologies-48c6be036c40&quot; target=&quot;_blank&quot;&gt;статью, в которой описываются паттерны эволюции поддоменов&lt;/a&gt;. А благодаря паттернам можно получить еще больше ограничений и требований;&lt;/li&gt;
  &lt;li&gt;[ru] Еще &lt;a href=&quot;https://systems.education/biz-req#rec226639930&quot; target=&quot;_blank&quot;&gt;больше примеров мест, куда стоит посмотреть&lt;/a&gt;, чтобы получить больше информации для системного контекста;&lt;/li&gt;
  &lt;li&gt;[en] Статья, которая &lt;a href=&quot;https://newsletter.fractionalarchitect.io/p/27-dont-break-the-bank-smart-spending&quot; target=&quot;_blank&quot;&gt;описывает основную информацию о бюджете в компании&lt;/a&gt;. Описывается какие бюджеты бывают и как бюджет влияет на принимаемые решения в компании. Плюс дается совет об оценки стоимости решения;&lt;/li&gt;
  &lt;li&gt;[en] Если хотите разобраться в системном контексте, советую &lt;a href=&quot;https://web.mit.edu/adamross/www/SHAH_CSER07.pdf&quot; target=&quot;_blank&quot;&gt;пейпер, в котором рассказывается что такое контекст для SoS&lt;/a&gt; (system of systems), как контексты систем взаимодействуют между собой и так далее;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Как перевести EventStorming модель в код</title>
   <link href="http://pepegramming.site/questions/how-to-map-eventstorming-to-code/"/>
   <updated>2024-10-11T00:00:00+03:00</updated>
   <id>http://pepegramming.site/questions/how-to-map-eventstorming-to-code</id>
   <content type="html">&lt;h2 id=&quot;вопрос&quot;&gt;Вопрос&lt;/h2&gt;

&lt;div class=&quot;question-text&quot;&gt;
  &lt;blockquote&gt;
    &lt;p&gt;Сделали EventStorming модель, а дальше ступор. Не понимаю как стикеры представить в коде. Пока выглядит так, что делаю двойную работу. Как выйти из тупика?&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/div&gt;

&lt;p&gt;На данный вопрос можно было бы ответить одним предложением: «берем команды и события, переводим их в тест-кейсы и «болванки» с бизнес логикой, по полученным тест кейсам заполняем код «болванок», катим в прод». Но так как вопрос задают часто и абстрактный ответ не подойдет, постараюсь подробно описать как перевести Event Storming (далее ES) в код, какую пользу можно получить и как модель помогает в тестах.&lt;/p&gt;

&lt;p&gt;Текст получился дискуссионный, так как не встречал «канона» и не знаю «как правильно». Поэтому ответ начну с длинного дисклеймера.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;В посте ниже будет пример того, как сам маплю модель на код. Поэтому, не факт, что описанный подход будет полезен, но постараюсь также пофантазировать, как это можно сделать в clean architecture, MVC фреймворках, приложениях с GraphQL и расскажу куда смотреть, если хотите каноничный &lt;a href=&quot;https://martinfowler.com/eaaCatalog/domainModel.html&quot; target=&quot;_blank&quot;&gt;domain model pattern&lt;/a&gt;. 
 
Допускаю, что перегнул с детальностью и повторением одного и того же в ответе, но решил, что лучше подробно и с примерами, чем «берете стикеры и пишете код» или «вот гитхаб, смотрите сами».
 
Держите в голове, что ответ писался для того, чтобы донести 3 главные мысли:
 &lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;Модель помогает не только при использовании &lt;a href=&quot;https://martinfowler.com/eaaCatalog/domainModel.html&quot; target=&quot;_blank&quot;&gt;domain model паттерна&lt;/a&gt; в коде (это который про value objects, entity, aggregates), но в и  других подходах, будь то MVC, использование сервис объектов, функциональные подходы и так далее;&lt;/li&gt;
    &lt;li&gt;Если уже используете ES – воспользуйтесь знаниями, добытыми из моделирования, вместо того, чтобы делать бизнес логику по своему, используя самостоятельно придуманные термины. Благодаря этому получите ubiquitous language о котором столько говорят и пишут;&lt;/li&gt;
    &lt;li&gt;Описанный подход стоит воспринимать как один из вариантов написания кода. Тестом можно вдохновиться, если не понимаете с чего начать. При этом, допускаю, что у вас может быт  другое представление о том, как реализация ES модели должна выглядеть – давайте обсуждать. Либо кидайте примеры с гитхаба, постараюсь сделать отдельную секцию с другими способами реализации;
 
Еще одно уточнение – примеры будут на псевдокоде &lt;a href=&quot;https://www.ruby-lang.org/en/&quot; target=&quot;_blank&quot;&gt;ruby&lt;/a&gt;, который постараюсь упростить и не показывать никакой сложной или специфичной бизнес логики или уникальных деталей из языка/фреймворков. Это сделано, чтобы донести идею, а не написать идеальное приложение. Если возникнут вопросы или недопонимание – тоже пишите. А если захотите сделать примеры под другие языки – буду только рад и добавлю больше примеров в ответ.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;что-еще-за-eventstorming&quot;&gt;Что еще за EventStorming&lt;/h2&gt;

&lt;p&gt;Данная часть нужна для тех, кто в первый раз слышит про EventStorming. Если знаете что это такое и (или) применяете подход в работе – можно пропустить, тут только краткая справка, без откровений.&lt;/p&gt;

&lt;p&gt;EventStorming &lt;a href=&quot;https://blog.avanscoperta.it/2014/02/12/introducing-event-storming/&quot; target=&quot;_blank&quot;&gt;придумал Альберто Брандолини в 2012–2014 годах&lt;/a&gt;. Это воркшоп, идея которого заключается в том, чтобы запереть всех сотрудников, которые работают над системой, в одной комнате, дать им инструмент для выгрузки знаний из головы. А на выходе получить схематичное описание поведения системы, с которым согласен каждый участник данного мероприятия.&lt;/p&gt;

&lt;p&gt;Важно уточнить, что это не технический воркшоп, тут важно определить доменную модель и поведение системы, а не обсудить в каком месте будет использоваться adapter паттерн или event sourcing.&lt;/p&gt;

&lt;p&gt;Краеугольный камень модели из воркшопа – события, которые появляются в системе. Под событиями подразумевают результат любого действия, т.е. это глагол в прошедшем времени, которое появляется как результат выполнения системой бизнес команды, которую запускает либо актор, либо система автоматически реагирует на события запуском команд по условию. &lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-concept-explonation.jpg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Модель того, как работает система в терминах EventStorming&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Кроме этого, в ES выделяют три уровня детализации системы: &lt;strong&gt;big picture&lt;/strong&gt;,  &lt;strong&gt;process modeling&lt;/strong&gt; и &lt;strong&gt;software design&lt;/strong&gt;. В ответе остановлюсь на process modelling.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/event-storming-levels.jpg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Уровни детализации в ES, в каждом используются свой набор стикеров и у каждого уровня собственные цели&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Благодаря тому, что process modelling является графической визуализацией бизнес процессов, а не технических алгоритмов или кусков реализации в коде, EventStorming может помочь с последующей реализацией бизнес процессов в коде. Либо же сгенерировать код из модели, о чем тоже поговорим. А получив набор изолированных commands и queries – можно изолировать код, тем самым улучшить maintainability/modifiability и testability кодовой базы.&lt;/p&gt;

&lt;p&gt;Если хотите подробнее разобраться как проводить ES, то на выбор либо &lt;a href=&quot;https://www.eventstorming.com/book/&quot; target=&quot;_blank&quot;&gt;книга Альберто (не дописанная)&lt;/a&gt;, либо &lt;a href=&quot;https://tough-roadway-bb5.notion.site/1-1-6adfeb2e07eb4269b5966ffb742d7fad#3ed1be8a4adf4dbc8320c00db41eac42&quot; target=&quot;_blank&quot;&gt;первый урок курса, который писал&lt;/a&gt;, либо &lt;a href=&quot;https://habr.com/ru/companies/oleg-bunin/articles/537862/&quot; target=&quot;_blank&quot;&gt;ссылки из интернета&lt;/a&gt;, либо гугл.&lt;/p&gt;

&lt;h2 id=&quot;мапим-eventstorming-на-код&quot;&gt;Мапим EventStorming на код&lt;/h2&gt;

&lt;p&gt;В качестве примера рассмотрим кусок выдуманной ES модели, который описывает часть интернет магазина: работу с корзиной, автоматическое пополнение склада, отчеты и часть работы сборщиков.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-example.jpg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример с магазином, в котором собрал стикеры из process modelling&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;А в качестве структуры приложения буду использовать аналог layered стиля, состоящий из трех слоев:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Транспортный слой, который является либо интерфейсом для различных видов клиентов (API/web/telegram/WS/etc), либо background processing (у рубистов это &lt;a href=&quot;https://github.com/sidekiq/sidekiq&quot; target=&quot;_blank&quot;&gt;sidekiq&lt;/a&gt;, у питонистов с натяжкой &lt;a href=&quot;https://github.com/celery/celery&quot; target=&quot;_blank&quot;&gt;celery&lt;/a&gt; и так далее), либо консьюмером для брокера сообщений;&lt;/li&gt;
  &lt;li&gt;Слой с логикой, в которой будет реализация бизнес логики которую смоделировали в ES;&lt;/li&gt;
  &lt;li&gt;Persistence слой, в котором кроме бд могут быть relations из datamapper паттерна или иные абстракции связанные с персистенсом;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/software-arch-breif-view.jpg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Три слоя, каждый слой отвечает за свою часть работы приложения. Транспортный вызывает контексты в которых реализована бизнес логика из ES. Например API для админки и для клиентов будут обращаться в одинаковый набор контекстов&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;В контексте изначального вопроса, о маппинге ES на код, интересует первые два слоя: логика и транспорт, при этом транспорт это не обязательно http запросы. Как пример: добавление товара в корзину можно  как через веб интерфейс, так и через HTTP API, либо через tg бота, либо вообще с помощью CLI. Из этого следует, что одну и туже бизнесовую логику, акторы могут вызвать используя подходящие по контексту виды транспорта. Т.е. описанная модель в ES будет работать для любых проектов: что тг ботов, что веба, что CLI инструментов, что асинхронных систем, что для вебсокетов и так далее.&lt;/p&gt;

&lt;h3 id=&quot;commands&quot;&gt;Commands&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Дальше по тексту будет использоваться термин команда, который в коде, в зависимости от языка и экосистемы может иметь другие значения. Для объяснения буду считать что бизнесовая команда мапится на бизнес логику, например сервис объект/операцию/юзкейс/команду.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Самое очевидное – команды. Это действия, совершает актор над системой, либо система автоматически выполняет как реакция на то, что произошло.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-only-commands.jpg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;В нашем примере пять команд, четыре из которых вызываются двумя акторами, а одна команда автоматически срабатывает при успешном чекауте&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Благодаря ES можно сразу назвать каждую из команд используя «общий язык» (Ubiquitous Language) найденный в процессе работы над EventStorming.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Названия команд вокруг заказа, которые вызывает покупатель: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AddItemToOrder&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RemoveItemFromOrder&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Checkout&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;Название команды пикера, который отмечает сборку заказов: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CollectOrder&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;Название команды, которая автоматически заказывает недостающие продукты на склад: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RequestMissingProduct&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Получив название для функции или объекта, делаем «болванку», в которой реализуется алгоритм действия.&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# название контекста&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ContextName&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Command&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# название команды, которую мы обнаружили в ES модели&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AddItemToCart&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# тут условная реализация алгоритма добавления продукта в заказ&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;order_repo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;add_product&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;quantity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;events&quot;&gt;Events&lt;/h3&gt;

&lt;p&gt;В случае реализации события в коде, можно предположить, что событием будет результат, который вернула команда. Т.е. если актор выполнил чекаут, получим заказ, который оформили:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ContextName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Checkout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# результат команды и будет событием, которое мы отобразили в ES&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;checked_out_order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Если на полученное событие система не реагирует автоматически, то либо возвращаем результат актору как read model, либо делаем что надо.&lt;/p&gt;

&lt;p&gt;Но, возникают ситуации, когда система реагирует на событие автоматическим запуском другой команды. В данном случае придется рассмотреть три случая:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;действие происходит в одном процессе (монолите) и можно вызвать команду на прямую;&lt;/li&gt;
  &lt;li&gt;действие происходит в двух сервисах, но связь асинхронная;&lt;/li&gt;
  &lt;li&gt;действие происходит в двух сервисах, но связь синхронная request-response;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Рассмотрим каждый на примере чекаута и дозаказа товаров.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-example-chain-of-events.jpg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Кусок модели, на котором рассмотрим как система автоматически запустит команду как реакцию на событие. О полиси поговорим в следующей части ответа&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;ситуация-1-когда-весь-код-в-монолите&quot;&gt;Ситуация 1: Когда весь код в монолите&lt;/h4&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-example-chain-of-events-monolith.jpg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Две команды в одном монолите, общаются прямым вызовом&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Тут важно определить что за «событие» вернула команда. Если оформление не получилось, возвращаем результат покупателю, а если заказ оформился - вызываем другую команду из нужного контекста:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ContextName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Checkout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# результат команды и будет событием, которое мы отобразили в ES&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# получив результат, разбираемся, что это за &quot;событие&quot; и в случае успешного чекаута &lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;order_checked_out?&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# если результат &quot;Заказ оформлен&quot; - мы вызываем следующую команду автоматически&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;ContextName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;RequestMissingProduct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;checked_out_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# если результат &quot;Заказ не оформлен&quot; - ничего не делаем&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;ситуация-2-когда-между-сервисами-асинхронное-событийное-взаимодействие&quot;&gt;Ситуация 2: Когда между сервисами асинхронное событийное взаимодействие&lt;/h4&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-example-chain-of-events-async.jpg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Каждая команда в своем сервисе, а связь между ними асинхронная&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Во первых, получаем бонус: берем готовое название события, которое будет продьюситься из первого сервиса во второй (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OderCheckedOut&lt;/code&gt;). И, &lt;a href=&quot;https://pepegramming.site/questions/make-events-small/#хочу-короткие-сообщения-потому-что-так-принято&quot; target=&quot;_blank&quot;&gt;решив какой размер события нужен&lt;/a&gt;, отправляем событие в брокер.&lt;/p&gt;

&lt;p&gt;Во вторых, коммуникация будет похожа на то, что было в первой ситуации, только вместо прямого вызова команды - отправляем событие в брокер, а из транспортного слоя консьюмера вызываем нужную команду:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# В сервисе продьюсере&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;checked_out_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;success?&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# если результат &quot;Заказ оформлен&quot; - мы отправляем событие в брокер, после чего оно консьюмится и вызывается следующая команда&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;broker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;produce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;ss&quot;&gt;topic: &lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;shop&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;ss&quot;&gt;event_name: &lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;OderCheckedOut&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;ss&quot;&gt;event_data: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;checked_out_order&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# если результат &quot;Заказ не оформлен&quot; - ничего не делаем&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# В сервисе консьюмере&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Transport&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BrokerConsumer&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;OderCheckedOut&apos;&lt;/span&gt;
        &lt;span class=&quot;no&quot;&gt;ContextName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;RequestMissingProduct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;checked_out_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;...&apos;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# ...&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;ситуация-3-когда-между-сервисами-синхронное-request-response-взаимодействие&quot;&gt;Ситуация 3: Когда между сервисами синхронное request-response взаимодействие&lt;/h4&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-example-chain-of-events-sync.jpg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Опять два сервиса для двух команд, но теперь связь синхронная (http, rpc, etc)&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Реализация аналогична первым двум ситуациям, только связь синхронная: получаем результат, определяем что за «событие», дергаем сервис через клиентскую библиотеку, либо на прямую по эндпоинту. Если используется RPC – название процедур будут названием команд. Идейно выглядит следующим образом:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;checked_out_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;success?&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# если результат &quot;Заказ оформлен&quot; - мы вызываем команду &quot;Заказать недостающие товары у поставщика&quot; в складском сервисе&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;warehouse_service&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;request_product&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;checked_out_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# в данном случае результатом вызова будет событие &quot;товары заказаны&quot; или любое другое, которое было указано в es&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# если результат &quot;Заказ не оформлен&quot; - ничего не делаем&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;actors&quot;&gt;Actors&lt;/h3&gt;

&lt;p&gt;Так как акторы это те, кто работают с системой, то ES поможет определиться с набором ролей или UI, который необходим приложению.&lt;/p&gt;

&lt;p&gt;Для этого стоит выписать каждого актора, который будет взаимодействовать с системой, после чего можно под каждого сделать уникальный UI со необходимым набором действий (если требуется).&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-example.jpg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;В рассматриваемом примере 3 актора: покупатель, сотрудник склада и маркетолог. Следовательно стоит подумать о трех видах UI, для каждого из акторов&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Кроме этого, информацию об акторах можно использовать для работы над авторизацией: один актор == одна роль (если используется RBAC). А после определения ролей можно определить кто какое действие над системой может выполнить.&lt;/p&gt;

&lt;h3 id=&quot;policies&quot;&gt;Policies&lt;/h3&gt;

&lt;p&gt;Полиси (фиолетовый стикер) – условие, при котором система автоматически запустит команду, как реакцию на событие. Т.е. если для выполнения автоматического действия надо чтобы не только событие произошло, но и было удовлетворено требуемое условие.&lt;/p&gt;

&lt;p&gt;Я знаю и использую два варианта реализации полиси в коде:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Когда полиси реализуется вне кода команды;&lt;/li&gt;
  &lt;li&gt;Когда полиси реализуется в коде команды;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если для условия надо ходить в бд или данных из события не хватает – выбираю первый. Если события хватает и нет необходимости в походе в БД – выбираю второй.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Дополнение:&lt;/strong&gt; существует еще один вариант, когда для полиси делается как доп абстракция, которая вызывается перед командой. Но кажется, что это уже будет перебор, хотя такой вариант тоже допускаю, но в статье рассматривать не буду.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;ситуация-1-когда-полиси-реализуется-вне-команды&quot;&gt;Ситуация 1: Когда полиси реализуется вне команды&lt;/h4&gt;

&lt;p&gt;Вернемся в пример, когда результат одной команды вызывает другую команду.&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;checked_out_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;success?&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# если результат &quot;Заказ оформлен&quot; - мы вызываем следующую команду автоматически&lt;/span&gt;
  &lt;span class=&quot;no&quot;&gt;ContextName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;RequestMissingProduct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;checked_out_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# если результат &quot;Заказ не оформлен&quot; - ничего не делаем&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Тут стоит проверить, хватает ли на складе продуктов, если да - ничего делать не надо, а если нет - придется дозаказывать. Если полиси вызывается вне команды, то условие придется реализовывать перед вызовом команды (например в транспортном слое):&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;checked_out_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;success?&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# если продуктов осталось меньше N - вызываем заказ недостающих товаров&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# если товаров больше N - ничего не делаем и не вызываем команду&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;product_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;warehouse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;count_of_product&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;checked_out_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;product_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;product_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;ContextName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;RequestMissingProduct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;checked_out_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# если результат &quot;Заказ не оформлен&quot; - ничего не делаем&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В данном примере используется прямой вызов куска кода, но давайте рассмотрим вариант распределенной системы с 2+ сервисами.&lt;/p&gt;
&lt;h4 id=&quot;ситуация-12-когда-система-распределенная&quot;&gt;Ситуация 1.2: Когда система распределенная&lt;/h4&gt;

&lt;p&gt;Так как полиси относится к команде, то логичнее делать команда в сервисе, к которому относится команда.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-example-chain-of-events-async.jpg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Я использовал картинку с асинхронной коммуникацией, но в синхронной будет тоже самое&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;В этом случае условие из полиси придется реализовывать в консьюмере (или в экшене контроллера для синхронного вызова).&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# В сервисе консьюмере&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Transport&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BrokerConsumer&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;consume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;OderCheckedOut&apos;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;product_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ContextName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;RequestMissingProduct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;checked_out_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;...&apos;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# ...&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;ситуация-2-когда-полиси-реализуется-в-команде&quot;&gt;Ситуация 2: Когда полиси реализуется в команде&lt;/h4&gt;

&lt;p&gt;В случае, когда полиси реализуется как часть команды – в начале команды делаем проверку:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ContextName&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Command&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RequestMissingProduct&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# наше полиси - если товара осталось меньше N на складе - дозаказываем&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;count_of_product&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;warehouse_repo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;product_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;product_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count_of_product&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;N&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;# реализация алгоритма заказа доп продуктов в магазин&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;# сразу отдаем результат, что мол все ок и ничего делать не надо, т.е. мы не вызовем команду&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt; Единственное, тут возникает вопрос, что такая команда возвращать должна. Для асинхронного вызова скипается код, а для синхронного – failure результат, который говорит, что ничего не произошло. Но тогда детали имплементации вырываются вне команды, что может говорить о текущих абстракциях. Поэтому иногда стоит возвращать что-то в духе «что надо – дозаказали».&lt;/p&gt;
&lt;h3 id=&quot;external-systems&quot;&gt;External systems&lt;/h3&gt;

&lt;p&gt;С точки зрения имплементации в коде – вызываем из команды нужную внешнюю систему и работаем с полученным результатом. Где результатом будет событие, которое внешняя система генерирует в результате работы.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-example-external-system-with-system-event.jpg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Красным маркером показал событие, которое вернется обратно в команду при синхронном вызове внешней системы&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;В коде вызов выглядит следующим образом:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ContextName&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Command&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RequestMissingProduct&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# реализация алгоритма заказа доп продуктов в магазин&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;# в данном случае мы делаем запрос во внешнюю систему вендора, у которого заказываем товар&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# а request_status будет «событием», которое возвращает внешняя система&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;request_status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Vendor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;HTTP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;request_product&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;product_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;quantity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# продолжение реализации алгоритма заказа доп продуктов в магазин&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;read-models&quot;&gt;Read models&lt;/h3&gt;

&lt;p&gt;Рид модель (зеленый стикер) – данные, которые нужны актору, чтобы принять решение о взаимодействии с системой. Например, не получив актуальную информацию по корзине (товарам и итоговой стоимости) – будет сложно принять решение, оформлять заказ или нет. А не зная информацию о товаре, будет трудно понять, стоит товар добавить в заказ или нет.&lt;/p&gt;

&lt;p&gt;Тут три ситуации, которые рассмотрим:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;когда актору нужна информация из того же монолита, где вызывается команда и данных из события хватает;&lt;/li&gt;
  &lt;li&gt;когда актору нужна информация из того же монолита, где вызывается команда, но данных из события не хватает и нужно «дообогащение»;&lt;/li&gt;
  &lt;li&gt;когда актор взаимодействует с рид моделью из другого сервиса;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Дополнение:&lt;/strong&gt; в &lt;a href=&quot;https://vladikk.com/2017/03/20/tackling-complexity-in-cqrs/&quot; target=&quot;_blank&quot;&gt;CQR/CQRS присутствуют ограничения на возвращаемый результат командой&lt;/a&gt;, а данные должны подтягиваться из query. Так как мы не говорим о каноничной реализации паттерна, то я допускаю вариант с получением рид модели из события команды, как популярный. Если планируете реализовывать паттерн – первую ситуацию можно проигнорить.&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;ситуация-1-когда-рид-модель-нужна-в-монолите-и-данных-из-события-хватает&quot;&gt;Ситуация 1: Когда рид модель нужна в монолите и данных из события хватает&lt;/h4&gt;

&lt;p&gt;Кажется, что распространенный случай. Например, в «оформление заказа» можно предположить, что события с результатом оформления заказа хватит, чтобы фронтенд смог, используя изначальный заказ, сделать страницу чекаута.&lt;/p&gt;

&lt;p&gt;Т.е. в коде возвращаем результат:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;http_action&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ContextName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;Checkout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# результат команды и будет событием, которое мы отобразили в ES&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;# используем результат команды, чтобы показать его как рид модель&lt;/span&gt;
  &lt;span class=&quot;ss&quot;&gt;render: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;А в UI, используя результат, делаем полноценную read model со статусом и наполнением заказа из информации, что осталась на фронте&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-example-read-model-as-response.jpg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Информацию о статусе заказа можно получить из события «заказ оформлен», а информацию о заказе можно либо получить из фронтового стейта, либо передать  информацию как часть события «заказ оформился»&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;ситуация-2-когда-рид-модель-нужна-в-монолите-но-данных-не-хватает&quot;&gt;Ситуация 2: Когда рид модель нужна в монолите, но данных не хватает&lt;/h4&gt;

&lt;p&gt;Если актору нужно получить данные, которые не вытащить из события, придется как минимум сходить в базу данных. Для этого я добавляю отдельную абстракцию &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;query&lt;/code&gt;, в которой происходит получение данных. Не обязательно использовать &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;query&lt;/code&gt; как название, это личная привычка.&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ContextName&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Query&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ShowOrder&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# любое получение данных, которые надо показать актору, в нашем случае - показ заказа перед чекаутом&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Пример простой, поэтому query может показаться избыточной абстракцией. Но если добавить фильтрацию, показ данных под роль или сложный поиск с дообогащением из другой БД, абстракция поможет изолировать получение данных.&lt;/p&gt;

&lt;h4 id=&quot;ситуация-3-когда-данные-для-рид-модели-нужны-в-другом-сервисе&quot;&gt;Ситуация 3: Когда данные для рид модели нужны в другом сервисе&lt;/h4&gt;

&lt;p&gt;Тут главный вопрос, какой подход в коммуникации использовать. Сам предпочитаю использовать модель коммуникаций, описанный в “&lt;a href=&quot;https://www.oreilly.com/library/view/building-microservices-2nd/9781492034018/&quot; target=&quot;_blank&quot;&gt;Building microservices&lt;/a&gt;” (Chapter 4. Microservices Communication Styles, Styles of Microserivces Commuinication). Поэтому распишу что делать для каждого из трех подходов: request-response, event-driven и common data.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/communication-types.jpg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Модель видов коммуникации в распределенных системах, которую использую для разделения коммуникаций в распределенных системах&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h5 id=&quot;request-response&quot;&gt;Request-response&lt;/h5&gt;

&lt;p&gt;Тут два варианта:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Либо данные отправляются как запрос в сервис которому данные нужны. В этом случае сервис потребитель сохраняет данные локально, а потом использует когда надо;&lt;/li&gt;
  &lt;li&gt;Либо сервис, которому нужны данные, запрашивает данные из сервиса с командой/событием;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/query-req-res-communication.jpg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;В первом случае данные отдаются в место, где данные потребуются, во втором – запрашиваются из места, где данные нужны&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Единственное, убедитесь, что с static и stamp coupling все ок.&lt;/p&gt;

&lt;h5 id=&quot;event-driven&quot;&gt;Event-driven&lt;/h5&gt;

&lt;p&gt;Cервис отправляет асинхронное событие, после чего событие консьюмится в сервисе, где нужны данные и либо сохраняется для дальнейшего использования, либо используется сразу.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/query-event-driven-communication.jpg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Продьюсится событие, которое обрабатывается сервисом потребителем и сохраняется в БД. После чего, рид модель достает нужные данные из базы&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h5 id=&quot;common-data&quot;&gt;Common data&lt;/h5&gt;

&lt;p&gt;Сервисы используют общий персистенс, после чего, сервис достает необходимые данные из общей базы:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/query-common-data-communication.jpg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Сервис потребитель даже не будет знать откуда данные взялись&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;варианты-реализации-в-других-подходах&quot;&gt;Варианты реализации в других подходах&lt;/h2&gt;

&lt;p&gt;Так как понимаю, что вариант написания кода выше может отличаться от того, что принято в других проектах или языке/фреймворке, то опишу как бы реализовывал маппинг ES в код для каждого из «популярных» способов.&lt;/p&gt;

&lt;h3 id=&quot;генерация-кода-по-es-модели&quot;&gt;Генерация кода по ES модели&lt;/h3&gt;

&lt;p&gt;Если самому писать код по ES моделе лень, можно попробовать воспользоваться генератором. Единственная проблема – работает только с джавой и котлином (для других экосистем решений не знаю). Для этого можно воспользоваться &lt;a href=&quot;https://docs.vlingo.io/xoom-designer#modeling-with-the-xoom-designer&quot; target=&quot;_blank&quot;&gt;xoom-designer&lt;/a&gt;, который сгенерирует проект с нужными абстракциями.&lt;/p&gt;

&lt;p&gt;Плюс, слышал лайфхак связанный с archimate (лично не проверял). Для этого придется &lt;a href=&quot;https://dckms.github.io/system-architecture/emacsway/it/ddd/ddd-in-practice/event-storming/archi.html&quot; target=&quot;_blank&quot;&gt;реализовать ES модель в archimate&lt;/a&gt;. После можно будет сделать экспорт модели в csv файл, а полученный файл использовать для проверки тестов, кода и для fitness functions.&lt;/p&gt;

&lt;h3 id=&quot;mvc&quot;&gt;MVC&lt;/h3&gt;

&lt;p&gt;В отличии от кода, который написал выше, в MVC абстракций меньше: model, view, controller. Так как редко видел чистые MVC проекты, добавлю еще две абстракции: service и query объекты.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Read model&lt;/strong&gt; – три возможных варианта: реализация логики в контроллере (GET запросы) (о «качестве» кода не говорим), реализация логики как метода модели и отдельный query object;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Команда&lt;/strong&gt; – три варианта, аналогичных read model: реализация в контроллере (POST, PUT, PATCH, DESTROY запросы), реализация в модели и service object;
  - Вызовы между командами делаются аналогично примеру выше;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Внешние системы&lt;/strong&gt; – никакого отличия от примера выше;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Полиси&lt;/strong&gt; – аналогично примеру выше;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В случае MVC фреймворков стоит учитывать, что бизнес логика и транспортный слой разделены (даже без явного указания этого в коде). Т.е. помнить, что экшен =/= команде, просто нет явной границы между командой и транспортом в реализации.&lt;/p&gt;

&lt;h3 id=&quot;clean-architecture&quot;&gt;Clean architecture&lt;/h3&gt;

&lt;p&gt;Держите в голове, что я не эксперт в clean architecture, поэтому могут быть ошибки. Но, в моей голове, выглядит маппинг следующим образом:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Read model&lt;/strong&gt; – располагается в infrastructure layer, если правильно концепт понимаю;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Команда&lt;/strong&gt; – use-case. Название для use-case берем из названия команд;
  - Вызовы между командами делаются аналогично примеру из основной части ответа;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Внешние системы&lt;/strong&gt; – из use-case;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Полиси&lt;/strong&gt; – аналогично примеру из основной части ответа;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;graphql&quot;&gt;GraphQL&lt;/h3&gt;

&lt;p&gt;Так как GraphQL разделяет query и mutation (команды) по дефолту, то можно не думать:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Read model&lt;/strong&gt; – query. Единственное, стоит подумать о том, какие акторы какую часть схемы будут видеть (либо авторизацию сделать под актора, либо отдельную схему под каждого из акторов)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Команда&lt;/strong&gt; – mutation. Причем названия мутаций берем из названий команд&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Внешние системы&lt;/strong&gt; – аналогично примеру из основной части ответа;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Полиси&lt;/strong&gt; – скорее всего – только часть мутации (если есть варианты лучше - пишите);&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;domain-model-pattern&quot;&gt;Domain model pattern&lt;/h3&gt;

&lt;p&gt;Если используете в проекте &lt;a href=&quot;https://martinfowler.com/eaaCatalog/domainModel.html&quot; target=&quot;_blank&quot;&gt;domain model pattern&lt;/a&gt;, то советую посмотреть &lt;a href=&quot;https://ibm-cloud-architecture.github.io/refarch-eda/methodology/domain-driven-design/&quot; target=&quot;_blank&quot;&gt;статью из интернета о том, как замапить EventStorming на domain model&lt;/a&gt;. Либо почитать &lt;a href=&quot;https://www.oreilly.com/library/view/learning-domain-driven-design/9781098100124/&quot; target=&quot;_blank&quot;&gt;Learning DDD&lt;/a&gt;, где в справочных материалах &lt;a href=&quot;https://github.com/vladikk/learning-ddd/tree/main/wolfdesk/eventually-wolfdesk/eventually&quot; target=&quot;_blank&quot;&gt;приводился пример маппинга&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;бонус-тестирование&quot;&gt;Бонус: тестирование&lt;/h2&gt;

&lt;p&gt;Дисклеймер: в данном случае будет только о black box testing. В случае, когда тестируется реализация, а не поведение, ES модель вряд-ли поможет, кроме как названиями команд/событий.&lt;/p&gt;

&lt;p&gt;Тут можно сослаться на Альберто, который &lt;a href=&quot;https://www.youtube.com/live/v4xLxmpAFdI?t=3090&quot; target=&quot;_blank&quot;&gt;приводил пример, как из ES мапить на BDD&lt;/a&gt;. Но, ES подойдет и в «обычном» тестировании, так как уже готово описание поведения. Т.е. описание того, что должны делать команды и список результатов. Это поможет в black box тестах команд, так как можно сразу понять кто и что будет вызывать и какой результат должен получится. При этом, названия тестов уже готовы, достаточно реализацию теста написать и понять контексты, в которых происходит то или иное событие.&lt;/p&gt;

&lt;p&gt;Давайте на примере оформления заказа.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-checkout-example.jpg&quot; alt=&quot;&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример чекаута, который возвращает разные результаты, в зависимости от контекста&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;На момент создания ES, мы знаем над чем происходит действие (заказ), кто выполняет действие (покупатель) и какой результат ожидается (ок, либо проблемы). На основе этой информации уже можно сделать болванку для тестов:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;describe&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Order&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# контекст в котором все ок придется определить самому&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;when purchaser ...&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;check out process completed without issues&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;# реализация теста&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;# контекст в оформление заказа фейлится придется определить самому&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;when purchaser ...&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;check out process failed &quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;# реализация теста&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Останется только понять контекст в котором происходит каждое из событий и написать реализацию теста.&lt;/p&gt;

&lt;p&gt;При этом, каждая бизнесовая команда будет содержать уникальный набор тестов в собственном файле, что позволит изолировать тесты. И никто не мешает сначала сделать EventStorming, после написать тесты, потом «сгенерировать» болванки команд, а в конце написать реализацию команды и отрефакторить полученный код. Т.е. использовать TDD/BDD подход в написании кода.&lt;/p&gt;

&lt;h2 id=&quot;итоги&quot;&gt;Итоги&lt;/h2&gt;

&lt;p&gt;Используя ES можно разделить «думать» и «делать»: сначала думаем о бизнесовом процессе с названиями и определяем связи. После – занимаемся реализацией бизнесового процесса в коде и «заполняем» алгоритмами реализации и вызовом &lt;a href=&quot;https://pepegramming.site/questions/data-model/#случай-1-проект-только-в-голове-и-хочется-понять-как-связаны-данные-между-собой&quot; target=&quot;_blank&quot;&gt;моделей о которых думаем в момент реализации концептуальной модели данных&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Благодаря такому подходу, получаем плюсы от использования ES в написании кода:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Уменьшение когнитивной нагрузки, за счет того, что придется меньше думать об общем и можно будет сфокусироваться на частном (реализации команд);&lt;/li&gt;
  &lt;li&gt;Получение «карты» процессов в системе со связями. Если понадобиться что-то исправить, можно быстро найти нужный кусок в ES и после, по названию команды, найти нужное место в коде;&lt;/li&gt;
  &lt;li&gt;Использование ubiquitous language из DDD в коде, вместо придумывания терминов, которые потом придется объяснять бизнесу (либо наоборот переводить термины бизнеса на код);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Но и минусы присутствуют, связанные с ES моделью:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Придется постоянно держать актуальную версию ES модели, что может быть затруднительно для стартапов или для компаний, где нет ответственного человека или нет интереса в поддержке моделей сотрудниками;&lt;/li&gt;
  &lt;li&gt;Придется перестраивать процессы и сначала проектировать бизнес процесс, после чего уже писать код, что не сработает для гипотез и RnD, где сначала делают, потом думают (это норм);&lt;/li&gt;
  &lt;li&gt;Придется каким-то образом верифицировать, что код и ES модель консистентны, в 99% случаев в ручную;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В конце напишу чеклист, которым пользуюсь, когда надо написать код по ES модели:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Сделать бизнес объекты под каждую команду, где название будет такое же, как название команды;&lt;/li&gt;
  &lt;li&gt;Сделать эндпоинты для каждой команды, которыми будут пользоваться акторы. При этом определить, как будут акторы разграничиваться в рамках транспорта (аунтификация, различные UI);&lt;/li&gt;
  &lt;li&gt;Разобраться с коммуникациями между командами: сделать эндпоинты/процедуры, создать необходимые топики/очереди;&lt;/li&gt;
  &lt;li&gt;Подготовить black box тесты для каждой команды. Подумать в каких контекстах появится каждое из возможных событий;&lt;/li&gt;
  &lt;li&gt;Реализовать логику команд. Добавить вызов внешних систем и (или) полиси;&lt;/li&gt;
  &lt;li&gt;Проверить, что код работает как требуется и радоваться жизни;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Если используете другой подход маппинга - буду рад, если расскажите, я дополню статью. Ну и делитесь личным опытом в комментарии, добавлю в ответ.&lt;/p&gt;

&lt;h2 id=&quot;доп-ссылки&quot;&gt;Доп ссылки&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;[en] Статья от разработчиков cucumber (тест фреймворк для BDD), в которой &lt;a href=&quot;https://cucumber.io/blog/bdd/bdd-with-event-mapping/&quot; target=&quot;_blank&quot;&gt;описывается как концепции из ддд (точнее из event mapping) перевести в тест кейсы&lt;/a&gt;. В случае с ES подход аналогичен.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;[en] Пять репозиториев с кодом, который был написан (надеюсь) с использованием EventStorming:
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/ddd-by-examples/library&quot; target=&quot;_blank&quot;&gt;github.com/ddd-by-examples/library&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/m-khooryani/OverCloudAirways-DDD-sample&quot; target=&quot;_blank&quot;&gt;github.com/m-khooryani/OverCloudAirways-DDD-sample&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/mkejeiri/Domain-Driven-Design&quot; target=&quot;_blank&quot;&gt;github.com/mkejeiri/Domain-Driven-Design&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/ddd-by-examples/factory&quot; target=&quot;_blank&quot;&gt;github.com/ddd-by-examples/factory&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/mgce/modular-monolith-nodejs&quot; target=&quot;_blank&quot;&gt;github.com/mgce/modular-monolith-nodejs&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[en] Еще один пример &lt;a href=&quot;https://github.com/ContextMapper/contextmapper.github.io/blob/master/_docs/tutorials/event-storming.md&quot; target=&quot;_blank&quot;&gt;перевода EventStorming в код&lt;/a&gt;. Для примера используется джава (если правильно распарсил).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[en] Статья не об ES, но о том, как в целом &lt;a href=&quot;https://ibm-cloud-architecture.github.io/refarch-eda/methodology/domain-driven-design/&quot; target=&quot;_blank&quot;&gt;как используя концепции тактического и стратегического DDD для написания кода&lt;/a&gt;. EventStorming тоже присутствует.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;[en] Репозиторий с &lt;a href=&quot;https://github.com/davydovanton/layerd-arch-style-with-dry-example/tree/master/contexts&quot; target=&quot;_blank&quot;&gt;кодом на руби, который сделал для воркшопа&lt;/a&gt;. Можно посмотреть как описанный подход работает в плюс-минус рабочем коде&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Как убедиться, что техническое решение нужно?</title>
   <link href="http://pepegramming.site/questions/how-to-be-sure-about-technical-decision/"/>
   <updated>2024-09-27T00:00:00+03:00</updated>
   <id>http://pepegramming.site/questions/how-to-be-sure-about-technical-decision</id>
   <content type="html">&lt;h2 id=&quot;вопрос&quot;&gt;Вопрос&lt;/h2&gt;

&lt;div class=&quot;question-text&quot;&gt;
  &lt;blockquote&gt;
    &lt;p&gt;Разработчики (или другая команда) пришли с техническим решением. Как понять, что решение нужно?&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;TLDR&lt;/strong&gt;: чтобы оценить техническое решение, нужно убедиться, что решение описывает текущее состояние системы, желаемое состояние и путь по которому пройдет эволюция. А также учитывает надсистемы – пользователей, бизнес и другие процессы. Если описание решения не охватывает эти аспекты, решение стоит доработать&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Можно было бы ответить, что надо, чтобы техническое решение было описано по заветам ADR (либо RFC), а разработчики понимали что будут делать. На деле, такой ответ бессмысленный, так как в decision record можно написать способ реализации решения, но не объяснить почему решение нужно и как решение связано с проблемой бизнеса (далее рассмотрим реальный пример).&lt;/p&gt;

&lt;p&gt;Еще одно уточнение: тема супер обширная и глубокая. Чтобы подробно ответить на вопрос, придется написать еще одну книгу (а таких книг много: &lt;a href=&quot;http://fundamentalsofsoftwarearchitecture.com&quot; target=&quot;_blank&quot;&gt;первая&lt;/a&gt;, &lt;a href=&quot;https://www.manning.com/books/architecture-modernization&quot; target=&quot;_blank&quot;&gt;вторая&lt;/a&gt;, &lt;a href=&quot;https://www.oreilly.com/library/view/software-architecture-the/9781492086888/&quot; target=&quot;_blank&quot;&gt;третья&lt;/a&gt;, &lt;a href=&quot;https://www.oreilly.com/library/view/software-architecture-and/9780138249694/&quot; target=&quot;_blank&quot;&gt;четвертая&lt;/a&gt;, &lt;a href=&quot;https://www.georgefairbanks.com/book/&quot; target=&quot;_blank&quot;&gt;пятая&lt;/a&gt;, &lt;a href=&quot;https://www.oreilly.com/library/view/economics-driven-software-architecture/9780124104648/&quot; target=&quot;_blank&quot;&gt;шестая&lt;/a&gt;  и так далее). К тому же, не буду описывать как подготовить решение на валидацию, потому что это на отдельный междисциплинарный курс тянет и ответ написать такого размера не представляется возможным.&lt;/p&gt;

&lt;p&gt;Поэтому, в ответе на вопрос решил рассказать о двух идеях, которые помогают быстро оценить насколько продумано и проанализировано предлагаемое решение.&lt;/p&gt;

&lt;h3 id=&quot;эволюция-системы&quot;&gt;Эволюция системы&lt;/h3&gt;

&lt;p&gt;Под системой подразумеваю набор связанных элементов (и свойства системы и каждого элемента). При этом, функциональность системы превышает сумму отдельных элементов (читай &lt;a href=&quot;https://en.wikipedia.org/wiki/Emergence&quot; target=&quot;_blank&quot;&gt;эмерджентность&lt;/a&gt;. А как пример - песочные часы, которые показывают сколько времени прошло, но песок и стекло, по отдельности, подобного не могут).&lt;/p&gt;

&lt;p&gt;Если рассматривать что угодно как систему, то получается, что возникает причина, в которой старая система перестает работать так, как ожидается. Следовательно, нужно изменить систему так, чтобы новая система снова начала работать корректно для новой ситуации. Т.е. эволюционировать из текущей точки А в требуемую точку Б. Причем не важно, переписываете систему целиком, либо добавляете функционал – это будет новая система в новой точке (проблему &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%80%D0%B0%D0%B1%D0%BB%D1%8C_%D0%A2%D0%B5%D1%81%D0%B5%D1%8F&quot; target=&quot;_blank&quot;&gt;корабля Тесея&lt;/a&gt; оставим для другого ответа).&lt;/p&gt;

&lt;p&gt;Такое изменение системы под новые требования идейно похоже на путешествие из точки А в точку Б. Только вместо перемещения людей в пространстве, перевозим «систему» во времени и функционале.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-27-how-to-be-sure-about-technical-decision/system-evolution-base.jpeg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Если песочные часы отсчитывали 5 минут, то для 10 минут придется увеличивать количество песка, т.е. эволюционировать систему из точки А в точку Б&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;За примерами далеко ходить не надо: &lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Делаем онлайн магазин (точка А), наступил ковид, пришли пользователи – система не справляется. Можем как масштабировать систему горизонтально, а можем навесить кеширования (точка Б);&lt;/li&gt;
  &lt;li&gt;Делаем таск трекер для компаний (точка А), но клиенты резко начали использовать новую методологию работы, которую трекер не поддерживает. Нужно сделать так, чтобы трекер мог работать с новым UberAgile, иначе клиенты уйдут к конкурентам. Можем как добавлять новый функционал, так и переписывать текущий, под новые требования (точка Б);&lt;/li&gt;
  &lt;li&gt;Делаем онлайн игру (точка А), но люди отваливаются через час игры. Можем как наваливать новых механик, так и улучшать уже реализованные (точка Б);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;При этом, эволюцию, которая не приводит систему к нужному состоянию, сложно назвать «полезной» и корректной. Например, хотим увеличить количество пользователей в стартапе. Для этого желательно, чтобы фичи появлялись как можно быстрее, а технический отдел предлагает разбить монолит на 10 сервисов руками двух из трех разработчиков. В результате фичи делать некому, деньги ресурсы тратятся непонятно на что, а time to market улетает в небо.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-27-how-to-be-sure-about-technical-decision/system-evolution-reality.jpeg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Хотели быстрее добавлять фичи в систему (точка Б), но по итогу пять лет мучаемся с распилом монолита на сервисы (точка С)&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Чтобы такой ситуации не возникло, придется разобраться с тремя проблемами: какая система до момента эволюции, какой система будет после эволюции и как будет происходить процесс. А для этого придется ответить на ряд вопросов (вопросы абстрактные, нужны больше для примера):&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Вопросы связанные с системой в текущем моменте (точка А):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Из чего состоит текущая система и какие связи между элементами?&lt;/li&gt;
  &lt;li&gt;Какие свойства у текущей системы? (SLA, выдерживаемая нагрузка, скорость добавления фичей и так далее);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Вопросы связанные с будущем видом системы (точка Б):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Какие новые свойства должны быть у системы и почему эти свойства важны?&lt;/li&gt;
  &lt;li&gt;Как должна выглядеть новая система с новыми свойствами (элементы связи)?&lt;/li&gt;
  &lt;li&gt;Как изменятся текущие свойства системы?&lt;/li&gt;
  &lt;li&gt;Какие риски могут произойти после эволюции?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Вопросы связанные с переходом из точки А в Б:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Какие способы перейти из точки А в точку Б существуют?&lt;/li&gt;
  &lt;li&gt;Какие потенциальные риски возникнут во время перехода?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;смотрим-шире&quot;&gt;Смотрим шире&lt;/h3&gt;

&lt;p&gt;Когда разработчики предлагают технические решения, часто решение рассматривает проблему исключительно с точки зрения технической системы (кода, инфраструктуры и алгоритмов реализации). Даже накину, что подобное отношение к принятию решений быстрее приведет систему к «легаси», чем отсутствие технических компетенций в команде.&lt;/p&gt;

&lt;p&gt;Чтобы избежать подобной «ловушки», придется прибегнуть к системной инженерии и концепции систем, подсистем и надсистем. Если коротко, создали код в репозитории, но код не крутиться в вакууме. Т.е. есть люди, которые этот код пишут (или просят gpt написать код), используют задеплоенное приложение, а есть бизнес, который нанял людей, чтобы написанный код закрывал потребности бизнеса. Группы людей и бизнес – такие же системы, находящиеся «над» рассматриваемой технической системой.&lt;/p&gt;

&lt;p&gt;При этом, если говорим о software systems, то тут над систем будет больше двух. Например, &lt;a href=&quot;https://cs.ccsu.edu/~stan/classes/CS530/Notes18/19-SystemsEngineering.html&quot; target=&quot;_blank&quot;&gt;в интернете можно найти такую картинку&lt;/a&gt;:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-27-how-to-be-sure-about-technical-decision/software-system-as-system-of-systems.png&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Техническая система – часть большей надсистемы связанной с организацией. А организация – подсистема для еще одной надсистемы, связанной с целями и стратегиями бизнеса и так далее&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Если слышали о правиле, которое упоминается в системной инженерии – смотреть на надсистемы рассматриваемой системы. В случае кода – это когда рассматривается не только код в репозитории, но надсистемы: работающее приложение, бизнес, сотрудников с их подходами к знаниями и так далее.&lt;/p&gt;

&lt;p&gt;Тут момент: иногда надсистемой является техническая система, если рассматриваемая система – часть технической системы, например сервисы или модули. Например, один раз рассматривал решение с выносом информации о используемых валютах в компании в отдельный сервис. Разработчик решал проблему только в рамках одного bounded context, но информация о валютах использовалась еще в четырех контекстах. На вопрос, как остальные четыре контекста будут работать – ответа не было. Т.е. даже в рамках технической системы можно сконцентрироваться на одной подсистеме (например паре сервисов) и не рассматривать техническую систему как надсистему.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-27-how-to-be-sure-about-technical-decision/technical-subsystem.jpeg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;В данном случае сервис S3 будет подсистемой (subsystem) для technical system, но сервис S3 можно рассматривать как отдельную систему с надсистемой в виде technical system&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Давайте на примерах из прошлой секции рассмотрим как изучение надсистемы может повлиять на решения проблем:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Делаем онлайн магазин, наступил ковид, пришли пользователи – система не справляется. Тут проблема может оказаться как в техническом решении (страница не открывается), так и проблема с сотрудниками (не хватает курьеров и собирателей заказов);&lt;/li&gt;
  &lt;li&gt;Делаем таск трекер для компаний, но клиенты резко начали использовать новую методологию работы, которую трекер не поддерживает. Если смотреть на техническую систему – решением будет добавить новый функционал или изменить существующий. Если смотреть на надсистему – может оказаться, что хайповый инструмент не решает проблем компаний и нужно вкладываться в обучение и объяснения, почему уже реализованные подходы в таск трекере лучше;&lt;/li&gt;
  &lt;li&gt;Делаем онлайн игру, но люди отваливаются через час игры. Технически можно пилить контент или улучшать уже реализованный. А если смотреть выше – окажется, что хватит раз в месяц разыгрывать новый айфон за первые три места в дашборде лидеров;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Этот рассказ о надсистемах нужен только для одной идеи, в рамках ответа: проблемы, которые, на первый взгляд, можно закрыть технически – не всегда стоит закрывать на уровне technical system. Иногда можно подняться выше (разобравшись в надсистеме) и найти решение там, не тратя деньги на дорогой (во всех смыслах) технический отдел. Из-за этого, чтобы понять на сколько «нужно» решение, придется разобраться, было бы проанализировано решение, вне технических изменений.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-27-how-to-be-sure-about-technical-decision/tech-business-changes-tradeoff.jpeg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Иногда проще поменять бизнес или надсистемы, чем что-то делать с кодом в виду стоимости разработки (считаем зп людей, которые будут разрабатывать и поддерживать код)&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Чтобы понять что изменение в технической системе нужно, стоит проверить две вещи:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Проверить, что изменение технической системы будет дешевле чем исправление надсистемы. В случае с играми, разыгрывать 3 айфона в месяц (~3600$ за три iPhone 16 pro max + логистика) дешевле, чем тратить даже месяц разработки одной команды (считал для связки из одного тимлида, 2 мидлов и одного дизайнера);&lt;/li&gt;
  &lt;li&gt;Проверить, что новая система вписывается в надсистемы выше. Так, если во время наплыва пользователя, доставка не справляется из-за количества людей, ускорение главной страницы не спасет, но ресурсы на разработку будут потрачены;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Вообще, эту муть с надсистами можете заметить в постах, где от разработчиков «просят» смотреть не только на код, но и на бизнес с его потребностями/проблемами. Например, &lt;a href=&quot;https://t.me/pmdaily/1196&quot; target=&quot;_blank&quot;&gt;Федя пишет об этом же&lt;/a&gt;, только без зауми вокруг системной инженерии.&lt;/p&gt;

&lt;p&gt;Может показаться, что подобными вещами должны заниматься продукты и бизнес, но давайте на примере двух «одинаковых» ADR посмотрим как это работает с техническими изменениями.&lt;/p&gt;

&lt;h4 id=&quot;пример-описания-решения-с-анализом-надсистем-и-без&quot;&gt;Пример описания решения с анализом надсистем и без&lt;/h4&gt;

&lt;p&gt;В самом начале я упомянул, что использование «фреймворков» для описания решений не поможет, так как проблема не в структуре, а в содержании. В качестве примера, давайте рассмотрим два ADR из двух архитектурных кат. Оба документа связаны с кешированием.&lt;/p&gt;

&lt;p&gt;В примере рассмотрим только секцию с контекстом так как эта часть ADR, которая отвечает за объяснение проблемы, а без понимания проблемы – решение бессмысленно. Попробуйте ответить на вопрос: какой из двух контекстов лучше объясняет причину, почему было решено использовать кеширование. И почему один из двух документов справляется с объяснением причины использования кэширования лучше.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/kamikazeSlayers/architectural-katas-2022/blob/main/adrs/adr06-caching.md&quot; target=&quot;_blank&quot;&gt;Первый ADR&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ease of use of the Spotlight app is one of the primal requirement for its success. Page load time is an important criteria that determines the quality of the end user experience. To this avail, Spotlight app utilizes caching for almost all its entities.&lt;/p&gt;

  &lt;p&gt;Caching is a common architectural paradigm that not only helps reduce the page-load time, but also help in retrieving data efficiently without loading the critical infrastructure in the system.&lt;/p&gt;

  &lt;p&gt;‘Cache Manager’ micro-service consumes all entity updates via the message bus and updates the in-memory cache. This provides an efficient way to manage cache entities, populate cache on demand.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ldynia/archcolider/blob/master/4.ADRs/013%20%20Cache%20the%20meal%20catalogue.md&quot; target=&quot;_blank&quot;&gt;Второй ADR&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;User satisfaction and speed of the application is our priority and in case of a slow\unstable connection, we’d like to have the smallest delay possible in catalog browsing. Users expect quick response times. We can safely assume that the menu catalog won’t have drastic changes during a day and we can cache the catalog with an estimated number of meals in each fridge in the user’s area. Most probably the whole menu can be formed for a week and provided for the ordering system. Based on this assumption we could upload the meal catalog once per day with the amount of available Stock Keeping Unit (SKU) in fridges. Our estimations on the update package sizes show that a catalog with 20 meals could weigh around 500kb-700kb without images. Even if it might not be a significant amount of data for a single entry, multiplying it by the number of users gives us a large amount of data to transfer which isn’t free for us and the users. The catalog updates with a meal amount might be organized as additional event messages that will be very lightweight compare to the entire catalog that will save us money on the Cost of Ownership. So we can upload this information upfront.&lt;/p&gt;

  &lt;p&gt;The purchase process, i.e. payment confirmation, always takes some time and users get used to it and this can be used to attempt to actualize a certain position in the menu.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Если выкинуть воду из первого ADR и оставить только объяснение причины из-за которой необходимо добавить кеш, то выйдет что бизнесу зачем-то нужна простота использования (ease of use) и время загрузки почему-то важный критерий для этого. При этом, сразу выбирается кеширование (а не in memory DB, например или другая тактика) и дальше начинается техническое описание вокруг инфры, сервисов и прочего. Т.е. автор первого документа проваливается в описание технического решения только в рамках technical system, не описывая проблематику с позиции бизнеса и пользователей (надсистем).&lt;/p&gt;

&lt;p&gt;Во втором контексте описание идет со стороны бизнеса и пользователей (надсистем): описывается проблема бизнеса с удовлетворенностью пользователей, описывается поведение пользователей, после чего уже идет переход к предположению, что кеш поможет, и то, не в контексте реализации, а в контексте требований к решению.&lt;/p&gt;

&lt;p&gt;Если учесть, что цель АДР – описать проблему, в которой решение принималось, то открыв первый документ через 3 года, возникнут вопросы: «почему появился кэш». В случае второго документа – конкретики станет больше и через три года, когда вернетесь к АДР, станет понятно, почему появилась идея добавить кэширования, которое постоянно ломается.&lt;/p&gt;

&lt;h3 id=&quot;как-провалидировать-техническое-решение&quot;&gt;Как провалидировать техническое решение&lt;/h3&gt;

&lt;p&gt;Если объединить две идеи, получим «правило» валидации технического решения: проверить, что авторы решения подумали как об эволюции (место старта, куда придем и как будем двигаться), так и о том, как решение связано и будет вписано в другие надсистемы. Поэтому, для валидации решения, ищу ответы на вопросы вокруг эволюции, связанные как с технической системой, так и с надсистемами.&lt;/p&gt;

&lt;p&gt;Сам список выглядит так (возможно часть вопросов пропустил, но цель донести идею):&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Вопросы связанные с системой в текущем моменте (точка А):&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Вопросы к технической системе:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Из каких элементов состоит система или часть системы, в которой будут изменения?&lt;/li&gt;
  &lt;li&gt;Какие связи между элементами и как связи работают?&lt;/li&gt;
  &lt;li&gt;Какие свойства у текущей системы? (это о SLA, перфомансе, секьюрити и других quality attributes/NFR/architectural characteristics)&lt;/li&gt;
  &lt;li&gt;Почему текущая система перестала удовлетворять требованиям?&lt;/li&gt;
  &lt;li&gt;Какие места системы не удовлетворяют требованиям?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вопросы к надсистемам:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Почему бизнесу необходимы новые свойства от системы?&lt;/li&gt;
  &lt;li&gt;Кто из characteristics заинтересован в изменениях и почему?&lt;/li&gt;
  &lt;li&gt;Какие потребности стейкхолдеров первичны, а какие вторичны?&lt;/li&gt;
  &lt;li&gt;Кто из исполнителей свободен и какие компетенции нужны для эволюции?&lt;/li&gt;
  &lt;li&gt;Какими ресурсами располагает компания момент эволюции и что из этого можно выделить на изменения?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Вопросы связанные с будущим видом системы (точка Б):&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Вопросы к технической системе:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Какие &lt;a href=&quot;https://systems.education/biz-req#rec229738249&quot; target=&quot;_blank&quot;&gt;solution requirements&lt;/a&gt; к новой системе?&lt;/li&gt;
  &lt;li&gt;Какие решения для эволюции системы рассматриваются под новые требования?&lt;/li&gt;
  &lt;li&gt;Какие свойства будут у итоговой системы при каждом варианте изменений? (нужно, чтобы понять на сколько близко система будет к точке Б);&lt;/li&gt;
  &lt;li&gt;Какой из вариантов новых систем удовлетворяет потребности лучше и почему?&lt;/li&gt;
  &lt;li&gt;Что может пойти не так в новой системе?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вопросы к надсистемам:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Какие бизнес процессы будут затронуты изменением?&lt;/li&gt;
  &lt;li&gt;На сколько критичные части бизнеса будут затронуты новой системой? (виды поддоменов из ДДД, либо value chain + commoditization из карт вордли, либо другой способ понимания важности элементов бизнеса);&lt;/li&gt;
  &lt;li&gt;Какие потребности заинтересованных сторон будут закрыты при каждом из решений?&lt;/li&gt;
  &lt;li&gt;Как изменения повлияют на надсистемы? (тут и о людях, бизнесе, и другие части технической системы);&lt;/li&gt;
  &lt;li&gt;Что дешевле, реализовать решение или оставить текущую систему без изменений?&lt;/li&gt;
  &lt;li&gt;Частный случай вопроса выше – какие интеграции надо будет добавить, изменить или удалить?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Вопросы связанные с переходом из точки А в Б:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Вопросы к технической системе:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Как произвести изменения в лучшем из вариантов и сколько это будет стоить?&lt;/li&gt;
  &lt;li&gt;Что может пойти не так во время изменений?&lt;/li&gt;
  &lt;li&gt;Как убедиться, что итоговая система будет удовлетворять новым требованиям? (например: тесты и fitness functions);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вопросы к надсистемам:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Какие риски, связанные с надсистемами, могут возникнуть (кончатся деньги, не будет специалистов, требования потеряют актуальность и так далее);&lt;/li&gt;
  &lt;li&gt;Сколько стоит решение? Не обязательно считать в деньгах, хватит и человеко-часов, даже примерных;&lt;/li&gt;
  &lt;li&gt;Был ли составлен хайлевел план эволюции для задействованных команд, кто будет работать над эволюцией? &lt;a href=&quot;https://pepegramming.site/questions/graph-as-a-project-managment-tool/&quot; target=&quot;_blank&quot;&gt;Хотя бы в общих чертах&lt;/a&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если из описания нельзя получить ответы на вопросы выше – задаю вопросы лично и после решаю на сколько авторы понимают что делают. Вопросов можно придумать бесконечное количество, но тут важнее убедиться, что во время принятия решения авторы прошли полный путь анализа и синтеза. Т.е. могут рассказать как о текущем состоянии системы, так и том, куда и почему система будет идти и как это связано как с бизнесом, так и с людьми которые будут делать изменения, использовать систему и поддерживать систему в будущем.&lt;/p&gt;

&lt;p&gt;Если видно, что решение описывает только техническую реализацию и не понятно от куда и почему решение взялось, то решение придется отклонить или попросить доделать (либо помочь с переделкой).&lt;/p&gt;

&lt;p&gt;Понимаю, что на вопросы только разработчики ответить не смогут, поэтому стоит обращаться к аналитикам, продуктам или другим людям, которые помогут с ответами.&lt;/p&gt;

&lt;h3 id=&quot;советы&quot;&gt;Советы&lt;/h3&gt;

&lt;h4 id=&quot;на-какие-надсистемы-стоит-обратить-внимание&quot;&gt;На какие надсистемы стоит обратить внимание&lt;/h4&gt;

&lt;p&gt;Можно встать в ступор, если с нуля пытаться определить надсистемы, о которых стоит думать. Чтобы жилось проще, напишу список систем о которых сам думаю, когда принимаю технические решения:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Hardware&lt;/strong&gt;. Наличие ресурсов, возможность развернуть новые базы либо сервисы, по сути инфраструктурные вопросы;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Внешние зависимости&lt;/strong&gt;. Как долго будут поддерживать библиотеки или SaaS, сколько будет стоить переезд, если зависимость отвалится (или покинет рынок), сколько времени будет стоит обучение сотрудников использованию зависимости и так далее;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Сотрудники компании&lt;/strong&gt;. С кем связано решение, сколько человек готовы работать над изменениями, какие людские компетенции в наличии у компании и надо ли проводить обучение, на сколько люди выгорели или устали, какая мотивация работать над изменениями и так далее;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Организационная структура&lt;/strong&gt;. В отличии от сотрудников, тут рассматривается структура организации: разделены команды фронтов от бека, как быстро работает команда инфраструктуры, соответствуют отделы бизнеса bounded context-ам или subdomain, существует ли команда для DX и точечной работы над сложными тех решениям. &lt;a href=&quot;https://teamtopologies.com&quot; target=&quot;_blank&quot;&gt;Team topology&lt;/a&gt; – как пример подхода, который фокусируется на данной надсистеме при решении архитектурных проблем;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Бизнесовые процессы&lt;/strong&gt;. Какие процессы будут аффектиться решением, какие процессы меняются часто, а какие медленно, на сколько кодовая структура соотносится с «элементами» бизнес процессов (тут о &lt;a href=&quot;https://www.domainlanguage.com/wp-content/uploads/2016/05/DDD_Reference_2015-03.pdf&quot; target=&quot;_blank&quot;&gt;стратегическом DDD&lt;/a&gt;, &lt;a href=&quot;https://learnwardleymapping.com&quot; target=&quot;_blank&quot;&gt;wardley mapping&lt;/a&gt;) и так далее;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Бизнес&lt;/strong&gt;. Какие стратегические цели у бизнеса в контексте квартала, года и пары лет, какие проблемы решает бизнес, какие ограничения у бизнеса на момент эволюции и так далее;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Внешние ограничения&lt;/strong&gt;. Юридические ограничения в конкретной стране, что с налогами и спецификой страны, в которой работает бизнес;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Доменная модель&lt;/strong&gt;. Спорная «надсистема», но идея в том, что у каждой доменной модели присутствуют ограничения или подходы к работе. Лучше поговорить с экспертом или почитать книги о домене;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;что-делать-если-нет-времени-отвечать-на-вопросы-а-техническое-решение-нужно-было-еще-вчера&quot;&gt;Что делать, если нет времени отвечать на вопросы, а техническое решение нужно было еще вчера&lt;/h4&gt;

&lt;p&gt;К сожалению, тут нет одного алгоритма и контекст ситуации важен:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Если говорим о стартапе, где нет денег, сотрудников и времени, то намного важнее искать прибыльные гипотезы. Следовательно, стоит забить на дотошный анализ проблем и делать как делается. А в будущем уже исправлять систему, как только появятся деньги и ресурсы для этого;&lt;/li&gt;
  &lt;li&gt;Если говорим о бизнесе, в котором надо срочно починить баг, из-за которого теряются деньги – ситуация аналогичная. Быстро фиксим, пишем постмортем (если ситуация критичная). После, разбираемся как изменить систему, чтобы было ок;&lt;/li&gt;
  &lt;li&gt;Если говорим о локальных изменениях в рамках бизнес процесса, модуля (или класса), сервиса или другой изолированной части системы – тут возникает трейдофф, между качеством и ценой решения. В случае &lt;a href=&quot;https://vladikk.com/2018/01/26/revisiting-the-basics-of-ddd/&quot; target=&quot;_blank&quot;&gt;core subdomain&lt;/a&gt; траты на дотошный анализ решений скорее окупятся, в рамках support или generic – нет;&lt;/li&gt;
  &lt;li&gt;Если говорим об изменениях, затрагивающих большую часть технической системы и компания перешла стадию «делаем как угодно, главное денег получить», то тут советую потратить пару дней на анализ. Связано это с тем, что подобная «трата времени» приведет к &lt;a href=&quot;https://fs.blog/second-order-thinking/&quot; target=&quot;_blank&quot;&gt;мышлению второго порядка&lt;/a&gt;, что удешевит техническую составляющую бизнеса. А как это «продать» бизнесу – обсудим ниже;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;что-делать-если-в-компании-плевать-и-надо-быстро-без-времени-на-подумать&quot;&gt;Что делать, если в компании плевать и надо быстро без времени на подумать&lt;/h4&gt;

&lt;p&gt;Тут как и в прошлом совете, зависит от контекста. Иногда встречаются ситуации, когда нет смысла объяснять, так как бизнес сам все понимает:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Если стартап, то делайте как делается, исправлять потом будете&lt;/strong&gt; (если будет что исправлять). Но как совет – изолируйте фичи на уровне кода (модули, классы и так далее). Нужно это, чтобы избежать god objects и «спайки» процессов бизнесовых;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Авральная ситуация&lt;/strong&gt;. Кончились деньги, наступил ковид, квантовые компьютеры сломали криптографические ключи и так далее. В таком случае скорость изменений важнее качества системы;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Бизнесу действительно не нужно «техническое качество»&lt;/strong&gt;. Встречаются ситуации, когда бизнес пилит средства инвесторов, либо начинается саботаж. Узнается после общения с бизнесом. В таком случае, можно технические решения не проверять (а лучше избегать подобных компаний);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Но если говорим о ситуации, когда в компании все хорошо, то тут придется «продавать» подход. Обычно хватает объяснения через «систему» в которой мыслит бизнес. Т.е. нет смысла продавать анализ потому что так посоветовали в интернете. Вместо этого стоит объяснить, что качество технической системы увеличится, что приведет к большему соответствию требованиям и меньшему количеству переделок после релиза (тут индивидуальные причины для каждой ситуации). Подробнее о продаже советую почитать во второй ссылке, в конце ответа.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Важно&lt;/strong&gt;: учтите, что «важное или полезное» для бизнеса =/= «важное или полезное» для инженеров. Связано это с тем, что «бизнес» видит больше не технических проблем и там другие приоритеты. Лично видел (и сам сталкивался), как подобная ситуация загоняет разработчиков в депрессию, потому что кажется, что потратить месяц на ускорение страницы на 100мс необходимо, а у бизнеса кончились деньги, нет продаж и еще конкуренты давят. Вот тут как раз еще один пример когда изучение надсистем позволит справится с подобными ситуациями.&lt;/p&gt;

&lt;h4 id=&quot;что-делать-если-другие-разработчики-не-хотят-так-заморачиваться-а-хотят-обсуждать-новые-сервисытехнологии&quot;&gt;Что делать, если другие разработчики не хотят так заморачиваться, а хотят обсуждать новые сервисы/технологии&lt;/h4&gt;

&lt;p&gt;Сложный для меня кусок ответа, так как стараюсь избегать тем, связанных с управлением и взаимодействием с людьми. Если бизнес согласен тратить время на детальный анализ решений, то можно влиять на других. Если бизнес не готов тратить ресурсы, то тут сложнее. Можно продавать подобное описание решений как &lt;a href=&quot;https://ailev.livejournal.com/1513051.html&quot; target=&quot;_blank&quot;&gt;мышление письмом&lt;/a&gt;, которое позволит глубже в проблеме разобраться. Плюс это навык за который платят выше (ну и прокачка себя как инженера, а не кодера).&lt;/p&gt;

&lt;p&gt;Но советую показывать на собственном примере, а не давить окружающих дополнительной работой. Т.е. начните описывать собственные решения подобным образом, если люди увидят пользу, то будут повторять.&lt;/p&gt;

&lt;h3 id=&quot;выводы&quot;&gt;Выводы&lt;/h3&gt;

&lt;p&gt;Не важно, сами предлагаете решение или принесли решение на валидацию из вне. Важно обратить внимание на две вещи: надсистемы (бизнес, людей, технологии, интеграции и так далее) и три этапа эволюции (точка А, точка Б и путь от А к Б). &lt;/p&gt;

&lt;p&gt;Хоть концепции и не дают 100% гарантии, что решение будет корректным, но такой анализ позволит глубже понять проблему, что приблизит к поиску наиболее подходящего решения. При этом, подобная работа увеличивает стоимость решения, что может быть вредно для бизнеса «без денег» и другим людям. Но если необходимо изменить критически важную часть системы и переживаете о долгосрочных проблемах – стоит попробовать самостоятельно, а после «продавать» остальным.&lt;/p&gt;

&lt;h3 id=&quot;ссылки&quot;&gt;Ссылки&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;[en] Урок из курса по системной инженерии, в котором &lt;a href=&quot;https://cs.ccsu.edu/~stan/classes/CS530/Notes18/19-SystemsEngineering.html&quot; target=&quot;_blank&quot;&gt;рассказывается о socio-technical systems&lt;/a&gt;. Причем упор делается на software systems, так как подобные системы – социо-технические. Советую ознакомиться, потому что ответ копирует часть материала из ссылки;&lt;/li&gt;
  &lt;li&gt;[ru] Ссылка, на которую сослался в описании продажи решений бизнесу. &lt;a href=&quot;http://agilemindset.ru/аргументация-технических-решений/&quot; target=&quot;_blank&quot;&gt;Автор описывает как аргументировать технические решения&lt;/a&gt;;&lt;/li&gt;
  &lt;li&gt;[ru] Если первая ссылка рассказывает о socio-technical системах, то тут &lt;a href=&quot;https://libraryno.ru/1-tehnicheskaya-sistema-sistemnyy-podhod-dolotov/&quot; target=&quot;_blank&quot;&gt;глава учебника, в которой рассказывается о системах, подсистемах и надсистемах&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;[en] Затронул &lt;a href=&quot;https://fs.blog/second-order-thinking/&quot; target=&quot;_blank&quot;&gt;мышление второго порядка&lt;/a&gt; в ответе. Подход напоминает, что стоит выбирать решения не по прямому результату, а по последствиям, которые появятся от решения. Так, не самое корректное решение, может оказаться предпочтительнее в будущем;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Как и почему использую Obsidian</title>
   <link href="http://pepegramming.site/questions/how-i-use-obsidian-and-why/"/>
   <updated>2024-09-14T00:00:00+03:00</updated>
   <id>http://pepegramming.site/questions/how-i-use-obsidian-and-why</id>
   <content type="html">&lt;h2 id=&quot;вопрос&quot;&gt;Вопрос&lt;/h2&gt;

&lt;div class=&quot;question-text&quot;&gt;
  &lt;blockquote&gt;
    &lt;p&gt;Привет!&lt;/p&gt;

    &lt;p&gt;Видел у тебя обсидиан, расскажи как пользуешься им и почему не выбран инструмент X?&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/div&gt;

&lt;p&gt;С одной стороны кажется, что можно только рассказать как раскидал файлы и делаю заметки в обсидиане. Но так не раскрою идею, почему обсидиан, а не другой редактор. Поэтому, давайте сначала абстрактно о базе знаний поговорим и разберемся в том, как выбрать подходящий инструмент под цели и стиль ведения заметок.&lt;/p&gt;

&lt;p&gt;Если хотите почитать как я обсидианом пользуюсь, не читая абстрактной мути, &lt;a href=&quot;#как-веду-базу-знаний&quot;&gt;вам в следующую часть текста&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Важно: так как тема связана с продуктивностью, давайте договоримся на берегу – в ответе опишу только личный опыт и то, как сам работаю с knowledge base и обсидианом. Я не гонюсь за продуктивностью (и не считаю себя экспертом в теме), реализовывать систему Лумана или Эшби 1 в 1 желания тоже нет. Плюс, у меня специфическое требование к базе знаний связанное со связями (дальше по тексту обсудим), поэтому повторять за собой не советую ибо больно и в 90% не требуется для решения рабочих задач. Еще один момент: предполагаю, что вы знаете что такое обсидиан (если нет, то либо пропустите ответ, либо сначала &lt;a href=&quot;https://help.obsidian.md/Home&quot; target=&quot;_blank&quot;&gt;почитайте документацию&lt;/a&gt;).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TLDR для тех, кто рассматривает obsidian как замену notion: если используете ноушен как project management инструмент, либо для работы с другими людьми, либо для личной продуктивности – я бы посоветовал выбрать другой инструмент. Иначе потратите много времени на настройку и 1 в 1 функционал повторить не сможете. Хотя обратные примеры существуют: &lt;a href=&quot;https://www.vicyyn.com/blog/simple-obsidian-system&quot; target=&quot;_blank&quot;&gt;раз&lt;/a&gt;, &lt;a href=&quot;https://cplong.org/2024/01/using-obsidian-notes-to-create-meaningful-productivity/&quot; target=&quot;_blank&quot;&gt;два&lt;/a&gt;, &lt;a href=&quot;https://vanadium23.me/obsidian-anytype/&quot; target=&quot;_blank&quot;&gt;три&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Всё, с душным введением закончил, давайте о заметках.&lt;/p&gt;

&lt;h2 id=&quot;выбираем-подходящий-инструмент-для-заметок&quot;&gt;Выбираем подходящий инструмент для заметок&lt;/h2&gt;

&lt;p&gt;Заметки и конспекты веду всю жизнь, начиная со школы. Когда занялся программированием, заметки тоже вел постоянно. Казалось, что если буду писать, пока учусь или работаю – сразу жизнь наладится, волосы станут шелковистыми, а каждую идею, которую прочту или услышу буду помнить годами.&lt;/p&gt;

&lt;p&gt;Но реальность оказалась другой: заметки превращались в кашу, которой пользоваться было невозможно. Не так давно нашел старые конспекты из института, и лучше бы потрогал траву, чем разбирался бы в обрывистых записях об определении реакций в шарнирных опорах балки, теоремах лагранжа и прочем. Причем, ситуация с «качеством» заметок касается не только институтских записей, но и заметок по программированию, документации проектов и информации по работе систем и остальным, что связанно с текстом в повседневной работе.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/knowledge-base-meme.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Краткое описание конспектов, заметок и документации, что я вел за последние 20+ лет&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Каждый раз проблема сводилась к бесцельному желанию писать заметки, т.е. что дальше с ними делать – не знал (сессию можно и без конспектов закрыть). Т.е. писал без цели и это было ошибкой.&lt;/p&gt;

&lt;h3 id=&quot;цели-и-заметки&quot;&gt;Цели и заметки&lt;/h3&gt;

&lt;p&gt;У решения должна быть проблема, которую будем решать. Выбор инструмента для заметок не исключение. Целей может быть много, например:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хочу почувствовать себя молодцом и сделать популярный блог о продуктивности и персональных баз знаний (валидная цель, без шуток);&lt;/li&gt;
  &lt;li&gt;Хочу перестать забывать информацию, например рецепты, которые готовятся раз в год;&lt;/li&gt;
  &lt;li&gt;Прошел &lt;a href=&quot;https://en.wikipedia.org/wiki/Warhammer_40,000:_Space_Marine_2&quot; target=&quot;_blank&quot;&gt;Warhammer 40,000: Space Marine 2&lt;/a&gt; и теперь хочу разобраться в вахе и понять кто такие Адептус Астартес и при чем тут война с хорусом;&lt;/li&gt;
  &lt;li&gt;В институте заставили сдать конспекты, а без конспектов не поставят зачет;&lt;/li&gt;
  &lt;li&gt;Хочу собрать список на чтение, которого буду придерживаться год, а не хаотично изучать что попало;&lt;/li&gt;
  &lt;li&gt;Хочу персональную «вики» по вопросам с собесов, что бы устроиться в FAANG и подсматривать ответы в случае проблем;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Тут главное честно себе сказать, для чего заметки нужны, потому что ответ определяет что будем делать и как будем решать проблему. Т.е. если нужен список рецептов, то может хватить коллекционирования в бумажном блокноте. Если нужна «вики» для собеседований, то придется найти решение, которое позволит структурировать темы. А если хотим разобраться в лоре вахи (не хотим), то тут придется думать о вайтборде с перекрестными ссылками.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/pepe-silvia-meme.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Первое, что приходит в голову, когда думаю о человеке, который пытается разобраться в лоре adeptus astartes&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Тут приходим к тому, что нет одного подхода к ведению заметок, но можно выделить «стили» ведения заметок, которые помогут в решении проблем.&lt;/p&gt;

&lt;h3 id=&quot;стили-ведения-заметок&quot;&gt;Стили ведения заметок&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://nesslabs.com/how-to-choose-the-right-note-taking-app&quot; target=&quot;_blank&quot;&gt;Сошлюсь на идею о разных видах «note-taking styles»&lt;/a&gt;, в которой автор систематизирует «архетипы заметкодеятелей». В статье выделяется три группы:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;The architect&lt;/strong&gt; – любят планировать, дизайнить процессы и использовать «фреймворки». От note-taking инструмента ждут простоту в структурировании идей. Упарываются на структуре и порядке;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;The gardener&lt;/strong&gt; – любят изучать, искать связи между идеями, подходами и прочим. От note-taking инструмента ждут возможность развивать и соединять идеи вместе. Упарываются в связи между идеями;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;The librarian&lt;/strong&gt; – любят коллекционировать, делать каталоги ресурсов. От note-taking инструмента ждут легкость нахождения собственных идей. Упарываются в сбор информации;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если упростить, то стиль сводится к выбору на чем будешь фокусироваться: структура, коллекционирование, связи. &lt;/p&gt;

&lt;p&gt;Дальше автор предлагает набор инструментов под каждый «стиль». Например, для структуры подойдет условный notion, coda и аналоги. Для тех, кто по связям упарывается – rome, obsidian, wiki-like штуки (&lt;a href=&quot;https://blinpete.github.io/wiki-graph/?lang=en&amp;amp;wordle=&amp;amp;query=Note-taking&quot; target=&quot;_blank&quot;&gt;ссылка для тех кто удивился wiki в этой группе&lt;/a&gt;) и так далее. А для тех, кто любит коллекции – bear, evernote, OneNote.&lt;/p&gt;

&lt;p&gt;Важно отметить, что каждый из стилей важен и нужен. Т.е. нет плохого или хорошего подхода в работе с заметками. Идея в том, на чем нужно фокусироваться, пока ведешь заметки. Как пример, сравните вторую часть этого ответа и &lt;a href=&quot;https://vanadium23.me/obsidian-anytype/&quot; target=&quot;_blank&quot;&gt;пост Вани об обсидиане&lt;/a&gt;, вроде два текста об одном инструменте, но стили использования инструмента отличаются. Еще один пример использования одного инструмента по разному – блоги. Например, предположу, что &lt;a href=&quot;https://ailev.livejournal.com/1689226.html&quot; target=&quot;_blank&quot;&gt;Левенчук использует блог как gardener&lt;/a&gt;, а &lt;a href=&quot;https://blog.bytebytego.com/p/ep129-the-ultimate-walkthrough-of&quot; target=&quot;_blank&quot;&gt;автор bytebytego собирает коллекции технических подходов как librarian&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Поэтому, не обязательно фокусироваться на одном стиле. Если идейно ближе фокусироваться на связях, то будет странно хранить список фильмов для просмотра в обсидиане в виде графа с кучей связей (если нет цели разбираться в сюжетах), каталог тут будет удобнее. Например, заметки с рецептами и заметки с «бытовой» информацией я веду в двух разных приложениях (не обсидиан).&lt;/p&gt;

&lt;h3 id=&quot;соединяем-цели-и-стили-вместе&quot;&gt;Соединяем цели и стили вместе&lt;/h3&gt;

&lt;p&gt;Если развивать эту идею со стилями, можно прийти к тому, что выбор инструмента будет проходить через три шага:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/3-steps-for-selecting-notetaking-tool.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Три шага, которые позволят понять, какой инструмент подойдет под конкретную задачу&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;И смысл подхода в том, что стоит рассматривать решение от проблемы, а не подгонять проблему под решение. Если хоть раз ловили себя на мысли, что если кто-то использует картотеку и много пишет, то значит тоже срочно надо завести физическую картотеку, то вот это чувство как раз о том, чтобы взять инструмент, а потом придумать под него проблему.&lt;/p&gt;

&lt;p&gt;Единственное, что не указал (так как ответ о персональных базах знаний) – кроме стиля, стоит подумать о том, сколько человек будет пользоваться инструментом. Потому что некоторые редакторы предполагают, что работать над заметками будет команда, а некоторые нет. Пожалуйста, учитывайте этот аспект тоже.&lt;/p&gt;

&lt;details class=&quot;collapse_block&quot;&gt;
  &lt;summary class=&quot;collapse_block__title&quot;&gt;Заумь: один убер инструмент или N специфичных инструментов&lt;/summary&gt;

  &lt;div class=&quot;collapse_block__content&quot;&gt;
    &lt;p&gt;Рано или поздно столкнетесь с выбором: &lt;del&gt;emacs или vim&lt;/del&gt; убер инструмент где можно сразу сделать нужную структуру, вести каталоги и находить связи, либо использовать разные инструменты, каждый под конкретную задачу.&lt;/p&gt;

    &lt;p&gt;Честно, тут дело вкуса и спор похож на споры &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_philosophy#Origin&quot; target=&quot;_blank&quot;&gt;вокруг unix философии&lt;/a&gt;. Например, фанаты ноушена любят использовать приложение для всего, где и задачи и заметки и списки и связи. Попсовый пример – &lt;a href=&quot;https://www.notion.so/templates/aesthetic-matcha-student-planner&quot; target=&quot;_blank&quot;&gt;matcha student planner&lt;/a&gt;. В обсидиане тоже так пытаются: &lt;a href=&quot;https://www.vicyyn.com/blog/simple-obsidian-system&quot; target=&quot;_blank&quot;&gt;раз&lt;/a&gt;, &lt;a href=&quot;https://cplong.org/2024/01/using-obsidian-notes-to-create-meaningful-productivity/&quot; target=&quot;_blank&quot;&gt;два&lt;/a&gt;. Ну или &lt;a href=&quot;https://vanadium23.me/obsidian-anytype/&quot; target=&quot;_blank&quot;&gt;почитайте пример Вани&lt;/a&gt;, он из обсидиана убер комбайн сделал.&lt;/p&gt;

    &lt;p&gt;Проблем с таким подходом не вижу (главное чтобы работало, а не сжирало время на поддержку). Хотя мне ближе 1 инструмент под одну задачу и не мешать информацию по личным делам и рабочим. Банально, но голове так проще. Единственное исключение – todo app, в котором храню что рабочие, что личные задачи.&lt;/p&gt;
  &lt;/div&gt;
&lt;/details&gt;

&lt;h3 id=&quot;зачем-использую-заметки&quot;&gt;Зачем использую заметки&lt;/h3&gt;

&lt;p&gt;С абстрактным выбором инструмента закончили, теперь о личных проблемах, которые решаю заметками. Как писал выше, пока делал заметки, изначально я не ставил никакой цели, а просто писал, потому что так «принято» и «надо». Из-за этого заметки превращались в свалку, которая забывалась и выбрасывалась.&lt;/p&gt;

&lt;p&gt;На сегодня проблема сформировалась – по работе необходимо делать контент вокруг инженерных штук. Это как курсы, так и выступления, посты, обучающий материал для компаний, ADR, описание систем и собственный ресерч в темах, чтобы лучше разобраться и не запоминать тонну информации, названий инструментов и специфических особенностей использования паттернов или технологий.&lt;/p&gt;

&lt;p&gt;Т.е. цель – получить как можно больше материала и что важнее, связей. А после жонглировать информацией в зависимости от исходной цели требуемого контента. Выглядит это так: сначала собираю темы, связывая темы между собой, а потом, когда надо сделать что-то, выбираю нужные заметки и референсы, на основе которых пишу контент.&lt;/p&gt;

&lt;p&gt;Идейно это похоже на &lt;a href=&quot;https://en.wikipedia.org/wiki/Integrated_assessment_modelling&quot; target=&quot;_blank&quot;&gt;integrated model&lt;/a&gt;, где создается модель, для которой генерируется projection под задачу. Если пользовались fusion360 или аналогичными CAD – это как из 3д модели получить чертеж для вида сбоку, либо направления сил, действующих на изделие. Вот с заметками аналогичная идея: сначала делаю полную «модель» информации, а потом, когда нужно ответить на вопрос – собираю projection из полученной модели, нужно сделать доклад – собираю другой projection из той же модели. Может показаться, что это выглядит как локальная вики, но на деле гуглить приходится много, потому что тем слишком много и не успеваешь разбирать каждую и добавлять к себе в базу.&lt;/p&gt;

&lt;p&gt;Благодаря этому для &lt;a href=&quot;https://tough-dev.school/system-analysis&quot; target=&quot;_blank&quot;&gt;курса по анализу систем&lt;/a&gt; вышло 500 страниц А4 контента и 300+ референсных материалов на курс. А сам курс написал за пол года. Единственный минус – пришлось потратить еще 3+ года на то, чтобы собрать информацию которую потом использовал для курса.&lt;/p&gt;

&lt;p&gt;В целом, работа с заметками выглядит как два не связанных цикла:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/personal-knowledge-base-cycle.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Два цикла, которые не зависят друг от друга. В левом наполняю базу знаний, в правом использую накопленные записи для контента, а появляющиеся идеи или «знания» помещаю в базу знаний&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;что-использовать-для-поиска-связей-вместо-обсидиана&quot;&gt;Что использовать для поиска связей вместо обсидиана&lt;/h3&gt;

&lt;p&gt;В ответе упоминается только обсидиан. Но это не единственный инструмент, который помогает с поиском связей между заметками. Ниже список инструментов, что сам использовал и на что можно посмотреть:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://evernote.com&quot; target=&quot;_blank&quot;&gt;Evernote&lt;/a&gt;. Первое note-taking приложение, что использовал. Так как не понимал что и зачем делаю, было не удобно. Знаю, что есть фанаты, но это не инструмент для поиска связей;&lt;/li&gt;
  &lt;li&gt;Приватный репозиторий с md файлами + любимый редактор. Идеальное во всем решение, кроме поиска связей между заметками;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.thebrain.com&quot; target=&quot;_blank&quot;&gt;The Brain&lt;/a&gt;. В 2016 году часто слышал о приложении, даже пробовал сам. Не понравилось, что связывались концепции, а не заметки + работа в крупном графе вызывает вопросы с точки зрения удобства (ниже подробнее расскажу). Плюс, не было задачи для инструмента, поэтому забил;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.inkdrop.app&quot; target=&quot;_blank&quot;&gt;InkDrop&lt;/a&gt;. Идейно ближе к evernote или bear. Со связями аналогично, сделать можно, а исследовать проблемно. Поэтому, &lt;a href=&quot;https://www.youtube.com/watch?v=a9SCmSKbSVs&quot; target=&quot;_blank&quot;&gt;пытался сделать графовое отображение для заметок&lt;/a&gt;, что бы лучше связи искать;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://roamresearch.com&quot; target=&quot;_blank&quot;&gt;Roam Research&lt;/a&gt;. Засматривался на приложение еще до появления обсидиана. Оттолкнула цена + работа только в браузере. Для локальной работы подойдет &lt;a href=&quot;https://github.com/foambubble/foam&quot; target=&quot;_blank&quot;&gt;foam&lt;/a&gt;, который работает в vscode. Но было лень разбираться в деталях;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://logseq.com&quot; target=&quot;_blank&quot;&gt;LogSeq&lt;/a&gt;. Модный на 2024 год oss инструмент, который продолжает идеи roam, плюс конкурирует с обсидианом, даже аналог canvas добавили. Пробовал сам, но не понравилось;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.devontechnologies.com/apps/devonthink&quot; target=&quot;_blank&quot;&gt;DEVONthink&lt;/a&gt;. Не пользовался, но говорят, что там можно сделать что хочешь, даже развернуть zettelkasten. Только под мак;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://orgmode.org&quot; target=&quot;_blank&quot;&gt;org-mode&lt;/a&gt;. Для сильных духом и тех, кто любит GNU и лисп. Если бы изначально использовал emacs, а не vim – остановился на org-mode;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kaorahi.github.io/howm/&quot; target=&quot;_blank&quot;&gt;howm&lt;/a&gt;. Еще один mode для emacs, если бы не org-mode. Нишевая штука, которую придумал японец (документации не на японском не было до 2023 года). Подробнее лучше &lt;a href=&quot;https://github.com/Emacs101/howm-manual&quot; target=&quot;_blank&quot;&gt;почитать в документации&lt;/a&gt;;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://znotes.thedoc.eu.org&quot; target=&quot;_blank&quot;&gt;Zettel Notes&lt;/a&gt;. Попытка сделать инструмент под zettelkasten. Не использовал;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если не хватило – &lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_personal_information_managers&quot; target=&quot;_blank&quot;&gt;в вики список еще больше&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;что-делать-если-цели-другие&quot;&gt;Что делать, если цели другие&lt;/h3&gt;

&lt;p&gt;Тут не подскажу, не рабочие заметки веду в &lt;a href=&quot;https://bear.app&quot; target=&quot;_blank&quot;&gt;bear&lt;/a&gt;, рецепты &lt;a href=&quot;https://mela.recipes&quot; target=&quot;_blank&quot;&gt;в отдельном приложении&lt;/a&gt;, а списки посмотреть/почитать/поиграть в экселе. Единственное, что могу посоветовать – определитесь с целями (делать контент мало кому нужно, если быть честным) и после выбрать подходящий стиль и под него инструмент. Если не знаете подходит ли инструмент под выбранный стиль – придется пробовать и искать самостоятельно, либо поискать ответ на reddit.&lt;/p&gt;

&lt;h2 id=&quot;как-веду-базу-знаний&quot;&gt;Как веду базу знаний&lt;/h2&gt;

&lt;p&gt;Для тех, кто не читал прошлую часть: держите в голове, что обсидиан использую только для создания нового контента. Это значит, что решения и способ использования обсидиана, которые буду описывать далее – крутятся только вокруг этой проблемы.&lt;/p&gt;

&lt;p&gt;Главное правило, которого придерживаюсь: в обсидиане только рабочая информация вокруг software систем, плюс смежные темы. Т.е. никаких дневников настроения, бытовых задач или заметок с рецептами.&lt;/p&gt;

&lt;p&gt; По структуре &lt;a href=&quot;https://help.obsidian.md/Plugins/Workspaces&quot; target=&quot;_blank&quot;&gt;obsidian workspace&lt;/a&gt; не запариваюсь, раскидал &lt;a href=&quot;https://fortelabs.com/blog/para/&quot; target=&quot;_blank&quot;&gt;файлы по PARA&lt;/a&gt;. Кроме файлов с заметками, использую whiteboard-ы где связываю темы в структуру материала (прямо как в фильмах о расследованиях), либо собираю термины во что-то осмысленное. Раньше использовал miro, но переехал на &lt;a href=&quot;https://help.obsidian.md/Plugins/Canvas&quot; target=&quot;_blank&quot;&gt;obsidian canvas&lt;/a&gt;. Так как whiteboard нужен только для структуры, минимализма canvas хватает.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/ac-course-whiteboards.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Слева структура &lt;a href=&quot;https://tough-dev.school/system-analysis&quot;&gt;AC курса&lt;/a&gt;, которую сначала делал в миро, справа – структура того же курса, но уже перенесенная в canvas обсидиана&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;о-заметках&quot;&gt;О заметках&lt;/h3&gt;

&lt;p&gt;Само собой сложилось, что использую шесть видов заметок. Возможно через пару лет появятся новые виды, но на сегодня список такой:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Базовая заметка. Основной вид заметок, в которых мысль или тему раскрываю. О размере не парюсь, некоторые могут состоять из одного предложения, а другие – лонгридом;&lt;/li&gt;
  &lt;li&gt;Журнал. Список событий вокруг темы. Например, пока читаю книгу, делаю заметки по личному отношению к книге с датой. Потом смотрю как менялось мнение спустя время, что читал книгу. Каждая запись начинается с даты. Использую потом для восстановления контекста о процессе работы или учебы;&lt;/li&gt;
  &lt;li&gt;«Research заметки». Заметки в которые кидаю ссылки на материалы, которые нужно прочитать чтобы разобраться в теме. В будущем, когда сажусь ковыряться в теме, не приходится с нуля искать материалы. Так как уже собрал пачку материалов, благодаря которой начинаю изучение, а не трачу время на поиски;&lt;/li&gt;
  &lt;li&gt;Заметка по книге/пейперу/курсу. Заметка с названием книги, началом изучения, ожиданиями и ссылками на заметки которые возникли во время изучения материала (по главам). Похоже на &lt;a href=&quot;https://obsidian.rocks/quick-tip-quickly-organize-notes-in-obsidian/#Why-are-MOCs-so-life-changing&quot; target=&quot;_blank&quot;&gt;MoC заметки&lt;/a&gt;, только собираю связи руками, а не через dataview. В заметках, которые появляются во время учебы, использую заметку по книге/курсу/пейперу как референс;&lt;/li&gt;
  &lt;li&gt;Канвас для создания структуры по контенту. Нужен для того, чтобы «раскидать» темы по «столу» и визуально понять как структурировать темы (визуально проще работать). Использую только для больших материалов. Для мелких – хватает отдельной заметки. Иногда канвас могу использовать для того, чтобы разобраться в сложной теме и сделать «концептуальную модель»;&lt;/li&gt;
  &lt;li&gt;Канбан доски. Использую только для регулярных проектов. Например, сделал доску, в которой держу список вопросов под &lt;a href=&quot;https://pepegramming.site/questions/&quot; target=&quot;_blank&quot;&gt;pepegramming questions&lt;/a&gt;. При этом, задачи и менеджмент выношу из обсидиана в отдельные инструменты, а канбан доска нужна только для планирования о чем писать дальше;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Хоть и разделяю заметки по типам, но использую один и тот же темплейт, в котором 4 секции: текст заметки, вопросы по теме, референсы и ссылки на другие заметки, которые подходят по смыслу.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
tags:
  - new_note
created at: 
---

# 
&amp;gt; заметка понятна вне контекста

## Комментарий

## Вопросы
- #открытыйвопрос &amp;lt;Вопрос&amp;gt;

## Референс
&amp;gt; откуда взята цитата или идея, вплоть до номера страницы конкретной книги

1. ...
2. ...

[1]: ...
[2]: ...

## Ссылка на другую заметку

&amp;gt; как эта идея дополняет то, что я уже знаю?
&amp;gt; как этот X повлияет на Y?
&amp;gt; как я могу при помощи этой идеи объяснить Z?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Обязательное условие существования заметки (после связей) – референсы, где в нумерованном списке откуда взял референс, а в ссылке &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[1]:&lt;/code&gt; прямая ссылка на референс. Для заметок, которые появляются как результат чтения книги указываю источник с точностью до абзаца. Если статья – оставляю ссылку, если видео – ссылка и временная точка, если книга/пейпер/курс – указываю точное расположение (как в книгах). Если собственная заметка – указываю откуда появилась идея (ссылками на другие заметки).&lt;/p&gt;

&lt;p&gt;Еще один плюс референсов – можно искать связи в других статьях или идеях. Ну или наблюдать, как авторы повторяют друг друга из раза в раз.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/why-microservices-example.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Моя заметка, где собираю причины перехода на сервисы. Каждая цифра в начале – референс, где упоминалась причина&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;details class=&quot;collapse_block&quot;&gt;
  &lt;summary class=&quot;collapse_block__title&quot;&gt;Заумь: почему не zettelkasten&lt;/summary&gt;

  &lt;div class=&quot;collapse_block__content&quot;&gt;
    &lt;p&gt;Кажется что без упоминания zettelkasten, не обходится ни одна статья вокруг базы знаний и обсидиана, в частности. Исключения делать не буду.&lt;/p&gt;

    &lt;p&gt;Для себя не вижу смысла в подходе Лумана, так как подозреваю, что люди увидели что Луман много делал и собирал картотеку с заметками. Из-за чего возникла связь, что zettelkasten == продуктивности как у Лумана. Кажется, что тут сбилась причинно-следственная связь, и картотека не является причиной продуктивности (вполне допускаю, что подхо развивал изначальное стремление Лумана). Поэтому делаю как самому удобнее, а пробовать другие варианты уже нет и сил и времени. Но с «научной» точки зрения, интересно как подход работал и на чем строился.&lt;/p&gt;

    &lt;p&gt;При этом, верю, что точное следование подхода помогает людям, но в моем случае это выглядит как вещь в себе. Хотя идею с раскидыванием «карточек» на столе для сбора материала использую, правда в виде canvas. А вот в &lt;a href=&quot;https://qnnnp.substack.com/p/3e2&quot; target=&quot;_blank&quot;&gt;собеседнике&lt;/a&gt; смысла не вижу.&lt;/p&gt;

    &lt;p&gt;Аналогично отношусь к другим подходам. В качестве примера можно вспомнить Уильяма Росса Эшби (психиатр, изучал кибернетику и сложные системы), который &lt;a href=&quot;https://fedorovpishet.ru/sistema-zapisej-uilyama-rossa-eshbi-bloknoty-na-maksimalkah/&quot; target=&quot;_blank&quot;&gt;заметки вел в виде пачки нумерованных блокнотов с кросс ссылками&lt;/a&gt;. Хоть подход Эшби мне идейно ближе, но использовать рукописные блокноты для исследований в 2k24 кажется архаично.&lt;/p&gt;
  &lt;/div&gt;
&lt;/details&gt;

&lt;h3 id=&quot;о-связях&quot;&gt;О связях&lt;/h3&gt;

&lt;p&gt;Связи между заметками – самое ценное и важное, что есть в моей базе знаний. Это то, что помогает либо глубже разбираться в темах (как пример – &lt;a href=&quot;https://pepegramming.site/questions/data-model/&quot; target=&quot;_blank&quot;&gt;ответ на вопрос с визуализацией бд&lt;/a&gt;), либо находить идейную дичь, которую потом можно раскрутить (например связь рефакторинга производства в factorio с рефакторингом software системы).&lt;/p&gt;

&lt;p&gt;Еще примеры связей, которые появились благодаря заметкам:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Используя две не связанных на первый взгляд темы с гранулярностью событий и state/delta событиями, появился ответ на &lt;a href=&quot;https://pepegramming.site/questions/make-events-small/&quot; target=&quot;_blank&quot;&gt;вопрос с матрицей размера событий&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Если проходили курс по анализу систем, то идея с инстабилити появилась, потому что нашлись две заметки которые связались через инстабилити;&lt;/li&gt;
  &lt;li&gt;Если слышали от меня идею о system form и system function в контексте EventStorming и модели данных, то это тоже благодаря связям, которые появились в заметках во время ресерча system engineering;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Так как приходится искать связи между темами, что бы из этого получались идеи для контента, то мои заметки можно представить как систему, в которой чем выше каплинг между заметками, тем лучше система работает. Для этого использую три базовых вида связей, два вида валидирую и с одним играю в свободное время.&lt;/p&gt;

&lt;h4 id=&quot;базовая-связь-прямые-ссылки-между-заметками&quot;&gt;Базовая связь: прямые ссылки между заметками&lt;/h4&gt;

&lt;p&gt;Открываем заметку и вставляем явную ссылку на другую заметку. В моей картине мира это «явная» связь, так как ссылка будет доступна не только в обсидиане, но и в другом редакторе (и даже git репозитории). По этой же причине не люблю wiki style, поэтому ссылки использую как в маркдауне (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[]()&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Различаю два вида ссылок, которые похожи на то, что можно найти в википедии. Научных названий таких ссылок не знаю, поэтому назову «как чувствую»:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;«Референс ссылка». Использую в тексте заметки. Т.е. когда говорю о maintainability, ссылаюсь на заметку о maintainability;&lt;/li&gt;
  &lt;li&gt;«Связанные заметки». Похожие на нижний блок в вики странице, где указываются референсы на другие статьи по теме;&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/wiki-link-types-example.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Где икать каждый из двух видов ссылок в википедии&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;базовая-связь-теги&quot;&gt;Базовая связь: Теги&lt;/h4&gt;

&lt;p&gt;Каждой заметки ставлю набор тегов по ключевым идеям. Знаю, что есть подход, когда вместо тегов используют заметки, но слишком ленивый для такого.&lt;/p&gt;

&lt;p&gt;Когда надо найти заметки по теме – в первую очередь ищу по тегу. После смотрю связанные прямой ссылкой заметки, чтобы получить «месиво» информации.&lt;/p&gt;

&lt;p&gt;По тегам не заморачиваюсь. Т.е. никаких вложенных тегов не использую, строгого наименования не придерживаюсь. Иногда «рефакторю», когда понимаю, что &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#event&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#events&lt;/code&gt; один и тот же тег.&lt;/p&gt;

&lt;h4 id=&quot;базовая-связь-папки&quot;&gt;Базовая связь: папки&lt;/h4&gt;

&lt;p&gt;Так как придерживаюсь PARA, то использую 5 «базовых» папок:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Inbox&lt;/strong&gt; – инбокс, в которой попадают новые заметки, которые пока не понимаю где должны находиться (если сразу знаю – пропускаю inbox);&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Projects&lt;/strong&gt; – рабочие проекты в которых собираю либо информацию по проекту (если с работой связано), либо пишу текст (аутлайн для выступлений), если проект связан с контентом. Например, ответы на вопросы пишу в этой папке;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Areas&lt;/strong&gt; – Тут базовая информация по «области» в которой ведется работа. Это может быть как название компании где работаю, так и название конференции или еще чего;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;References&lt;/strong&gt; – тут заметки созданные во время изучения. Т.е. информация по характеристикам, системной инженерии и прочему, попадает сюда. Файлы раскидываю по вложенным папкам как сам считаю нужным, но чаще по темам: все вокруг анализа систем в одно место, вокруг солюшен архитектуры в другое и так далее;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Archive&lt;/strong&gt; – тут находятся закрытые проекты или компании, с которыми больше не работаю;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;связь-которую-валидирую-метатеги&quot;&gt;Связь которую валидирую: Метатеги&lt;/h4&gt;

&lt;p&gt;Берем заметку и указываем в метатегах кто автор, где опубликована, категорию (область), подкатегорию и какая проблема решается заметкой. После, получаем дополнительные связи по авторству, проблемам и так далее. Плюс в том, что одни и те же проблемы могут решаться в разных категориях, плюс можно посмотреть чем занимаются авторы и как авторы влияют на базу знаний.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/metatags-connections-example.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример того, как могут выглядеть «области» метатегов, где в каждой области свой набор заметок, который может лежать в разных папках и тегах. Картинку взял из статьи, которая вдохновила на эксперимент с метатегами&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;На словах звучит заманчиво, на деле – из-за количества заметок которые надо обновить ничего сказать не могу и пока только валидирую на сколько адекватно так заморачиваться. Идею &lt;a href=&quot;https://habr.com/ru/articles/806339/&quot; target=&quot;_blank&quot;&gt;честно украл&lt;/a&gt;, может быть через пару лет смогу фидбек написать, но пока сказать нечего.&lt;/p&gt;

&lt;h4 id=&quot;связь-которую-валидирую-graph-analysis-plugin&quot;&gt;Связь которую валидирую: graph-analysis plugin&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/SkepticMystic/graph-analysis&quot; target=&quot;_blank&quot;&gt;Для обсидиана сделали плагин, который анализирует граф связей&lt;/a&gt; используя алгоритмы для поиска подобия, co-citations, link prediction и поиска групп заметок. Иногда пользуюсь, но пользы пока не вижу, поэтому просто валидирую.&lt;/p&gt;

&lt;h4 id=&quot;балуюсь-в-свободное-время-векторное-подобие&quot;&gt;Балуюсь в свободное время: векторное подобие&lt;/h4&gt;

&lt;p&gt;Это скорее в планах ибо инструментов нормальных нет. Идея в том, что бы &lt;a href=&quot;https://www.couchbase.com/blog/what-is-vector-search/&quot; target=&quot;_blank&quot;&gt;перевести заметки в векторы и после искать подобие&lt;/a&gt;. Благодаря этому можно найти связи, которые пропустил из-за того, что либо забыл о существовании заметки, либо потому что не нашел связь. &lt;/p&gt;

&lt;p&gt;Из того, что пробовал, самое похожее – &lt;a href=&quot;https://github.com/brianpetro/obsidian-smart-connections&quot; target=&quot;_blank&quot;&gt;плагин smart connections&lt;/a&gt;. Но плагин работает только с английским языком (и одна модель для китайского), а локальную llama не поддерживает (но в планах), из-за чего жду развития. &lt;a href=&quot;https://khoj.dev&quot; target=&quot;_blank&quot;&gt;Khoj&lt;/a&gt; похож, но требует отдельный сервис и нормально искать связи с плагином не получается.&lt;/p&gt;

&lt;h3 id=&quot;о-global-graph&quot;&gt;О global graph&lt;/h3&gt;

&lt;p&gt;Когда обсидиан появился – глобальный граф считался киллер фичей. Авторы любят показывать персональные графы, например такие:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/personal-obsidian-global-graph.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Если страдаете трипофобией – простите&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Сначала идея с глобальным графом нравилась, но когда заметок стало больше 500 штук –  граф потерял смысл из-за каши в визуализации (плюс электрон глючить начинает и фризить). Но, граф помогает с анализом «качества» прямых связей между заметками.&lt;/p&gt;

&lt;p&gt;Давайте на примере расскажу, что имею в виду.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/example-obsidian-global-graph.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Граф, который нашел в интернете. Попробуйте определить что тут не так с базой знаний&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Кажется, что граф как граф. На деле, по такой картинке можно найти два с половиной вида проблем:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;«Болтающиеся» заметки. Т.е. заметки, которые никак не связаны с другими заметками. Следовательно, используя такие заметки для создания контента, придется дополнительно думать как и с чем связаны записи, что время и силы, плюс меньше шансов найти нужную заметку;&lt;/li&gt;
  &lt;li&gt;«Цветы» в виде заметок, которые связаны только с корневой заметкой. Такие заметки появляются вокруг одной темы и это может говорить о двух проблемах: доп заметки в рамках темы не связаны между собой, либо эти заметки так же будет сложно использовать для создания контента;&lt;/li&gt;
  &lt;li&gt;Частный случай «цветов» –  отростки к одной заметке и без связей;&lt;/li&gt;
&lt;/ol&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/example-obsidian-global-graph-with-issues.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Красное – «цветы», синее – «болтающиеся» заметки&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Сразу скажу, что у меня присутствуют те же проблемы, что описаны выше. Можно заметить, что в моих заметках выделяется «core» часть, которую стараюсь держать максимально связанной и границы, где все не так хорошо, как могло бы быть:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/personal-obsidian-global-graph-issues.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;В центре связанность высокая, но по границам много «цветов» и болтающихся заметок в воздухе&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Вот благодаря глобальному графу можно быстро определить проблемы среди заметок и фиксить конкретные места. Например, раз в пол года, я выделяю себе пару недель чтобы поправить эти места, но раз и навсегда такое не исправить, что огорчает.&lt;/p&gt;

&lt;h3 id=&quot;о-dataview&quot;&gt;О dataview&lt;/h3&gt;

&lt;p&gt;Знаю, что в комьюнити обсидиана любят &lt;a href=&quot;https://blacksmithgu.github.io/obsidian-dataview/&quot; target=&quot;_blank&quot;&gt;dataview&lt;/a&gt;. Проблема тут в том, что связи, которые получаются через dataview становятся не явными (т.е. нельзя увидеть по тексту или перекрестным ссылкам ну и вне обсидиана dataview не работает). Из-за этого теряются связи во время работы над контентом. Плюс, нет гарантий, что dataview будет жить вечно и появится в других заметках (если обсидиан отвалится в будущем).&lt;/p&gt;

&lt;p&gt;Из-за этого использую dataview только для анализа: поиска заметок без тегов, без связей, либо с небольшим количеством связей и так далее. Если бы чаще требовались каталоги и MoC (Map of Content) заметки – использовал чаще.&lt;/p&gt;

&lt;h3 id=&quot;о-плагинах&quot;&gt;О плагинах&lt;/h3&gt;

&lt;p&gt;Еще при работе с vim привык использовать по минимуму плагинов. С обсидианом ситуация аналогичная. Помимо dataview, smart connections и канбан досок, каждый день использую еще три плагина:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/esm7/obsidian-vimrc-support&quot; target=&quot;_blank&quot;&gt;Obsidian Vimrc Support Plugin&lt;/a&gt;. Тут без комментариев, 12+ лет в виме меняют личность;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ozntel/oz-image-in-editor-obsidian&quot; target=&quot;_blank&quot;&gt;Ozan’s Image in Editor Plugin&lt;/a&gt;. Мне не нравится разделение на edit/view для заметок. Особенно бесит, что надо открывать view мод что бы картинки посмотреть (так было 3 года назад, как сейчас – не знаю). Плагин рендерит картинки в edit моде обсидиана;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Vinzent03/find-unlinked-files&quot; target=&quot;_blank&quot;&gt;Find orphaned files&lt;/a&gt;. Пользуюсь редко, но пару раз в год верифицирую заметки на наличие проблем в ссылках;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;как-использую-заметки-для-создания-контента&quot;&gt;Как использую заметки для создания контента&lt;/h3&gt;

&lt;p&gt;В самом начале выбираю тему для контента. Если это рабочий документ, то повезло. Но если это выступление, пост или курс, то тут начинаются проблемы. &lt;/p&gt;

&lt;p&gt;Знаю, что есть люди, которым придумывать темы легко, но это не мой случай. Либо выбираю тему, которая самому интересна или которой занимаюсь в текущий момент, либо прошу других придумать темы. Так, могу написать организаторам конференции с вопросом «о чем стоит рассказать», либо собрать проблемы в компании, либо посмотреть вопросы из канала (&lt;a href=&quot;https://goo.gl/forms/iUd1Gufq6WnTsaO62&quot; target=&quot;_blank&quot;&gt;вопрос можно написать тут&lt;/a&gt;). Иногда помогает вести список тем, с которыми хочется разобраться, но лично такой список понадобился 1 раз и после был удален. Пробовал выбирать темы по рандомному открытию заметок, но не помогло.&lt;/p&gt;

&lt;p&gt;Если нет строгого дедлайна, могу сделать заметку по теме и в свободное время накидывать туда материал для изучения или ссылки, которые хочу использовать для ресерча в будущем. Тогда заметка становится «ресерч заметкой».&lt;/p&gt;

&lt;p&gt;После выбора темы, делаю пустую заметку (или canvas) с которой буду работать. Заметку использую когда контент небольшой (например, ответы на вопросы или ADR), canvas – когда тема большая (чаще курсы). В этот момент начинается этап наполнения заметки материалом: собираю заметки которые нахожу в базе знаний, если чего-то нет или о теме ничего не знаю – иду исследовать и попутно добавляю информацию в обсидиан.&lt;/p&gt;

&lt;p&gt;Собственные заметки ищу любым доступным способом: прямой поиск по словам, теги, метатеги. Иногда помню, что есть нужная заметка в определенном месте. А для каждой заметки просматриваю связанные записи и каждую подходящую добавляю в «месиво» информации.&lt;/p&gt;

&lt;p&gt;После начинаю разбирать полученное «месиво» и делаю первую версию &lt;a href=&quot;https://www.eapfoundation.com/writing/process/outline/&quot; target=&quot;_blank&quot;&gt;аутлайна&lt;/a&gt; из заметок, т.е. примерный план того, о чем будет контент. При этом, если заметки нужной нет по теме, то могу словами написать, чего не хватает. Это выглядит как список или план, который в будущем станет table of context. При этом, аутлайн может еще тысячу раз поменяться. Например, первоначальный аутлайн для этого ответа выглядел следующим образом (сравните с тем, что по итогу вышло):&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Зачем мне нужна база знаний нужна
## Целепологание
## Свалка для всего vs только специфичная информация
## Зачем база знаний для генерации контента
## Что делать, если цели другие
# Как веду базу знаний
## базовые принципы
## Советы
## Трейдоффы с которыми живу
## О каких подходах рассказать
## Про датавью
## Про темплейты
# Как использую базу знаний для создания контента
# Выводы
# Ссылки
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Если контент большой, отдельная заметка с темами превратится в кашу, которую будет сложно поддерживать. В этот момент выручает whiteboard в виде canvas.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-09-14-how-i-use-obsidian-and-why/aa-course-outline.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример аутлайна для &lt;a href=&quot;https://tough-dev.school/architecture&quot;&gt;новой версии АА курса&lt;/a&gt;. После аутлайн дополняется заметками из базы знаний. А после уже пишется контент&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;После того, как появилась черновой аутлайн – начинаю писать. Для этого копирую текст из связанных заметок, что бы получился черновик.После этого &lt;a href=&quot;http://maximilyahov.ru/blog/all/meatballs/&quot; target=&quot;_blank&quot;&gt;наполняю «мясом» текст&lt;/a&gt;, редактирую, вычитываю и переписываю. В случае с выступлениями, делаю аналогичную работу, только презентация основывается на аутлайне, который сделал ранее.&lt;/p&gt;

&lt;h3 id=&quot;риски-и-проблемы-с-которыми-живу&quot;&gt;Риски и проблемы с которыми живу&lt;/h3&gt;

&lt;p&gt;Может показать, что обсидиан решает любые проблемы и лучше ничего нет для ресерча и поиска связей. На деле проблем хватает:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Чем выше каплинг (а это цель), тем сложнее работать с заметками, т.е. добавлять и связывать сложнее становится, на это тратится время. «Голый» обсидиан не помогает. Единственное, жду момента, когда llm модели научаться нормально работать с обсидианом для поиска потенциальных связей между заметками. Благодаря чему, надеюсь, сил на добавление заметок будет уходить меньше;&lt;/li&gt;
  &lt;li&gt;Приходится тратить время на саму базу знаний и ситуации в духе «добавлю заметку, может потом понадобиться». По ощущениям выходит около 95% работы с базой знаний и 5% написания контента. Я смирился, но задумываюсь о цене такого подхода;&lt;/li&gt;
  &lt;li&gt;Приходится регулярно убирать техдолг: проставлять ссылки, проставлять теги, добавлять что-то, убирать лишнее, разбирать заметки состоящие только из одной ссылки и так далее. Без этого база знаний начинает «протухать». С другой стороны, работа над тех долгом сжирает кучу сил и времени, что приводит к фрустрации;&lt;/li&gt;
  &lt;li&gt;Переезжать между инструментами – боль. Т.е. либо делаете заметки, либо постоянно пробуете новые инструменты. Аналогично с подходами. В текущем виде мне сложно метатеги проставить для связей, а переехать на зетелькастен или другой «фреймворк» – непосильная задача;&lt;/li&gt;
  &lt;li&gt;Электрон – боль. Global graph лагает и иногда возникают странности в поведении. Vim keybindings работают криво, не все цветовые схемы корректно работают с плагинами. Зато любой элемент можно в девтулзах подправить;&lt;/li&gt;
  &lt;li&gt;Работа с мобильных устройств вызывает только апатию. Изначально думал, что с телефона или планшета будет комфортно работать с заметками вне дома. Но чуда не произошло, проще быстро написать идею в saved messages в тг, а потом обработать с компа. Читать книги и делать заметки с айпада без клавиатуры смысла нет, но тогда возникает вопрос, почему не взять ноутбук;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tips--tricks&quot;&gt;Tips &amp;amp; tricks&lt;/h3&gt;

&lt;h4 id=&quot;учеба-и-работа-с-базой-знаний&quot;&gt;Учеба и работа с базой знаний&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Верифицируйте, что заметки решают проблему. Т.е. если решили делать контент и для этого занимаетесь базой – делайте контент регулярно, а не раз в пять лет. Например, ответы на вопросы – регулярная проверка того, что текущей базой можно пользоваться;&lt;/li&gt;
  &lt;li&gt;Учиться лучше каждый день и регулярно, чем 1 день в неделю по 3.5 часов. Если времени нет, могу сам себе позволить абзац книги прочитать или одну статью. Так появляется привычка и нет «раскачки»;&lt;/li&gt;
  &lt;li&gt;Забейте на размер заметок. Лучше написать лонгрид с 10 идеями, чем два часа думать как разбить заметки на атомарные идеи. В крайнем случае, лонгрид можно будет «отрефакторить» после. Иногда помогает сделать конспект статьи в одной заметке, а потом раскидать на атомарные заметки. С пейперами так получается продуктивнее;&lt;/li&gt;
  &lt;li&gt;Совет, который  игнорирую. Отдых важен, если каждый день учиться, через два месяца тошнить будет. Поэтому, 1 день в неделю лучше отдохнуть, иначе можно быстро выгореть;&lt;/li&gt;
  &lt;li&gt;Указывайте референсы. Т.е. откуда взяли заметку и в каких условиях (кто посоветовал, как нашли и так далее). Даже если это обсуждение в чате, либо ссылка на вики. Потом проще перечитать будет, если надо будет дополнить информацию, плюс можно референс в конце контента делать, не тратя время на поиски;&lt;/li&gt;
  &lt;li&gt;Журналы, как заметки во времени, полезная штука, но польза появляется только в будущем. Например, когда хочется понять по какой причине появилась запись. Благодаря этому сохраняется контекст, в котором появилась мысль, что идейно близко к ADR;&lt;/li&gt;
  &lt;li&gt;Личное предпочтение. Лучше явная связь через линк, чем не явная по датавью. Связанно это с тем, что явную связь проще найти в тексте поиском, плюс нет гарантий, что завтра датавью будет работать так же как и сегодня;&lt;/li&gt;
  &lt;li&gt;Иногда хочется сохранить ссылку на будущее, что бы прочитать и для этого делается «пустая» заметка только с ссылкой. Спустя время такие заметки начинают только мешать ибо смысла не имеют. Советую добавлять контекст, для которого не придется читать текст: почему ссылка понравилась, что стоит прочитать, где планируете воспользоваться информацией и почему считаете, что информация из ссылки полезна;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;обсидиан&quot;&gt;Обсидиан&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Переименовывайте картинки так, чтобы в названии было объяснение к чему картинка. Позволит быстро понять что к чему и не запутаетесь, если в папке много картинок. Плюс по ним будет работать поиск;&lt;/li&gt;
  &lt;li&gt;Можно добавлять pdf файл с книгой/пейпером к MoC заметке с названием книги/пейпера. Благодаря этому не придется каждый раз искать книгу, что бы проверить оригинал;&lt;/li&gt;
  &lt;li&gt;Global graph может показаться бессмысленным, когда заметок много. Но если использовать граф для контроля качества базы знаний, можно экономить время;&lt;/li&gt;
  &lt;li&gt;Выделяйте время на рефакторинг заметок. Если забить, то можно придти к тому, что заметки не имеют никакого смысла. Под рефакторингом подразумеваю: заполнение пустых заметок, проставление тегов, метатегов и прочего, чистка дублей или не нужных заметок и так далее;&lt;/li&gt;
  &lt;li&gt;Плагин на превью картинок мастхев. Без него замучаетесь переключаться между edit/view;&lt;/li&gt;
  &lt;li&gt;Вместо того, чтобы сразу ставить 100+ плагинов, попробуйте воспользоваться «голым» приложением, после чего ставить плагины под возникающие проблемы (если собираете комбайн – можно проигнорировать). Так, dataview поставил спустя 3 года после начала использования обсидиана;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;выводы&quot;&gt;Выводы&lt;/h2&gt;

&lt;p&gt;Три вывода, которые хочется донести:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Выбирайте инструмент под задачу, а не задачу под инструмент. Для этого придется честно ответить самому себе что за проблема появилась и стоит ли на нее тратить силы. После, стоит выбрать стиль, которым задача будет решена, а потом уже думать об инструменте;&lt;/li&gt;
  &lt;li&gt;Если нужно искать связи - обсидиан рабочий инструмент. Не идеальный, с проблемами и заскоками, но пользоваться можно. Если думаете что выбрать из 2+ инструментов – попробуйте каждый и только после выбирайте. Если привыкли писать от руки – посмотрите на метод Уильяма Росса Эшби, который &lt;a href=&quot;https://fedorovpishet.ru/sistema-zapisej-uilyama-rossa-eshbi-bloknoty-na-maksimalkah/&quot; target=&quot;_blank&quot;&gt;заметки вел в виде пачки нумерованных блокнотов с кросс ссылками&lt;/a&gt;;&lt;/li&gt;
  &lt;li&gt;Используйте обсидиан как хотите, тут нет гайдов и «стандартов» (ну или я не видел). Можете попробовать описанный в ответе вариант, можете взять за основу чужой. Тут важнее не структуру и подходы настраивать и менять, а получать выгоду от заметок решая проблемы из первого вывода, при этом используя инструмент так, как удобнее;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ведение заметок - труд и серьезная инвестиция. При этом, инструмент не влияет на качество заметок и качество использования базы знаний, поэтому выбирайте то, что ближе или нравится внешне больше. Тратить силы на базу знаний или нет – решать вам, но если бы не создание контента, я бы лучше тратил время на путешествия;&lt;/p&gt;

&lt;h2 id=&quot;ссылки&quot;&gt;Ссылки&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;[ru] Специфический &lt;a href=&quot;https://habr.com/ru/users/flowing_abyss/publications/articles/&quot; target=&quot;_blank&quot;&gt;блог на хабре&lt;/a&gt;, где автор дотошно расписывает темы связанные с продуктивностью. Читаю каждый пост, но советую изучать идеи, а не описанные реализации&lt;/li&gt;
  &lt;li&gt;[ru] Если интересуетесь темой заметок, &lt;a href=&quot;https://qnnnp.substack.com&quot; target=&quot;_blank&quot;&gt;знаете блог&lt;/a&gt;. Если нет – автор занимается занимается изучением принципов и приёмов учебной и научной деятельности. Тематика вращается вокруг систем управления знаниями. Советую две статьи об инструментах для заметок: &lt;a href=&quot;https://qnnnp.substack.com/p/pkm&quot; target=&quot;_blank&quot;&gt;первая&lt;/a&gt; и &lt;a href=&quot;https://qnnnp.substack.com/p/f20&quot; target=&quot;_blank&quot;&gt;вторая&lt;/a&gt;;&lt;/li&gt;
  &lt;li&gt;[ru] Базовый &lt;a href=&quot;https://vas3k.club/post/25661/&quot; target=&quot;_blank&quot;&gt;гайд по logseq&lt;/a&gt;, который объяснит идеи и концепции приложения. Только для тех, кто решит попробовать приложение;&lt;/li&gt;
  &lt;li&gt;[ru] Тема журналов продолжает &lt;a href=&quot;https://ailev.livejournal.com/1513051.html&quot; target=&quot;_blank&quot;&gt;подход «мышление письмом»&lt;/a&gt; и помогает в ситуации, когда понимаете, что застряли. Т.е. выгружаете мысли из головы в текст во временном порядке. Потом к чему-то придете, но записи остануться и к ним можно будет вернуться в будущем. Например подкорректировать и сделать из этого пост, либо ADR;&lt;/li&gt;
  &lt;li&gt;[ru] Если захотите с zettelkasten разобраться – &lt;a href=&quot;https://fedorovpishet.ru/all-about-zettel/&quot; target=&quot;_blank&quot;&gt;советую статью в которой собраны ресурсы по теме&lt;/a&gt;. Плюс &lt;a href=&quot;https://vas3k.club/post/3040/&quot; target=&quot;_blank&quot;&gt;гайд из vas3k.club&lt;/a&gt; (советую посмотреть связанные посты);&lt;/li&gt;
  &lt;li&gt;[ru] Если хотите посмотреть процесс работы с заметками, &lt;a href=&quot;https://t.me/niceandeasyme/3275&quot; target=&quot;_blank&quot;&gt;Тимур в своем тг канале иногда выкладывает записи того, как работает над заметками&lt;/a&gt;;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Как уменьшить размер события в асинхронных коммуникациях</title>
   <link href="http://pepegramming.site/questions/make-events-small/"/>
   <updated>2024-08-30T00:00:00+03:00</updated>
   <id>http://pepegramming.site/questions/make-events-small</id>
   <content type="html">&lt;h2 id=&quot;вопрос&quot;&gt;Вопрос&lt;/h2&gt;

&lt;div class=&quot;question-text&quot;&gt;
  &lt;blockquote&gt;
    &lt;p&gt;Привет!&lt;/p&gt;

    &lt;p&gt;Вопрос: что делать если требуется чтоб в message bus были максимально короткие сообщения?&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/div&gt;

&lt;p&gt;Так как вопрос абстрактный, то можно выделить две ситуации, в которой необходимо «короткое» событие:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хочу короткие сообщения, потому что так «принято»;&lt;/li&gt;
  &lt;li&gt;Есть проблема с брокером/трафиком/деньгами, и нужно решение для уменьшения размера payload в событии. При этом, концептуально событие корректно;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Давайте рассмотрим каждый из вариантов.&lt;/p&gt;

&lt;details class=&quot;collapse_block&quot;&gt;
  &lt;summary class=&quot;collapse_block__title&quot;&gt;Заумь: душный кусок, который задает понятийный аппарат и который можно пропустить&lt;/summary&gt;

  &lt;div class=&quot;collapse_block__content&quot;&gt;

    &lt;p&gt;К сожалению, без духоты, в виде зауми, могут появиться додумки или недопонимания, поэтому лучше договориться на берегу.&lt;/p&gt;

    &lt;p&gt;Дальше по тексту будут использоваться три термина связанных с событиями, поэтому давайте договоримся на берегу, что подразумевается под каждым из терминов.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Событие (event)&lt;/strong&gt; – факт того, что произошло в прошлом. Всегда именуется глаголом в прошедшем времени, причем безвозвратным. Например, если что-то покупается в интернет магазине, то событие будет “заказ оформлен”;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Команда (command)&lt;/strong&gt; – действие которое кто-то должен выполнить, обозначаются глаголом в настоящем времени. Если вернуться к примеру с заказом, то “оформить заказ”, как действие, можно отправить асинхронно. Для команд, текст ниже также валиден;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Payload&lt;/strong&gt; – кроме названия того, что произошло, нужен и контекст, который добавляет конкретной информации, что именно произошло. Т.е. если мы “оформили заказ”, то желательно знать что это за заказ (хотя бы его id), кто это сделал, когда, какие товары были в заказе, какая стоимость (общая и каждого товара) и так далее. Все это является контекстом события, который находится в payload-е события. Для команды аналогично;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Событие в общем виде можно представить так

event ItemAddedToCart { # ItemAddedToCart - название события
  id: int, # тут описываем payload
  # ... 
}

# Команда выглядит так

command AddItemToCart { # AddItemToCart - название команды, которую кто-то выполнит
  id: int, # тут описываем payload
  # ... 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Бизнес событие&lt;/strong&gt; – событие которое говорит о том, что какой-то бизнес процесс завершился с каким-то результатом. Если знакомы с EventStorming – оранжевый стикер с событием будет аналогом. Если знакомы с DDD – domain event близок по смыслу;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Продьюсинг и консьюминг (producing/consuming)&lt;/strong&gt; – терминология из кафки (и аналогов). Producer отправляет события, consumer потребляет. В кролилке любят использовать publisher/subscriber терминологию, что одно и тоже. Но в ответе будет использоваться терминология из кафки;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Брокер (message broker)&lt;/strong&gt; – очередь/распределенный лог/стриминг платформа используемый для передачи событий из A в B;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;Вот об уменьшении payload-а события и поговорим в контексте вопроса.&lt;/p&gt;

  &lt;/div&gt;
&lt;/details&gt;

&lt;h2 id=&quot;хочу-короткие-сообщения-потому-что-так-принято&quot;&gt;Хочу короткие сообщения, потому что так «принято»&lt;/h2&gt;

&lt;p&gt;Первое, с чего надо начинать, когда дело касается размера payload в событии – определиться с двумя концепциями: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state (fact) vs delta (action) events&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;event granularity&lt;/code&gt;. Чаще эти два понятия даются отдельно и не связывают между собой. Но сегодня особый случай – будем рассматривать концепции в связке.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/fine-coarse-state-delta-matrix.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;«Матрица» связи state/delta и event granularity концепций, которую будем использовать дальше&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;state-fact-vs-delta-action-events&quot;&gt;State (fact) vs delta (action) events&lt;/h3&gt;

&lt;p&gt;Существует два подхода к хранению состояния в событиях:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;State (or fact) event – хранит полное состояние агрегата/бизнес события на момент продьюсинга;&lt;/li&gt;
  &lt;li&gt;Delta (or action) event – хранит только изменения которые произошли в событие на момент продьюсинга;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/state-vs-delta-events.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример двух одинаковых событий: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ItemAddedToOrder&lt;/code&gt;. В delta событии показывается только то, что изменилось, в state – указывается весь «снапшот» &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order&lt;/code&gt; агрегата&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Дополнение:&lt;/strong&gt; считается, что событие не может быть наполовину state и на половину delta. Но в реальности встречал ситуации, когда передавался полный агрегат + изменения только вложенных данных. Поэтому считаю значения не бинарными в этом ответе.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;плюсы-и-минусы-state-events&quot;&gt;Плюсы и минусы state events&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Плюсы&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Так как не надо считать состояние из кучи delta событий (которые могут быть разбросаны по разным очередям/топикам), то можно пропустить прошлые события, чтобы получить текущий слепок состояния;&lt;/li&gt;
  &lt;li&gt;Если меняется схема событий – проще исправить одно state событие, чем пачку delta;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Минусы&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cобытие может оказаться слишком большим (наш случай);&lt;/li&gt;
  &lt;li&gt;Не понятно что изменилось, если ордеринг событий нарушится. Из-за этого можно будет обновить новые данные на старые и получить не консистентный стейт;&lt;/li&gt;
  &lt;li&gt;Если изменения частые, может быть действительно слишком много лишних данных об одном и том же;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;плюсы-и-минусы-delta-events&quot;&gt;Плюсы и минусы delta events&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Плюсы&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;События будут меньше по размеру, в отличии от state событий, так как там не будет ничего лишнего;&lt;/li&gt;
  &lt;li&gt;Если изменения частые – можно выиграть в трафике и количестве данных, которые храняться на стороне консьюмера;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Минусы&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Исправление проблем со схемой событий может стать еще большей проблемой. Частный случай – решение проблемы GDPR и другие “удаления” данных могут быть проблемными;&lt;/li&gt;
  &lt;li&gt;Придется следить за event ordering;&lt;/li&gt;
  &lt;li&gt;Если для обработки события нужен полный агрегат (все данные агрегата) – придется хранить локальное состояние агрегата;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;event-granularity&quot;&gt;Event granularity&lt;/h3&gt;

&lt;p&gt;Вторая концепция раскрывает идею state/delta событий, но в плоскости полезности и полноты события. Для этого вводятся понятия coarse и  fine событий.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/fine-vs-coarse-events.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример двух одинаковых событий с добавлением товара в корзину. В coarse событии слишком много не понятно зачем относящихся данных, fine событие слишком специфичное и мелкое&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;coarse-событие&quot;&gt;Coarse событие&lt;/h4&gt;

&lt;p&gt;Такие события большие и общие (т.е. обо всем сразу), содержат дженерик нейминг и кучу данных не обязательных (и местами не нужных) для работы консьюмера.&lt;/p&gt;

&lt;p&gt;Иногда встречаются ситуации, когда событие так себе называется и контекст того, что произошло, можно понять только через чтение данных. Из-за этого бизнес логика просачивается на сторону консьюмера.&lt;/p&gt;

&lt;h4 id=&quot;fine-событие&quot;&gt;Fine событие&lt;/h4&gt;

&lt;p&gt;Такие события слишком мелкие и специфичные. Чаще нормально называются, но слишком в них мало информации для работы бизнес логики&lt;/p&gt;

&lt;p&gt;Считается, что такое событие не юзабельно без других событий, следовательно приходится их комбинировать и это может привести к проблемам, что потенциально может привести к проблемам с event ordering.&lt;/p&gt;

&lt;h3 id=&quot;собираем-концепции-вместе&quot;&gt;Собираем концепции вместе&lt;/h3&gt;

&lt;p&gt;Если соединить две концепции, то появляется пространство выбора, в котором можно определить как оптимальный размер события, так то, на сколько общим (generic) событие будет в системе.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/fine-coarse-state-delta-matrix-event-size.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Примерное описание того, какой размер события ожидать в каждом из мест «матрицы». Цветом показал ожидаемый размер события. Fine delta событие будет самым мелким, поэтому стикер зеленый&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;В таком ключе, вся работа над размером событий сводится к тому, что бы сначала сначала определяется какой вид события нужен: state или delta. После чего определяем проблему гранулярности события и решаем найденную проблему.&lt;/p&gt;

&lt;p&gt;Благодаря этому можно выбирать размер события. Что приводит к тому, что каждое событие будет оптимально по размеру и контексту под заданные требования и ограничения. Благодаря чему можно отказаться от «моды»/советов на delta события без данных, просто потому что в компании Х используется такой подход по дефолту.&lt;/p&gt;

&lt;p&gt;Но у такого подхода присутствует и минус: придется думать над каждым событием, что может привести к разногласиям в команде, либо же к проблемам, если разработчики не скиловые. Можно решить что хватит delta/fine события, а потом окажется, что не попали в требования. Из-за чего придется заниматься дорогой и сложной эволюцией схемы события.&lt;/p&gt;

&lt;h2 id=&quot;событие-корректное-по-размеру-но-слишком-большое-для-системы&quot;&gt;Событие корректное по размеру, но слишком большое для системы&lt;/h2&gt;

&lt;p&gt;К сожалению, использование концепции &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state (fact) vs delta (action) events&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;event granularity&lt;/code&gt; не спасает в 100% случаев от проблем с размером события. Возможна ситуация, когда необходим state event, который при этом должен быть coarse. Т.е. вообще никак не выбрать ничего другого. А размер события должен быть максимально небольшим ибо специфика брокера/нет денег на инфру/etc.&lt;/p&gt;

&lt;p&gt;Чтобы решить эту проблему перечислю точечные подходы, которые разбиваются на две группы:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;уменьшаем payload сообщения с помощью паттернов *;&lt;/li&gt;
  &lt;li&gt;увеличиваем допустимые размеры сообщения в брокере;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;* Для некоторых вариантов придется подумать о консистентности данных в payload, ибо не все варианты работают со strong consistency.&lt;/p&gt;

&lt;h3 id=&quot;уменьшение-размера-сообщений-без-потери-гранулярности&quot;&gt;Уменьшение размера сообщений без потери гранулярности&lt;/h3&gt;

&lt;h4 id=&quot;убрать-лишние-данные-в-ручную&quot;&gt;Убрать лишние данные в ручную&lt;/h4&gt;

&lt;p&gt;Очевидное решение, пересекающее с концепциями из первой части ответа: берем событие, смотрим какие данные нужны в каждом консьюмере события, после чего, ковыряясь в payload, выкидываем лишние данные. Т.е. делаем событие больше fine чем coarse:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/less-coarse-event.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Может оказаться, что событие надо сделать не таким coarse, следовательно, по «матрице» оно опустится чуть ниже&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;event-notification&quot;&gt;Event notification&lt;/h4&gt;

&lt;p&gt;Если получали смс «осторожно, будет шторм», а потом шли смотреть где шторм, когда и кого зацепит – значит знакомы с паттерном.&lt;/p&gt;

&lt;p&gt;По сути, паттерн частный случай delta события. Идея такая: отправляем событие, что что-то произошло, но контекст просим получить с помощью синхронного вызова. Подход нужен в двух случаях: когда необходимо передать большое количество данных, либо когда нужно максимально консистеные данные получить в событии. В контексте ответа на вопрос интересен первый случай.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/event-notification-example.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример реализации event notification паттерна. Сначала отправляется событие с ссылкой на ресурс. После этого, консьюмер, делает запрос за данными и получает контекст&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Подобным образом можно передавать аттачменты в событиях: кидаем файл в s3, получаем ссылку, а после ссылку передаем в событии, благодаря чему можно не грузить гигабайты видео и картинок в брокер.&lt;/p&gt;

&lt;p&gt;Из минусов подхода – появляется дополнительный каплинг за счет синхронной связи, что влияет на reliability, availability и другие характеристики.&lt;/p&gt;

&lt;h4 id=&quot;воспользоваться-бинарной-сериализацией&quot;&gt;Воспользоваться бинарной сериализацией&lt;/h4&gt;

&lt;p&gt;Если удалять из схемы payload нечего, а использовать синхронный вызов не позволяют характеристики, можно ужать само сообщение. Для этого берем бинарный серелизатор и упаковываем payload. По итогу получаем ужатую строку, которая меньше на 25-50% чем оригинальный payload (больше данных - больше ужимает).&lt;/p&gt;

&lt;p&gt;Из минусов - без десериализации человек такую бинарную строку быстро не прочитает, в отличии от human-readable форматов (json, xml, etc). Еще из минусов – придется думать как консьюмер поймет какую схему использовать для десерелизации (либо 1 событие на топик/очередь, либо название события в headers кафки прокидывать).&lt;/p&gt;

&lt;p&gt;Популярные серелизаторы: &lt;a href=&quot;https://github.com/protocolbuffers/protobuf&quot; target=&quot;_blank&quot;&gt;protobuf&lt;/a&gt; (в grpc используется), &lt;a href=&quot;https://github.com/apache/avro&quot; target=&quot;_blank&quot;&gt;avro&lt;/a&gt;, &lt;a href=&quot;https://github.com/apache/thrift&quot; target=&quot;_blank&quot;&gt;apache thrift&lt;/a&gt;. В некоторых языках реализованы решения из коробки, &lt;a href=&quot;https://www.erlang.org/doc/apps/erts/erl_ext_dist.html&quot; target=&quot;_blank&quot;&gt;например в erlang&lt;/a&gt; (использовать только тем, кто контрибьютил в пакет).&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/avro-vs-protobuf-size-comparison.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Разработчик решил проверить, что будет если &lt;a href=&quot;https://cristian-matei-toader.medium.com/compressing-a-year-of-reddit-with-apache-avro-and-google-protobuf-c9e40cf90444&quot;&gt;ужать датасет kaggle 2015 года от reddit&lt;/a&gt;. Скриншот выше – итоговый результат, который мало говорит о том, что лучше, но показывающий как можно уменьшить размер события&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;message-chunking&quot;&gt;Message chunking&lt;/h4&gt;

&lt;p&gt;Если описанные выше варианты не подошли, можно воспользоваться идеей передачи больших данных в синхронных вызовах: поделить сообщение на чанки меньшего размера и вместо одного жирного события получить N мелких.&lt;/p&gt;

&lt;p&gt;Из минусов – проблемы с strong consistency для payload события, плюс проблемы упаковки чанков в событие на стороне консьюмера.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/message-chunking-example.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример из вики apache pulsar. Идея в том, что событие разбивается на чанки (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M1-C1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M1-C2&lt;/code&gt;), после чего консьюмер собирает из чанков исходное событие&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;передавать-часть-данных-в-других-событиях&quot;&gt;Передавать часть данных в других событиях&lt;/h4&gt;

&lt;p&gt;На первый взгляд решение может показаться идентичным message chunking, но концепция чуть отличается.&lt;/p&gt;

&lt;p&gt;Идея в том, что можно разделить связи между элементами в плоскости &lt;a href=&quot;https://en.wikipedia.org/wiki/Form,_fit_and_function&quot; target=&quot;_blank&quot;&gt;system function и system form&lt;/a&gt;. Благодаря чему появится два вида связности: по данным (это form) и на уровне поведения (function). Это приводит к идее, что если присутствует событие, которое говорит о поведении, для обработки которого нужны данные, эти данные можно передать через system form связь.&lt;/p&gt;

&lt;p&gt;Для определения system form можно воспользоваться &lt;a href=&quot;https://pepegramming.site/questions/data-model/&quot; target=&quot;_blank&quot;&gt;концептуальной data model&lt;/a&gt;, а для определения system function – любой моделью, описывающей поведение, например EventStorming.&lt;/p&gt;

&lt;h3 id=&quot;тюнинг-брокера&quot;&gt;Тюнинг брокера&lt;/h3&gt;

&lt;p&gt;Сразу скажу – не эксперт в инфраструктуре, поэтому накину идей. Лучше идите к DevOps инженерам или админам (сам так делаю).&lt;/p&gt;

&lt;p&gt;Как могу судить, тут два подхода: либо крутить конфиг брокера, либо использовать специфичные инструменты реализованные в брокере:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Если возникла проблема, что событие не влезает в брокер, то можно накрутить конфиг &lt;a href=&quot;https://stackoverflow.com/questions/21020347/how-can-i-send-large-messages-with-kafka-over-15mb&quot; target=&quot;_blank&quot;&gt;кафки&lt;/a&gt; или &lt;a href=&quot;https://www.cloudamqp.com/blog/what-is-the-message-size-limit-in-rabbitmq.html&quot; target=&quot;_blank&quot;&gt;кролика, но тут лимит в 128 мб&lt;/a&gt;. Для других брокеров думаю можно найти аналогичные настройки;&lt;/li&gt;
  &lt;li&gt;Если используете кафку, советую посмотреть в сторону &lt;a href=&quot;https://www.confluent.io/blog/apache-kafka-message-compression/&quot; target=&quot;_blank&quot;&gt;message compression&lt;/a&gt;. Подход сработает для xml, json и прочего, что легко компрессируется и содержит дубли. По сути, аналог серелизации из списка выше;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Знаете еще варианты? Пишите в комментариях к тг посту, соберем список, а я дополню эту часть ответа.&lt;/p&gt;

&lt;h2 id=&quot;выводы&quot;&gt;Выводы&lt;/h2&gt;

&lt;p&gt;Уменьшение объема payload события не тривиальная задача, которую в первую очередь лучше решать через &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state (fact) vs delta (action) events&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;event granularity&lt;/code&gt; концепции. Но даже так, возникают ситуации, когда приходится точечно исправлять ситуацию, с чем помогают как паттерны, так и прямой конфиг брокера (если возможен).&lt;/p&gt;

&lt;p&gt;А чтобы собрать ответ в кучу, сделал decision flow диаграмму, которую сам использую, когда проектирую события, надеюсь поможет.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/event-size-decision-flow.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Флоу выбора решения, который использую, если дело касается размера payload события&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Хотя, в идеале, лучше жить в мире, в котором денег много, а инструменты не ограничивают в размере событий.&lt;/p&gt;

&lt;h2 id=&quot;ссылки&quot;&gt;Ссылки&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;[en]  &lt;a href=&quot;https://barryosull.com/blog/event-granularity-modelling-events-in-event-driven-applications/&quot; target=&quot;_blank&quot;&gt;Статья, которая рассказывает о концепции event granularity с fine и coarse событиями&lt;/a&gt;. При этом, автор объясняет почему появляются те или иные виды событий события;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[en]  &lt;a href=&quot;https://developer.confluent.io/courses/event-design/fact-vs-delta-events/&quot; target=&quot;_blank&quot;&gt;Статья о state и delta событиях&lt;/a&gt;. Текста много, но и объясняется куча нюансов;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;[en]  &lt;a href=&quot;https://www.funnel-labs.io/2022/08/26/data-serialization-apache-avro-vs-google-protobuf/&quot; target=&quot;_blank&quot;&gt;Сравнение avro и protobuf серелизаторов&lt;/a&gt; между собой;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://dataintensive.net&quot; target=&quot;_blank&quot;&gt;4 глава DDIA&lt;/a&gt; посвящена сериализации данных. Если не читали – рекомендую;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[en]  &lt;a href=&quot;https://cristian-matei-toader.medium.com/compressing-a-year-of-reddit-with-apache-avro-and-google-protobuf-c9e40cf90444&quot; target=&quot;_blank&quot;&gt;Статья, в которой автор вдохновился DDIA и решил ужать датасет реддита&lt;/a&gt;, чтобы понять какой сериализатор лучше. Результат проверки найдете картинкой в ответе выше;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[en]  Советы по работе с большими сообщениями, которые описаны в вики apache pulsar. &lt;a href=&quot;https://github.com/apache/pulsar/wiki/PIP-37:-Large-message-size-handling-in-Pulsar#option-2-producer-publish-marker-message-after-publishing-all-chunked-messages&quot; target=&quot;_blank&quot;&gt;Message chunking – один из вариантов решения&lt;/a&gt;;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[ru] Подробнее о разделении коммуникаций на поведение и данные (form, function) можно &lt;a href=&quot;https://f213.notion.site/dfa7f424ed8440d99a21c328cc8c5c65&quot; target=&quot;_blank&quot;&gt;почитать в открытом уроке курса&lt;/a&gt;, по анализу систем, который сделал;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;[en] Автор дает &lt;a href=&quot;https://jcdubs.medium.com/aws-large-payload-pattern-e3e4c57d402d&quot; target=&quot;_blank&quot;&gt;советы тем, кто использует aws инфраструктуру и хочет работать с большими событиями&lt;/a&gt;. Примеры кода на js;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Как слежу за большими проектами</title>
   <link href="http://pepegramming.site/questions/graph-as-a-project-managment-tool/"/>
   <updated>2024-08-16T00:00:00+03:00</updated>
   <id>http://pepegramming.site/questions/graph-as-a-project-managment-tool</id>
   <content type="html">&lt;h2 id=&quot;вопрос&quot;&gt;Вопрос&lt;/h2&gt;

&lt;div class=&quot;question-text&quot;&gt;
  &lt;blockquote&gt;
    &lt;p&gt;Привет!&lt;/p&gt;

    &lt;p&gt;Вопрос: как планируешь и следишь за долгими проектами? Особенно интересно что используешь для долгих проектов, которые дляться от года и больше, потому что в какой-то момент перестаю видеть «лес» за тасками в трекере.&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/div&gt;

&lt;p&gt;Давайте разбираться. Важно: я не менеджер, людьми не управляю. Отчеты по работе и планированием спринтов тоже не занимаюсь. Поэтому буду говорить с позиции solution architect и касаемо только рабочих проектов.&lt;/p&gt;

&lt;p&gt;При этом, описываться будет личный опыт, из-за чего допускаю, что ответ подойдет далеко не всем: кто-то следит за проектами в «джире», кто-то получает результат от менеджеров. Поэтому буду рад если описанный подход либо вдохновит, либо поможет в текущей ситуации.&lt;/p&gt;

&lt;p&gt;И еще одно уточнение: в тексте буду использовать «джира» как обобщенное слово для любого PM инструмента. О jira тоже поговорим.&lt;/p&gt;

&lt;h2 id=&quot;контекст-в-котором-приходится-планировать-работу&quot;&gt;Контекст в котором приходится планировать работу&lt;/h2&gt;

&lt;p&gt;Для начала стоит описать контекст в котором нахожусь как solution architect. С этим поможет первая глава &lt;a href=&quot;https://www.oreilly.com/library/view/solution-architecture-foundations/9781780175676/&quot; target=&quot;_blank&quot;&gt;Solution Architecture Foundations&lt;/a&gt;, в которой описываются активности роли. Из списка хочется выделить три:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;управление доставкой решения, в которое входит роадмап из текущей ситуации в будущее, где проблема решена;&lt;/li&gt;
  &lt;li&gt;Организация процесса, в который входит коммуникации между стейкхолдерами на разные темы;&lt;/li&gt;
  &lt;li&gt;Взаимодействие со стейкхолдерами проекта, в которое входят как получение информации, которая потом шарится будет;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Как можете понять, я не занимаюсь менеджментом разработчиков и людей (да и не хочу). Поэтому мне не надо считать сторипоинты, гадать сколько эпиков влезет в спринт и продавать &lt;a href=&quot;https://community.atlassian.com/t5/App-Central/3-tools-to-analyze-Cycle-and-Lead-Time-in-the-Jira/ba-p/1403775&quot; target=&quot;_blank&quot;&gt;красивые графики по распределению времени работы&lt;/a&gt;. С другой стороны, во время работы необходимо понимать в каком состоянии находится проект, где затыки, объяснение почему что-то долго происходит и другие вещи, связанные с обсервабилити работы. Что бы было нагляднее, покажу на &lt;a href=&quot;https://en.wikipedia.org/wiki/V-model&quot; target=&quot;_blank&quot;&gt;v-model&lt;/a&gt;, в какие моменты приходится наблюдать за тем, что делают другие.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/v-model-and-personal-managment.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Дизайн, имплементация и верификация – три фазы, на которых приходится «держать руку на пульсе»&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Т.е. задача сводится к трем вещам:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;На этапе дизайна помочь спланировать работу и провалидировать, что план понятен и устраивает каждого стейкхолдера. А также проверить, что план влезает в ресурсы и цена решения будет приемлемой;&lt;/li&gt;
  &lt;li&gt;На этапе имплементации знать в каком состоянии находится проект и какие проблемы появляются. Плюс знать когда приступать к работе над другими частями системы (если требуется);&lt;/li&gt;
  &lt;li&gt;На этапе верификации нужно проверить, что система будет провалидирована перед тем, как оказаться в проде;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;По итогу, нужен инструмент который решает следующие проблемы:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Помогает в быстром прототипировании этапов работы и валидации этих этапов с каждым из стейкхолдеров проекта (бизнесом и разработчиками);&lt;/li&gt;
  &lt;li&gt;Инструмент должен работать для разных команд/отделов. Т.е. встречаются проекты, которые затрагивают от двух команд из разных отделов и необходимо синхронизировать последовательность работ между ними;&lt;/li&gt;
  &lt;li&gt;Важно как можно быстрее понять в каком состоянии проект на выбранный момент времени, или как быстро происходит требуемая эволюция. Т.е. в идеале, нужен инструмент, который позволит работать с «концептуальной» моделью работы над проектом (о концептуальной/логической/технической модели можно прочитать &lt;a href=&quot;https://pepegramming.site/questions/data-model/&quot; target=&quot;_blank&quot;&gt;в прошлом ответе&lt;/a&gt;);&lt;/li&gt;
  &lt;li&gt;Так как ко мне могут прийти и спросить либо почему так долго выполняются работы, либо просто спросить что происходит – нужен артефакт для стейкхолдеров, который покажу и от меня отстанут;&lt;/li&gt;
  &lt;li&gt;Решение должно быть кросс-платформенное. Связано со спецификой работы, так как за последние четыре года использовались следующие инструменты: бейскамп, джира, редмайн, асана, миро (не спрашивайте), пяток штук для рисования ганта, гитхаб доски, трелло и другие. Если инструмент окажется вендорлоком - я не смогу решение протащить в другой проект;&lt;/li&gt;
  &lt;li&gt;Инструмент должен хранить задачи, которые вроде как надо бы сделать, но пока не понятно как, когда и нужно ли это вообще;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Дополнительные пожелания:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Чем меньше элементов и информации, тем лучше. Т.е. сроки, таймлайны и прочее хотелось бы убрать. Этим пусть занимаются тимлиды с командами;&lt;/li&gt;
  &lt;li&gt;Хочется иметь инструмент для собственной рефлексии:
  - Понимать на сколько изначальные планы отличаются от того, что получилось в конце эволюции;
  - Нужна ретроспектива, что бы быстро понимать как долго делаются задачи и замечать проблемы. Плюс понимать как сильно ошибался в начале и в конце работы (видеть как много добавилось нового во время работы)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;почему-project-management-tools-не-сработают&quot;&gt;Почему project management tools не сработают&lt;/h3&gt;

&lt;p&gt;Может показаться, что под требования подойдет любой продукт для project planning/management. На деле, подобные инструменты только усложняют работу и связано это с тем, что списки задач не работают для высокоуровневого планирования.&lt;/p&gt;

&lt;p&gt;Проблема тут в том, что задачи редко когда связаны последовательно между собой. В качестве примера можно привести «базовую» задачу по выносу кода из монолита в новый сервис. Если сильно не упарываться, то список шагов можно представить как такую последовательность: &lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Сделать новый сервис с копией логики существующего модуля монолита

1. поднять новую базу данных
2. поднять болванку с пустым сервисом
3. настроить деплоймент
4. настроить observability (метрики, логи, etc)
5. настроить репликацию данных из монолита в новую базу данных
6. проверить, что данные валидны и соответствуют реальности
7. реализовать бизнес логику в сервисе
8. проверить, что бизнес логика работает корректно с данными
9. перевести трафик с монолита на новый сервис
10. проверить что итоговое решение работает корректно
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Вроде кажется, что работа последовательна и тут нечего параллелить, достаточно сделать проекты под каждый шаг и фигачить пару месяцев.  Но если представить шаги как «граф», то оказывается, что есть как минимум три трека, в которых задачи могут быть распараллелены, а сам процесс не так линеен, как кажется на первый взгляд&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-service-extraction-final.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Тот же список по выносу логики из монолита, который теперь выглядит как граф, а не последовательные работы&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;В тех инстурментах, что я знаю или использовал (jira, asana, basecamp, clubhouse, redmine, любая kanban доска, etc) нельзя быстро понять связь между задачами. Т.е. настроить и посмотреть связанные задачи можно, но в голове придется рисовать картинку выше, что отнимает время и силы. А в больших проектах, где задействуются команды из разных отделов, подобные действия могут превратиться в дни анализа. Хотя не исключаю, что я не преисполнился мудростью и плохо знаю инструменты, так как не менеджер.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/jira-go-brrr.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Подозреваю, что прошаренные менеджеры как-то так воспринимают этот текст&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;мой-подход&quot;&gt;Мой подход&lt;/h2&gt;

&lt;p&gt;В 2019 году, пока работал в toptal, попробовал схему с графом, которая прижилась и которую использую до сих пор. Идейно подход напоминает &lt;a href=&quot;https://en.wikipedia.org/wiki/Directed_acyclic_graph&quot; target=&quot;_blank&quot;&gt;DAG&lt;/a&gt;, который используется как визуализатор задач в пайплайнах CI/CD или ETL. Единственное отличие, граф рисую руками, вместо использования &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;as a code&lt;/code&gt; подхода.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/airflow-dag-visualizator.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Airflow DAG visualizator, который «рисует» шаги data flow в виде графа, где визуально понятно какая задача за какой вызывается и какой статус у каждой задачи&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Главный плюс подхода – работает в любом инструменте. Я чаще использую lucidchart, но можно взять draw.io или аналоги, возможно даже diagram as code подойдет (не пробовал). Главное, чтобы выполнялись следующие условия:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Можно рисовать квадраты разных цветов;&lt;/li&gt;
  &lt;li&gt;Есть возможность связывать стрелками квадраты между собой;&lt;/li&gt;
  &lt;li&gt;Можно добавлять отдельный элемент для комментариев (в идеале стикер);&lt;/li&gt;
  &lt;li&gt;Наличие отдельных вкладок для версионирования (об этом дальше);&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Сам процесс работы с графом состоит из трех шагов:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Планирование;&lt;/li&gt;
  &lt;li&gt;Наблюдение;&lt;/li&gt;
  &lt;li&gt;«Рефлексия»;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Давайте, на примере выноса кода в отдельный сервис, пройдем по каждому из шагов&lt;/p&gt;

&lt;h3 id=&quot;шаг-1-планирование&quot;&gt;Шаг 1: планирование&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;Предупреждаю: скорее всего сам план будет не корректен, но у меня цель идею показать, а не «правильно» спланировать работу.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Первым делом придется понять что за задачи нужно выполнить. В примере выносом кода в отдельный сервис можно сразу сказать три задачи которые необходимо выполнить:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Поднять новый и пустой сервис&lt;/li&gt;
  &lt;li&gt;Перенести логику в сервис&lt;/li&gt;
  &lt;li&gt;Перевести трафик с монолита на новый сервис&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В виде графа это будет выглядеть следующим образом:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-step-1-base.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Каждый шаг – отдельная нода графа, связи – показывают что за чем выполнять по плану&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Дальше наступает этап анализа, когда оказывается, что каждый из трех шагов состоит из специфичных действий: поднять новый сервис включает в себя поднятие необходимой базы, инстанса приложения, создания репозитория, настройку CI/CD, observability. При этом, без observability перевод трафика не будет иметь смысл.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-step-1-first-improvements.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Раскрываем «большие» задачи на конкретные шаги, которые необходимо выполнить&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Когда будут +- понятные задачи, советую отдельно подумать о двух вещах: интеграции и валидации.&lt;/p&gt;

&lt;p&gt;Под интеграции попадает все, что связывает два элемента вместе: вызов внешнего API, перенос данных из базы в базу, вызов API внутреннего сервиса, перенос данных из старой схемы в новую схему в рамках одной бд, наполнение данными нового сервиса/новой базы и так далее. Об интеграциях забывают в планировании, но как подсказывает практика, тут больше всего риска провалиться: сорвать срок, получить не консистентность и затянуть с работой. &lt;/p&gt;

&lt;p&gt;А под валидации попадает вся левая часть v-model: валидация адекватности данных, которые перенесли, валидация что решение работает, валидация что сервис правильно раскатался, валидация интеграций и так далее. Также как и в интеграциях, валидации забываются и тут много рисков/проблем, которые чаще выстреливают, чем нет.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-step-1-integration-and-validation.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Белые квадраты – интеграции и валидации о которых забывают, но которые не менее важны, чем написание кода и деплой&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Как сделаете план, важно согласовать шаги с командой. Тут два ключевых стейкхолдера: те, кто будут выполнять работу (чаще разработчики, тестировщики, дизайнеры и так далее) и менеджеры, которые будут выбивать ресурсы под работу. Возможно граф станет еще больше или часть задач изменится, это нормально. Важно, чтобы каждый согласился работать по представленному плану.&lt;/p&gt;
&lt;h4 id=&quot;советы&quot;&gt;Советы&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Есть риск скатиться в дробление задач на супер мелкие куски. Не вижу ничего плохого в этом, особенно если опыта мало. Подобные задачи можно схлопнуть или выкинуть на ревью. Единственное исключение – низкоуровневые технические задачи, которые стоит оставлять только если задачи супер критичные для проекта. Если нет, лучше использовать чеклисты для валидации (например сделать чеклист для изменения схемы бд с шагами и проверками);&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Всегда&lt;/strong&gt; (это важно) думайте о необходимых интеграциях и валидациях, без которых проект не запустится. Помните, что есть разница между сделать и заставить работать без ошибок;&lt;/li&gt;
  &lt;li&gt;Согласование такой же необходимый шаг, как и создание графа. Если придти и с ноги сказать кто, что и как делать будет – велик риск саботажа. Плюс другие люди могут указать о том, что вы забыли добавить или что часть работы можно выкинуть;&lt;/li&gt;
  &lt;li&gt;Один из возможных «smell-ов» по задачам – появление задачи, которая ни с чем не связана. Т.е. у задачи может быть либо входящая, либо исходящая связь (либо две сразу), но полное отсутствие стрелок является знаком, что что-то не так и стоит посмотреть внимательно (исключение – задачи в будущее, которые важно помнить, но непонятно когда и как их делать);&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;шаг-2-наблюдение&quot;&gt;Шаг 2: наблюдение&lt;/h3&gt;

&lt;p&gt;Нудный и в тоже время важный шаг. Каждый спринт встречаемся с исполнителями, проходим по каждой задачи из графа, оставляем комментарии и добавляем новые задачи, если оказалось что они нужны. Плюс отмечаем что было сделано и что в работе на момент ревью. Для этого использую цвета: зеленый – сделали, желтый – в работе, красный – отменили.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/real-example-full-graph.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Реальный граф связанный с рефакторингом сервиса. Комментарии оставляю как стикер, тут нет стандартизации. К сожалению шакально по причине NDA, но идею по картинке понять можно&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Тут важно сохранять прошлую версию графа отдельно. Для этого делаю копию, ставлю текущую дату (версию) и заполняю скопированный граф&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/real-example-graph-versions.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Каждая вкладка – новая версия графа, которая изменяется&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Благодаря такому версионированию, можно ретроспективно посмотреть как долго задачи делаются, что добавилось нового и исследовать процесс выполнения работы.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;https://leonardo.osnova.io/6c44e586-3769-4c22-4270-a326d823ea8c/-/format/mp4#t=0.1&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;В 2020 году, Самат &lt;a href=&quot;https://vc.ru/services/151374-s-pomoshyu-diagramm-mozhno-obyasnit-chto-ugodno-tem-bolee-dlya-etogo-est-klassnye-instrumenty&quot;&gt;написал статью&lt;/a&gt;, где показывал граф выполнения работ (в самом низу), видео как раз из статьи&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Кроме отметок по задачам, использую секцию «Проблемы/вопросы/комментарии», куда добавляю все, о чем говорят исполнители. В будущем секция помогает в анализе и ретро.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/real-example-pros-cons-ideas.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример секции «Проблемы/вопросы/комментарии» из проекта выше. Красное – проблемы, зеленое – комментарии, желтым обозначаю вопросы&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;По итогу, получаем гибкий инструмент, который можно использовать для ответа «в каком статусе проект» и «почему долго делается ХХХ?!».&lt;/p&gt;

&lt;h4 id=&quot;советы-1&quot;&gt;Советы&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Как я уже сказал - наблюдение важный шаг. Но при этом и сложный из-за регулярности и желания пропустить и забить. Советую хотя бы раз попробовать выполнить проект не забивая на этот шаг и после уже решать, подходит подход или нет;&lt;/li&gt;
  &lt;li&gt;Версионирование графа – ключ к успеху, особенно для шага с анализом;&lt;/li&gt;
  &lt;li&gt;Не бойтесь добавлять новые задачи. Невозможно сразу описать план идеально. В моей практике, в итоговой версии графа оказывается на ~40% больше задач, чем в изначальной версии;&lt;/li&gt;
  &lt;li&gt;Секция с проблемами не обязательна, но помогает сохранить контекст на будущее;&lt;/li&gt;
  &lt;li&gt;У каждого стейкхолдера должен быть доступ к графу в любое время. Разработчики смогут быстро посмотреть что делать дальше, а у бизнеса появится обсервабилити над проектом в любой необходимый момент времени;&lt;/li&gt;
  &lt;li&gt;В теории, можно раз в неделю открывать «джиру» и отмечать самому что в работе, а что планируется. Но у такого подхода есть минус – шаги не просматриваются исполнителями и нет контакта, благодаря которому можно поговорить о косяках в планировании или проблемах в реализации;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;шаг-3-рефлексия&quot;&gt;Шаг 3: «рефлексия»&lt;/h3&gt;

&lt;p&gt;Это опциональный пункт. Идея в том, что по завершению проекта, любят устраивать ретро. Если проект длится больше 6 месяцев – шансы вспомнить что было в начале нулевые. Но благодаря графу можно быстро посмотреть как долго делались задачи, выписать какие проблемы возникли (с решениями) и посмотреть на сколько ожидания разошлись с реальной работой.&lt;/p&gt;

&lt;h2 id=&quot;advanced-использование-графа&quot;&gt;Advanced использование графа&lt;/h2&gt;

&lt;p&gt;Чтобы накидать ещё больше пользы в ответ, решил еще добавить секцию связанную с анализом. Тут будут идеи из личного опыта, поэтому не ждите хардскилового менеджмента.&lt;/p&gt;

&lt;h3 id=&quot;поиск-проблем&quot;&gt;Поиск проблем&lt;/h3&gt;

&lt;p&gt;В секции с шагом планирования упоминались «висящие» задачи. Кроме этого есть еще один «smell». Связан он с ситуацией, когда задача блокирует другие задачи, например вот так:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-task-blocker.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Центральная задача блокирует правые. При этом, центральная задача ждет левые&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Проблема тут в том, что нельзя распараллелить выполнение работ из-за центрального блокера. Это не всегда плохо, но советую подумать, как можно блокер разбить на несколько задач, которые позволят разблокировать параллельность.&lt;/p&gt;

&lt;h3 id=&quot;как-срокиресурсы-считать&quot;&gt;Как сроки/ресурсы считать&lt;/h3&gt;

&lt;p&gt;Сразу скажу, делал такое 2 раза в жизни, но оба раза срабатывало. Идея в том, что сначала проставляется оценка задачам, после чего планируется, сколько команд надо для работы. В результате можно предположить сколько людей и в какой последовательности будут происходить работы. Благодаря чему заранее выбить капасити каждой команды и предположить сколько времени займет работа (немного точнее, чем просто «пальцем в небо»).&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-resource-planning.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Что бы вынести сервис из монолита нужно 4 команды (каждый цвет – отдельная команда), причем левые три команды могут работать параллельно, а последняя нужна только в самом конце и до реализации бизнес логики может отдыхать&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Подход полезен в двух случаях: когда надо посчитать «пальцем в небо» стоимость и когда проект реализуется сразу несколькими командами и нужно кросс командное взаимодействие.&lt;/p&gt;

&lt;h3 id=&quot;как-понять-почему-по-срокам-не-укладывайтесь&quot;&gt;Как понять, почему по срокам не укладывайтесь&lt;/h3&gt;

&lt;p&gt;Специально для ситуаций, когда бизнес не понимает, почему изначальный коммит был на полгода, а прошло уже 2 года и проект не приносит денег. Благодаря графу можно наглядно показать как увеличился пул задач или какие задачи долго висели в блоке. Судя по опыту, это выглядит намного нагляднее для не-менеджеров, чем графики «джиры».&lt;/p&gt;

&lt;p&gt;Плюс, если за 2-3 спринта задачи только добавляются в граф, а прогресса нет – время бить тревогу и пинать менеджмент/бизнес, что проблемы начались.&lt;/p&gt;

&lt;h3 id=&quot;используем-реальный-анализ-графов&quot;&gt;Используем реальный анализ графов&lt;/h3&gt;

&lt;p&gt;Так как это граф, можно применить научные методики анализа из теории графов. Но тему не раскручивал, поэтому оставлю идею для самостоятельного изучения. Если что-то придумаете, напишите пожалуйста, буду рад обсудить.&lt;/p&gt;
&lt;h3 id=&quot;как-использовать-project-management-tools-с-таким-графом&quot;&gt;Как использовать project management tools с таким графом&lt;/h3&gt;

&lt;p&gt;Если взять &lt;a href=&quot;https://pepegramming.site/questions/data-model/#data-modelling&quot; target=&quot;_blank&quot;&gt;идею conceptual/logical/physical data models&lt;/a&gt;, то можно представить граф как концептуальную модель, PM tool как логическую, а реализацию в виде кода как физическую&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/conceptual-logical-phisical-models.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Наглядное сравниение каждой data model и планирования работы&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Из этого сравнения получается, что есть условный «эпик», который описывается графом. Каждая нода графа – отдельный проект в «джире», а каждый таск из проекта – отдельный PR/MR, который на шаг ближе закрывает эпик.&lt;/p&gt;

&lt;p&gt;Благодаря такому разделению, можно использовать viewpoints для каждого стейкхолдера: список задач для команды, гант диаграмму по эпику, статус проекта для бизнеса, задачи для конкретного разработчика и так далее.&lt;/p&gt;

&lt;p&gt;А если используете &lt;a href=&quot;https://habr.com/ru/articles/831922/&quot; target=&quot;_blank&quot;&gt;трассировку требований&lt;/a&gt;, сможете линковать между собой. Единственный минус подхода, для графа нет автоматизации.&lt;/p&gt;

&lt;h2 id=&quot;плюсы-и-минусы-использования-графа-для-планирования&quot;&gt;Плюсы и минусы использования графа для планирования&lt;/h2&gt;
&lt;p&gt;Начну с плюсов:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Появляется хоть какая-то системность в планировании и выполнении проекта. Благодаря чему каждый из стейкхолдеров может рассматривать &lt;a href=&quot;https://creatime.me/MediaLibrary/UchebnyeMaterialy-2/Stati/PodsistemyI&quot; target=&quot;_blank&quot;&gt;либо подсистемы либо надсистемы&lt;/a&gt; в зависимости от собственных интересов;&lt;/li&gt;
  &lt;li&gt;Лично доволен таким подходом, за пять лет проблем не было;&lt;/li&gt;
  &lt;li&gt;Когда проектов больше пяти – помогает быстро получить контекст в каком состоянии реализация каждого;&lt;/li&gt;
  &lt;li&gt;Судя по опыту, бизнес любит такую наглядность. Разработчики страдают от того, что сложно хайлевел задачи декомпозировать и понять что за чем – поэтому декомпозицию можно обсудить заранее. Пару раз ребята говорили спасибо, ибо понимали что их дальше ждет и могли заранее подготовить код к будущей работе;&lt;/li&gt;
  &lt;li&gt;Из-за концептуальности и простоты решения – супер гибкое решение. Выбираете удобный вам инструмент для диаграмм и работаете. Только помните, что в случае вайтбордов придется решить, как версионировать графы. Плюс, с добавлением трассировки требований, можно быстро делать кросс линки между задачами и другими артефактами работы;&lt;/li&gt;
  &lt;li&gt;Концептуальный план делается быстро и легко правится. После можно сделать «логический» план в виде задач или эпиков в джире и сразу начать работать, вместо того, что бы тратить время на реализацию концептуального плана в PM tool;&lt;/li&gt;
  &lt;li&gt;Хорошо показывает себя в проектах, где есть четкая цель, которая не поменяется через пол года и которую долго делать. Например, когда знаете, что надо вынести сервис, отрефакторить кусок кода или реализовать фичу с определенным DoD. Один раз сделали, знаете конец и дальше работаете, раз в спринт сверяясь;&lt;/li&gt;
  &lt;li&gt;Судя по опыту, работает для ретро лучше, чем список задач из джиры (возможно ошибка выжившего). Связано с тем, что подход добавляет концепцию «журнала» связанного с проблемами, хорошими вещами и вопросами. После чего, на ретро, открываем нужный спринт и смотрим, что там происходило;&lt;/li&gt;
  &lt;li&gt;Не совсем о подходе, но скорее в целом о полном плане работ: включается &lt;a href=&quot;https://fs.blog/amateurs-professionals/&quot; target=&quot;_blank&quot;&gt;мышление второго порядка&lt;/a&gt;. Особенно, если план валидировать через результат каждого шага + вопроса “что произойдет после этого”;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;После плюсов может показаться, что инструмент серебряная пуля, но минусов у графа тоже много:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;К концу релиза начинается каша и велик риск забить на диаграмму. Нужен высокий уровень самоконтроля и постоянно пушить исполнителей. Из этого следует главный минус – без контроля и ревью, подход не работает;&lt;/li&gt;
  &lt;li&gt;Не сработает, когда высокая неопределенность в работе. Т.е. когда сделав задачу, планы меняются и становятся другими, например сегодня выносите сервис, а завтра оказывается, что денег больше нет и надо гипотезы делать по две штуки в день;&lt;/li&gt;
  &lt;li&gt;Это придуманный подход, его нет нигде. Поэтому допускаю проблемы с объяснением и обучением, так как нет описания. Т.е. кроме куска из курса о системах и этого текста, в интернете информации нет (если ошибаюсь и знаете аналоги, буду рад ссылке);&lt;/li&gt;
  &lt;li&gt;Придется заморочиться с трассировкой требований, если нужна интеграция с проектной документацией. Это лишняя работа и цена;&lt;/li&gt;
  &lt;li&gt;Подход придется продавать бизнесу, менеджерам и исполнителям работы. Продажа подхода – одна из причин, почему появился этот текст;&lt;/li&gt;
  &lt;li&gt;Из инструментов – кривые плагины для конфлюенса и аналогов, либо делать руками. Если используете диаграммы - нет фильтрации по проектам/командам и автоматической генерации других viewpoints;&lt;/li&gt;
  &lt;li&gt;Подход не о сроках и датах. Если сроки важны, придется либо делать отдельный viewpoint (например ганта), либо использовать другой инструмент;&lt;/li&gt;
  &lt;li&gt;Менеджерам будет не хватать асайнов на людей, фильтрации и сроков/статусов;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;выводы&quot;&gt;Выводы&lt;/h2&gt;

&lt;p&gt;Использование подобного графа оправданно, если необходим «концептуальный» уровень для планирования проектов, а условная «джира» не справляется. Так как подход максимально гибок, можно использовать любые инструменты для диаграмм или вайтбордов (можно даже лист бумаги и ручку взять). Важно помнить, что стоит делать квадраты похожими на проект из GTD и следить за связями. При этом, кроме работы над планом, стоит потратить время на регулярное обновление статуса по проекту, что в будущем окупится аналитикой и ретро.&lt;/p&gt;

&lt;p&gt;Ну и еще раз напишу, что описанный подход планирования и слежения за проектами не единственный и не серебрянная пуля. Ну и помните главное правило: если устраивает текущая ситуация в компании – лучше ничего не трогать и не гнаться за новым подходом, ради подхода.&lt;/p&gt;

&lt;p&gt;Кроме этого, если используете «концептуальный» вью в PM инструментах, буду рад, если поделитесь секретом в комментариях. А если захотите воспользоваться описанным выше подходом и останутся вопросы или захотите поделиться фидбеком – буду рад в два раза больше.&lt;/p&gt;

&lt;h2 id=&quot;доп-ссылки&quot;&gt;Доп ссылки&lt;/h2&gt;

&lt;p&gt;Инструменты, представляющие работу над задачей в виде графа:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://about.i.ntention.app&quot; target=&quot;_blank&quot;&gt;Intention&lt;/a&gt;, работает на андроиде и в вебе (если понял правильно). &lt;a href=&quot;https://news.ycombinator.com/item?id=22591311&quot; target=&quot;_blank&quot;&gt;Обсуждение на ycombinator&lt;/a&gt; тоже присутствует;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://eyen.fr/taskheat/&quot; target=&quot;_blank&quot;&gt;Приложение за которым долго слежу&lt;/a&gt; и от которого были большие ожидания для персональных проектов, но так и не зашло. Возможно попробую еще раз через пару лет. Работает только на apple устройствах и больше о персональных проектах, т.е. конкурент для things3/todois/ticktick/etc;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.gameplan.global&quot; target=&quot;_blank&quot;&gt;PM tool, о котором никогда не слышал&lt;/a&gt; (нашел, пока ответ писал). Кажется, что если используете что-то другое, переехать на «нонейм» решение будет сложно;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.easyredmine.com/redmine-wbs-plugin&quot; target=&quot;_blank&quot;&gt;Плагин для редмайна&lt;/a&gt; с похожей функциональностью;&lt;/li&gt;
  &lt;li&gt;Два плагина для джиры с похожим функционалом: &lt;a href=&quot;https://marketplace.atlassian.com/apps/1216207/issue-links-viewer&quot; target=&quot;_blank&quot;&gt;первый&lt;/a&gt; и &lt;a href=&quot;https://whiteboards.io&quot; target=&quot;_blank&quot;&gt;второй&lt;/a&gt;;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Как визуализировать схему базы данных</title>
   <link href="http://pepegramming.site/questions/data-model/"/>
   <updated>2024-08-01T00:00:00+03:00</updated>
   <id>http://pepegramming.site/questions/data-model</id>
   <content type="html">&lt;h2 id=&quot;вопрос&quot;&gt;Вопрос&lt;/h2&gt;

&lt;div class=&quot;question-text&quot;&gt;
  &lt;blockquote&gt;
    &lt;p&gt;«Возникла проблема, что нужно визуализировать данные, но не понятно с чего начать. Что в таких случаях делаешь и какие есть инструменты для этого?»&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/div&gt;

&lt;p&gt;Так как вопрос без конкретики, выделю два случая:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Проект только в голове и хочется понять как связаны данные между собой&lt;/li&gt;
  &lt;li&gt;Проект уже реализован в коде и хочется понять, что из себя представляет схема бд&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Поэтому, вместо короткого ответа «используй ERD», поговорим о каждом из вариантов. Но сначала разберемся с data modelling, благодаря которому можно определить нужный вид диаграммы для задачи.&lt;/p&gt;

&lt;h2 id=&quot;data-modelling&quot;&gt;Data modelling&lt;/h2&gt;

&lt;p&gt;Может показаться, что взять и начать фигачить SQL схему описывающую данные для проекта может быть разумной идеей. На деле это не так:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Так как нет структуры данных в голове, можно запутаться и упороться в вечное редактирование. А если данных много и связей еще больше - получится хаос который не влезет в голову;&lt;/li&gt;
  &lt;li&gt;Полученную модель данных придется валидировать, причем с бизнесом/доменным экспертом. Не разработчикам будет сложно и валидация может затянуться;&lt;/li&gt;
  &lt;li&gt;Когнитивная нагрузка увеличивается: работая с текстом, придется этот текст представить в виде модели в голове и потом обратно, из модели в текст;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-01-data-model/schema-vs-visualisation.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Слева - схема в dbml, которая представлена в виде диаграммы (справа). Когда разбираешься с новым проектом – мне проще сразу картинкой (моделью) оперировать&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;В целом, выглядит надежно, как швейцарские часы. Поэтому придумали процесс, который назвали &lt;a href=&quot;https://en.wikipedia.org/wiki/Data_model&quot; target=&quot;_blank&quot;&gt;data modeling&lt;/a&gt;. Data modeling помогает с определением релевантных для системы данных, связью между этими данными и как данные работают вместе, т.е. создать data model для системы. Главное, что стоит вынести из этой идеи – моделирование можно разбить на три «перспективы»:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Conceptual_schema&quot; target=&quot;_blank&quot;&gt;Концептуальная&lt;/a&gt; говорит о том, какие данные используются системой и как данные связаны между собой. Т.е. тут о том, что необходимо бизнесу без привязки к конкретной реализации хранения данных в конкретной бд&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_schema&quot; target=&quot;_blank&quot;&gt;Логическая&lt;/a&gt; говорит о том, как данные структурируются в приложении. Т.е. берем любой язык описания схемы (будь то SQL, dbml или еще что) и описываем таблицы/колонки/классы/etc.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Physical_schema&quot; target=&quot;_blank&quot;&gt;Физическая&lt;/a&gt; говорит о том, как данные физически храниться будут. Т.е. берем логическое описание и говорим где данные будут находиться физически и как все будет работать в реальности;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-01-data-model/conceptual-vs-logical-models.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Сравнение концептуальной (правая) и логической (левая) схем, где пример из самого начала. Возможно, я сделал концептуальную модель не корректно, но задача показать идею, а не сделать корректную модель&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;При использовании концептуальной модели данных можно отказаться от «технической» информации и оставить только необходимое для реализации бизнесовой модели. Т.е. можно не запариваться с pk, fk и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;created_at&lt;/code&gt; для каждого объекта и не думать о таблицах. Так, в примере выше, указан продукт как «элемент», к которому привязаны отдельные «элементы»: цена, тег и статус. Эта информация необходима для бизнес логики, хотя в реальности, если опуститься на логический уровень – данные оказываются в одной таблице.&lt;/p&gt;

&lt;p&gt;Теперь, используя информацию о data modeling, можно вернуться к оригинальному вопросу.&lt;/p&gt;

&lt;h2 id=&quot;случай-1-проект-только-в-голове-и-хочется-понять-как-связаны-данные-между-собой&quot;&gt;Случай 1: Проект только в голове и хочется понять как связаны данные между собой&lt;/h2&gt;

&lt;p&gt;Возможно бизнес с нуля делает систему, либо же нужно разобраться в уже работающей бизнес логике (доменной модели). Для этого придется разбираться с данными: какие элементы, как элементы связаны. Если в этот момент думать о том, где какая таблица будет и что в этой таблице должно находиться – выглядит как доп нагрузка которая усложняет работу. Поэтому для первого случая концептуальное представление предпочтительнее: меньше когнитивная нагрузка, проще работать, можно показать бизнесу не объясняя что это за &lt;a href=&quot;https://www.datensen.com/blog/er-diagram/one-to-many-relationships/&quot; target=&quot;_blank&quot;&gt;вилка&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;виды-нотаций-концептуальных-моделей&quot;&gt;Виды нотаций концептуальных моделей&lt;/h3&gt;

&lt;p&gt;Тут список может быть большой, опишу только то, что сам знаю и видел. Подробно на каждой нотации останавливаться не буду, оставлю это на самостоятельное изучение.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://studme.org/77224/informatika/notatsiya_idef&quot; target=&quot;_blank&quot;&gt;Нотация IDEF 1х&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://studme.org/77225/informatika/notatsiya_uml&quot; target=&quot;_blank&quot;&gt;PlantUml&lt;/a&gt;, тут используется &lt;a href=&quot;https://en.wikipedia.org/wiki/Class_diagram&quot; target=&quot;_blank&quot;&gt;class diagram&lt;/a&gt;, что сомнительно, но для общего развития пусть будет.&lt;/li&gt;
  &lt;li&gt;Cтоит упомянуть &lt;a href=&quot;http://www.modelsphere.com/org/index.html&quot; target=&quot;_blank&quot;&gt;Open ModelSphere&lt;/a&gt;, это oss инструмент, который помогает с моделированием данных не только концептуально, но и логически/физически
 
Отдельно хочется рассказать еще о двух нотациях:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Первая нотация – &lt;a href=&quot;https://en.wikipedia.org/wiki/Entity–relationship_model&quot; target=&quot;_blank&quot;&gt;ER model&lt;/a&gt; (иногда встречается как &lt;a href=&quot;https://studme.org/77222/informatika/notatsiya_pitera_chena&quot; target=&quot;_blank&quot;&gt;нотация Питера Чена&lt;/a&gt;) и тут важно не путать с ER diagram. Модель создана Питером Ченом в 1976 году для абстрактного описания данных. При этом, модель предоставляет абстракции для концептуального/логического/физического моделирования. Интересный факт: эта одна из нотаций, которые повлияли на UML.&lt;/p&gt;

&lt;p&gt;Вторая – &lt;a href=&quot;https://martinfowler.com/books/ap.html&quot; target=&quot;_blank&quot;&gt;нотация концептуальной модели Мартина Фаулера из книги&lt;/a&gt;, о которой преступно мало знают.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-01-data-model/martin-fowler-notation.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Так выглядит нотация используемая Фаулером, она описана прямо на первых страницах книги&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Что выбрать – решайте сами. Расскажу о том, что сам использую и почему редко использую описанные выше модели.&lt;/p&gt;

&lt;h3 id=&quot;что-сам-использую&quot;&gt;Что сам использую&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://tough-roadway-bb5.notion.site/1-1-6adfeb2e07eb4269b5966ffb742d7fad#34413c7cc27b4e1da6ee31177875b93b&quot; target=&quot;_blank&quot;&gt;Я использую сильно упрощенную нотацию, состоящую только из квадратов и стрелок&lt;/a&gt;, которую сам и «придумал». При этом, вместо использования сложных видов стрелок, подписываю вид связи который нужен (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;has_one&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;has_many&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;optional_has_one/many&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;many_to_many&lt;/code&gt;). Плюс использую цветовое обозначение для данных, которые используются в разных контекстах.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-01-data-model/data-model-example.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример модели из рабочего проекта. Тут кусок модели, &lt;a href=&quot;https://vc.ru/fedorandsamat/1103649-kak-my-perezapuskali-medicinskuyu-informacionnuyu-sistemu&quot;&gt;связанный с работой дантистов&lt;/a&gt;&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Такой выбор обусловлен двумя причинами:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Концептуальную модель приходится валидировать с бизнесом/доменными экспертами. Чем сложнее нотация, тем больше шансов, что человек запутается. Плюс грузить и без этого занятых людей так себе подход.&lt;/li&gt;
  &lt;li&gt;Внимательность – не обо мне, поэтому с большим шансом запутаюсь или пропущу стрелку/форму и по итогу получится фигня. Рисковать и проверять себя по 10 раз не хочется.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если в компании уже есть стандарт, либо хотите использовать распространенный стандарт – лучше забыть эту часть текста и использовать то, что уже принято. Если ничего такого нет, возможно стоит скопировать мое решение, а после, если этого окажется мало, выбрать любую из описанных выше нотаций.&lt;/p&gt;

&lt;h3 id=&quot;советы-для-моделирования-данных-не-схемы-бд&quot;&gt;Советы для моделирования данных (не схемы бд)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Забудьте о таблицах и реализации в бд. Начните с данных, которые необходимы для работы бизнес модели. Главная причина такого категоричного совета – проще замапить корректную концептуальную модель на реализацию конкретной базы данных, чем упороться с реализацией и потерять важные данные. Это может привести к тому, что решение не будет бизнес задачу решать, а будет подстраиваться под техническое решение, вокруг которого зацепитесь;&lt;/li&gt;
  &lt;li&gt;Вытекает из первого совета: в концептуальной модели не нужны данные, которые окажутся в базе данных. Поэтому о &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pk&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fk&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;created_at&lt;/code&gt;, etc можно забыть. Только если это не часть доменной модели;&lt;/li&gt;
  &lt;li&gt;Не важно какую нотацию выбрали, модель без легенды – деньги на ветер;&lt;/li&gt;
  &lt;li&gt;Валидируете модель с бизнесом/доменным экспертом;&lt;/li&gt;
  &lt;li&gt;Между дублированием элементов и уменьшением стрелок – выбирайте дублирование. Так можно снизить когнитивную нагрузку, которая появится из-за стрелочного хаоса. По этой же причине старайтесь избегать пересечения стрелок;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;С моделированием разобрались. Давайте поговорим о генерации картинок из схемы бд.&lt;/p&gt;

&lt;h2 id=&quot;случай-2-проект-уже-реализован-в-коде-и-хочется-понять-что-из-себя-представляет-схема-бд&quot;&gt;Случай 2: Проект уже реализован в коде и хочется понять, что из себя представляет схема бд&lt;/h2&gt;

&lt;p&gt;В данном случае, если нужна концептуальная модель – инструментов не знаю, к сожалению. Поэтому, для проектов с реализованной схемой бд, рисую концептуальные модели «руками».&lt;/p&gt;

&lt;p&gt;Но если хватит логической модели, можно найти решение. Из того что знаю – ER diagram (которая, является подмножеством ER model). Существует новомодный dbml, который тоже использовал. Еще стоит упомянуть &lt;a href=&quot;https://studme.org/77223/informatika/notatsiya_martina_crows_foot&quot; target=&quot;_blank&quot;&gt;Нотацию Мартина (Crow’s Foot)&lt;/a&gt;, но в живую не наблюдал. Если знаете другие варианты – буду рад комментариями, ибо самому интересно, а быстро нагуглить альтернативы не вышло.&lt;/p&gt;

&lt;p&gt;Для генерации «картинки» я использую следующие подходы:&lt;/p&gt;

&lt;h3 id=&quot;генерация-модели-из-кода&quot;&gt;Генерация модели из кода&lt;/h3&gt;

&lt;p&gt;В эту секцию входят:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;инструменты diagram as a code: &lt;a href=&quot;https://graphviz.org/Gallery/neato/ER.html&quot; target=&quot;_blank&quot;&gt;graphiz&lt;/a&gt;, &lt;a href=&quot;https://mermaid.js.org/syntax/entityRelationshipDiagram.html&quot; target=&quot;_blank&quot;&gt;mermaid&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;библиотеки для разных языков (&lt;a href=&quot;https://github.com/drivendataorg/erdantic&quot; target=&quot;_blank&quot;&gt;python&lt;/a&gt;, &lt;a href=&quot;https://github.com/voormedia/rails-erd&quot; target=&quot;_blank&quot;&gt;ruby&lt;/a&gt;, &lt;a href=&quot;https://github.com/fuelen/ecto_erd&quot; target=&quot;_blank&quot;&gt;elixir/ecto&lt;/a&gt;, &lt;a href=&quot;https://github.com/gmarik/go-erd&quot; target=&quot;_blank&quot;&gt;golang&lt;/a&gt;, &lt;a href=&quot;https://www.npmjs.com/package/prisma-erd-generator&quot; target=&quot;_blank&quot;&gt;js/prisma&lt;/a&gt;, etc) которые под капотом используют graphiz.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;С вероятностью в 99% там будет ERD. А подход подойдет в двух случаях:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Если схема данных меньше ~15 таблиц и хочется быстро подключить генератор, а после забыть и получать каждый релиз новый артефакт;&lt;/li&gt;
  &lt;li&gt;Если модель нужна для поста или показать идею;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Плюсы:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Работает для схем, где таблиц меньше ~15 или когда связей мало между таблицами;&lt;/li&gt;
  &lt;li&gt;Библиотеки работают из коробки и легко настраиваются;&lt;/li&gt;
  &lt;li&gt;Если говорим о библиотеках – нет проблем с обновлением схемы после изменений, так как генерируется новый файл;&lt;/li&gt;
  &lt;li&gt;Легко шарить между коллегами. Отправляем картинку в чат, добавляем в репозиторий или конфлюенс/ноушен/etc;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Из минусов:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Нельзя поменять положение элементов или связей. А автоматическая генерация не поддается логике;&lt;/li&gt;
  &lt;li&gt;На больших схемах получается не читаемая каша. Особенно, когда дело касается связей;&lt;/li&gt;
  &lt;li&gt;Генерируется векторная картинка, если схема увесистая – может шакалить;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;генерация-erd-в-инструментах-для-диаграм&quot;&gt;Генерация ERD в инструментах для диаграм&lt;/h3&gt;

&lt;p&gt;Lucidchart предоставляет &lt;a href=&quot;https://www.lucidchart.com/pages/examples/er-diagram-tool&quot; target=&quot;_blank&quot;&gt;инструмент, который генерирует ERD по загруженной схеме бд&lt;/a&gt;. Дальше получаете диаграмму, в которой можно двигать элементы, стрелки, добавлять новые элементы, менять цвета и делать что угодно.&lt;/p&gt;

&lt;p&gt;Draw.io реализовали &lt;a href=&quot;https://www.drawio.com/doc/faq/sql-plugin&quot; target=&quot;_blank&quot;&gt;аналогичный инструмент&lt;/a&gt;. Только для работы придется вставлять SQL код. После, с полученной схемой, также можно производит манипуляции с диаграммой.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-01-data-model/erd-bad-example.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример сгенерированной ERD в lucidchart. Получи такое картинкой – сразу бы отказался от проекта&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Плюсы:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;В отличии от векторной картинки – можно делать с полученной моделью что угодно;&lt;/li&gt;
  &lt;li&gt;Если не хватит сгенерированных элементов – можно добавить (например стикеры и комментарии);&lt;/li&gt;
  &lt;li&gt;Если схема большая – можно двигать каждую связь или элемент, плюс выручает поиск по модели;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Из минусов:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Могут теряться связи между элементами, особенно если связи указаны в коде, но не учтены в схеме бд. Пару раз попадался на эту уловку и приходилось руками достраивать модель, что малоприятно;&lt;/li&gt;
  &lt;li&gt;Хоть с диаграммой можно делать что угодно, но первичная генерация хаотична. Поэтому для «наведения порядка» придется самостоятельно двигать элементы;&lt;/li&gt;
  &lt;li&gt;Специфичный импорт, из-за чего придется под новую версию схемы делать новую диаграмму. А если добавили что-то кастомное, придется дублировать руками;&lt;/li&gt;
  &lt;li&gt;Шарить модель может быть проблемно, особенно если используете lucid и душит жаба платить за кучу людей (но для конфлюенса был плагин);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Заметка: помните, что генераторы ERD присутствуют не везде. Например, &lt;a href=&quot;https://miro.com/diagramming/er-diagram/&quot; target=&quot;_blank&quot;&gt;в miro нет ERD генераторов&lt;/a&gt;, вместо этого, получите только элементы для того, чтобы самостоятельно рисовать модель. &lt;/p&gt;

&lt;h3 id=&quot;использование-dbml&quot;&gt;Использование dbml&lt;/h3&gt;

&lt;p&gt;Персональное открытие прошлого года. Вместо рассказа, &lt;a href=&quot;https://dbdiagram.io/d&quot; target=&quot;_blank&quot;&gt;лучше посмотреть самостоятельно&lt;/a&gt; (в верхнем левом углу, где лого, можно загрузить advanced sample, который использовался в примерах в начале статьи).&lt;/p&gt;

&lt;p&gt;При этом, так как dbml схема типизирована, можно написать конвертер из erd в dbml и получить генерацию схемы из кода (делал так для &lt;a href=&quot;https://github.com/voormedia/rails-erd&quot; target=&quot;_blank&quot;&gt;erd-rails&lt;/a&gt; генератора). После, вставляем схему в редактор и изучаем схему баз данных.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Плюсы:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Из-за динамичности, можно двигать элементы, что работает с большими схемами;&lt;/li&gt;
  &lt;li&gt;Diagram as a code. Можно &lt;a href=&quot;https://dbml.dbdiagram.io/cli#convert--a-sql-file-to-dbml&quot; target=&quot;_blank&quot;&gt;генерировать dbml схему по SQL&lt;/a&gt;, присутствует &lt;a href=&quot;https://github.com/stepanic/parse-server-SCHEMA-to-DBML&quot; target=&quot;_blank&quot;&gt;библиотека для монги (не проверял)&lt;/a&gt;, &lt;a href=&quot;https://github.com/hamedsj/DbmlForDjango&quot; target=&quot;_blank&quot;&gt;для джанги&lt;/a&gt; библиотека существует;&lt;/li&gt;
  &lt;li&gt;Предпросмотр работает в браузере, не надо ничего ставить локально;&lt;/li&gt;
  &lt;li&gt;Так как генерация из кода – можно избежать ситуации, когда связи не отображаются, так как связей нет в схеме бд, но есть на уровне кода;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Из минусов:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Нет нормальной экосистемы. Библиотеки придется писать самому, в частности для мало популярных языков;&lt;/li&gt;
  &lt;li&gt;Еще один язык описания схемы, который придется изучить;&lt;/li&gt;
  &lt;li&gt;Если хотите хранить и смотреть модели командой, придется платить. Хотите селфхостед – на 2023 год находил аналоги, но каждый оставлял желать лучшего;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;генерация-из-редактораide&quot;&gt;Генерация из редактора/IDE&lt;/h3&gt;

&lt;p&gt;Так как всю жизнь просидел в vim, без возможности выхода, то особо ничего сказать о генерации схем из редактора и инструментов для этого. Знаю, что инструменты существуют и пользователи jetbrains &lt;a href=&quot;https://www.jetbrains.com/help/datagrip/creating-diagrams.html#db_diagrams&quot; target=&quot;_blank&quot;&gt;могут смотреть на схему не выходя из редактора&lt;/a&gt;. Лучше погуглить самостоятельно.&lt;/p&gt;

&lt;h2 id=&quot;итоги&quot;&gt;Итоги&lt;/h2&gt;

&lt;p&gt;Если необходимо смоделировать данные, то важно разобраться с целью модели, так как каждое представление закрывает определенные потребности:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Концептуальная модель – говорит о том, какие данные используются системой и как данные связаны между собой. Подойдет если важно понять что за данные нужны в бизнес логике и как данные связаны между собой;&lt;/li&gt;
  &lt;li&gt;Логическая модель – говорит о том, как данные структурируются в приложении. Поможет описать или посмотреть на схему бд. Можно сгенерировать автоматически;&lt;/li&gt;
  &lt;li&gt;Физическая модель – говорит о том, как данные физически храниться будут. Сам не использовал, но допускаю, что поможет в инфраструктурных документах;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если нужно визуализировать схему бд, то тут два варианта: для мелких схем или для примеров лучше взять генераторы или diagram as a code инструменты, а для больших схем лучше либо взять инструменты для диаграм, либо посмотреть в сторону dbml, который можно использовать и в качестве генератора.&lt;/p&gt;

&lt;h2 id=&quot;что-еще-почитать-по-теме&quot;&gt;Что еще почитать по теме&lt;/h2&gt;

&lt;p&gt;Если тема data model заинтересовала, собрал четыре ссылки, по которым можно погрузиться в тему глубже. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[en] В статье не рассказывал про archimate. Хотя там так же &lt;a href=&quot;https://eaprincipals.com/data-modeling-with-archi/&quot; target=&quot;_blank&quot;&gt;можно сделать нужную data model&lt;/a&gt;. Если используете archi - ничего нового не узнаете, скорее всего;&lt;/li&gt;
  &lt;li&gt;[en] &lt;a href=&quot;https://www.mongodb.com/basics/data-modeling&quot; target=&quot;_blank&quot;&gt;Статья из блога mongoDB, в которой рассказывается data modelling&lt;/a&gt;. В тексте найдете описание подхода, виды представлений, описание процесса, советы и еще больше инструментов и так далее;&lt;/li&gt;
  &lt;li&gt;[en] &lt;a href=&quot;https://www.thoughtspot.com/data-trends/data-modeling/conceptual-data-model-examples&quot; target=&quot;_blank&quot;&gt;Статья о том, как сделать концептуальную модель&lt;/a&gt;, какие виды есть и в чем ее преимущества;&lt;/li&gt;
  &lt;li&gt;[en] Серия статей о визуализации бд. По &lt;a href=&quot;https://minimalmodeling.substack.com/p/visual-language-and-database-visualization&quot; target=&quot;_blank&quot;&gt;ссылке третья часть&lt;/a&gt;, где упоминаются разные приложения для визуализации: MySQL Workbench,  Anchor,  TLDraw и Arrows.app;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Ретроспектива: ecommerce</title>
   <link href="http://pepegramming.site/blogposts/retrospection-ecommerce/"/>
   <updated>2020-06-03T00:00:00+03:00</updated>
   <id>http://pepegramming.site/blogposts/retrospection-ecommerce</id>
   <content type="html">&lt;p&gt;Год назад я ушел из healthcare стартапа, который являлся ecommerce для лекарств в штатах. Сразу после ухода я написал черновик с советами самому себе о том, что стоит делать сразу, а на что обратить внимание.&lt;/p&gt;

&lt;p&gt;Черновик забылся на год, но, найдя записи в блокноте, выложил в паблик как ретроспективу основанную на опыте и боли. Каждый пункт -  субъективный опыт и не претендуют на единственно верное решение. Если у вас есть похожие советы связанные с ecommerce - пишите комментарии, хочется собрать целый список. В будущем, можно будет сделать подобные списки и для других видов проектов.&lt;/p&gt;

&lt;h2 id=&quot;ордер-и-цены&quot;&gt;Ордер и цены&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cart&lt;/code&gt; - частный случай &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order&lt;/code&gt;. Вместо двух сущностей можно взять &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order&lt;/code&gt;  со статусом &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;created&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Купоны появятся. Делать купон отдельной сущностью - усложняет логику и добавит условий в чекаут и рефанд логику. Сегодня, если нужно будет делать добавить купоны в систему - сделаю купон отдельным айтемом с отрицательной ценой (скидкой).&lt;/li&gt;
  &lt;li&gt;В &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order_items&lt;/code&gt; линковался на &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;item&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;price&lt;/code&gt; из базы. Также, аналитики постоянно меняли цены на товары. Такая ситуация привела к мутациям ордера и было тяжело сказать, что и сколько стоило для ордера годичной давности. А пользователь получал не предсказуемый UX, так как возникала гипотетическая ситуация, что в момент чекаута цена на товар меняется и пользователь заплатит больше или меньше чем ожидает. Сегодня я бы помести в каждый &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order_item&lt;/code&gt;  JSONB поле для цены которое выглядело следующим образом &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSONB: { added_at: &apos;&apos;, price: ... }&lt;/code&gt;. В таком случае нет непредвиденных мутаций, появляется версионирование данных. К тому же, это больше информации для аналитиков.&lt;/li&gt;
  &lt;li&gt;Датасайнтисты захотят менять цены, используя сложные паттерны расчета цены и кучу условий. Это приводит к постоянным изменениям цен в базе данных. Поэтому сформировалось правило, все что относится к ценам стоит как можно раньше изолировать в отдельный домен, сервис, rails engine, что угодно. Разделять стоит не только на уровне логики, но и на уровне данных. Вариант с JSONB полем - частный случай такого разделения.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;обсервабилити&quot;&gt;Обсервабилити&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Мониторинг и логирование добавляют контроля и скажут что происходит или подскажут где проблема. Покрывать логами и мониторингом каждую строчку  дорого, поэтому top1 кандидаты: все что связанно с деньгами, checkout&amp;amp;refund flow, изменения в данных, интеграции с партнерами, которые приносят деньги. Подход коррелирует с правилом “знайте, что происходит в частях системы, которые приносят деньги”.&lt;/li&gt;
  &lt;li&gt;Работу с деньгами стоит начинать с логов. Если нет ELK или хранилища для логов в котором можно найти информацию без боли - используйте базу данны. Решение для старта - отдельная аудит таблица куда будет попадать информация от платежного шлюза. Такая информация будет полезна как в дебаге, так и аналитикам для создания моделей.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;архитектура&quot;&gt;Архитектура&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Если в системе присутствуют мобильные устройства и другие виды клиентов (например b2b интеграции), значит стоит подумать о версионировании и заложить работу с версиями с самого начала. Кроме версионирования контроллера есть версионирование бизнес логики и версионирование данных.&lt;/li&gt;
  &lt;li&gt;Если клиентов больше двух рекомендую  почитать о &lt;a href=&quot;https://samnewman.io/patterns/architectural/bff/&quot;&gt;BFF паттерне&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Если событий нет в коде - вероятность появления крайне высока. Sidekiq не предназначен для event driven architecture, хотя помогает отодвинуть переход на новую архитектуру и работает для бэкграунд процессинга или в самом начале работы проекта. Поэтому стоит заложить в имплементацию последующее использование событий вне сайдкика.&lt;/li&gt;
  &lt;li&gt;Код без событий для бизнеса и аналитиков - деньги на ветер. Стоит с самого старта проекта заложить, что события относящиеся к работе бизнеса нужно отправлять. Не обязательно использовать сложные решения или платить за SaaS продукты. Например, в собственных проектах шлю события в телеграм, а некоторые пишу в базу.&lt;/li&gt;
  &lt;li&gt;Kafka как брокер событий с самого старта - провал. Это дорого и очень дорого. Если хоститесь в клауде - sqs или google pub/sub могут стать хорошим началом. Если нет - выбирайте из селфхостед аналогов. Также, стоит сразу подумать о прямой и обратной совместимости данных в событиях, а также о schema registry. Как хак подойдет отдельный репозиторий со схемами событий.&lt;/li&gt;
  &lt;li&gt;Временное остаётся навсегда. Так технология добавленная на 2 спринта осталась в проекте на 2 года.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;данные-и-etl&quot;&gt;Данные и ETL&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;В маркете возникает ситуация, когда регулярно надо загружать новые данные. Пример - цены на товары и сама информация по товарам. Вместо создания rake тасков для загрузки csv в базу, стоит посмотреть на ETL и заложить работу с ним в архитектуру. Из  аналогов можно посмотреть на &lt;a href=&quot;https://github.com/thbar/kiba&quot;&gt;kiba&lt;/a&gt; (написан на руби) и &lt;a href=&quot;https://airflow.apache.org&quot;&gt;Apache Airflow&lt;/a&gt;, написанный на питоне.&lt;/li&gt;
  &lt;li&gt;Желательно подумать о том, как выгружать данные из приложения аналитикам заранее. Шарить дамп БД может оказаться быстрым вариантом, но в долгосрочной перспективе принесет проблемы совместимости между схемой данных в базе и схемой данных у аналитиков. Как альтернативное решение может подойти событийный подход. Но стоит заранее подумать о схеме данных, версионировании и обратной совместимости между версиями.&lt;/li&gt;
  &lt;li&gt;Аналитики хотят видеть динамику по данным и делают из дампов за разные дни список изменений. Событийный обмен данными также поможет в этой проблеме.&lt;/li&gt;
  &lt;li&gt;Если в домене присутствует специфический ID с определенной структурой - сделайте эту структуру на уровне базы и приводите к этой структуре в бизнес логике. Например, у нас был &lt;a href=&quot;https://en.wikipedia.org/wiki/National_Drug_Code&quot;&gt;National Drug Code&lt;/a&gt;. Это строка которая может содержать &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxxx-xxxx-xx&lt;/code&gt; (10 знаков), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxxxx-xxx-xx&lt;/code&gt; (10 знаков), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxxxx-xxxx-x&lt;/code&gt; (10 знаков) или &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxxxx-xxxx-xx&lt;/code&gt; (11 знаков) значения. Спустя год разработки вскрылось, что система содержит три формата этого кода и часть системы поддерживает только десятизначный формат, а на одиннадцатизначном падает с ошибкой. Договорились о стандарте &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5-4-2&lt;/code&gt; (11 знаков), сделали триггер на базу данных, чтобы лефтпадить значение до 11 чисел в строке (недостающие значения забивать нулями) и констрейн в базу данных на не больше 11 символов. В бизнес логике значение через лефтпад приводим к строке 11 символов (с нулями). В таком случае продюсер присылает данные в своем формате, а мы не боимся что в бд будет не валидное значение.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Нашли опечатку или ошибку? Буду рад если &lt;a href=&quot;https://github.com/2pegramming/2pegramming.github.io/tree/master/posts&quot;&gt;пошлете PR в гитхаб&lt;/a&gt;.&lt;/p&gt;
</content>
 </entry>
 

</feed>
