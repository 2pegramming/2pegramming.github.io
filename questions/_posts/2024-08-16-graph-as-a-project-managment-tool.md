---
layout: question
title: "Как слежу за большими проектами"
categories: questions
published: true
tags:
  - project_managment
  - graphs
---

## Вопрос

<div class="question-text" markdown="1">
  > Привет!
  >
  > Вопрос: как планируешь и следишь за долгими проектами? Особенно интересно что используешь для долгих проектов, которые дляться от года и больше, потому что в какой-то момент перестаю видеть «лес» за тасками в трекере.
</div>

Давайте разбираться. Важно: я не менеджер, людьми не управляю. Отчеты по работе и планированием спринтов тоже не занимаюсь. Поэтому буду говорить с позиции solution architect и касаемо только рабочих проектов.

При этом, описываться будет личный опыт, из-за чего допускаю, что ответ подойдет далеко не всем: кто-то следит за проектами в «джире», кто-то получает результат от менеджеров. Поэтому буду рад если описанный подход либо вдохновит, либо поможет в текущей ситуации.

И еще одно уточнение: в тексте буду использовать «джира» как обобщенное слово для любого PM инструмента. О jira тоже поговорим.

## Контекст в котором приходится планировать работу

Для начала стоит описать контекст в котором нахожусь как solution architect. С этим поможет первая глава [Solution Architecture Foundations](https://www.oreilly.com/library/view/solution-architecture-foundations/9781780175676/){:target="_blank"}, в которой описываются активности роли. Из списка хочется выделить три:

- управление доставкой решения, в которое входит роадмап из текущей ситуации в будущее, где проблема решена;
- Организация процесса, в который входит коммуникации между стейкхолдерами на разные темы;
- Взаимодействие со стейкхолдерами проекта, в которое входят как получение информации, которая потом шарится будет;

Как можете понять, я не занимаюсь менеджментом разработчиков и людей (да и не хочу). Поэтому мне не надо считать сторипоинты, гадать сколько эпиков влезет в спринт и продавать [красивые графики по распределению времени работы](https://community.atlassian.com/t5/App-Central/3-tools-to-analyze-Cycle-and-Lead-Time-in-the-Jira/ba-p/1403775){:target="_blank"}. С другой стороны, во время работы необходимо понимать в каком состоянии находится проект, где затыки, объяснение почему что-то долго происходит и другие вещи, связанные с обсервабилити работы. Что бы было нагляднее, покажу на [v-model](https://en.wikipedia.org/wiki/V-model){:target="_blank"}, в какие моменты приходится наблюдать за тем, что делают другие.

{%
    include image.html
    url="/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/v-model-and-personal-managment.jpg"
    description="Дизайн, имплементация и верификация – три фазы, на которых приходится «держать руку на пульсе»"
    altdescription="dbml: code and visualisation"
%}

Т.е. задача сводится к трем вещам:
- На этапе дизайна помочь спланировать работу и провалидировать, что план понятен и устраивает каждого стейкхолдера. А также проверить, что план влезает в ресурсы и цена решения будет приемлемой;
- На этапе имплементации знать в каком состоянии находится проект и какие проблемы появляются. Плюс знать когда приступать к работе над другими частями системы (если требуется);
- На этапе верификации нужно проверить, что система будет провалидирована перед тем, как оказаться в проде;

По итогу, нужен инструмент который решает следующие проблемы:

- Помогает в быстром прототипировании этапов работы и валидации этих этапов с каждым из стейкхолдеров проекта (бизнесом и разработчиками);
- Инструмент должен работать для разных команд/отделов. Т.е. встречаются проекты, которые затрагивают от двух команд из разных отделов и необходимо синхронизировать последовательность работ между ними;
- Важно как можно быстрее понять в каком состоянии проект на выбранный момент времени, или как быстро происходит требуемая эволюция. Т.е. в идеале, нужен инструмент, который позволит работать с «концептуальной» моделью работы над проектом (о концептуальной/логической/технической модели можно прочитать [в прошлом ответе](https://pepegramming.site/questions/data-model/){:target="_blank"});
- Так как ко мне могут прийти и спросить либо почему так долго выполняются работы, либо просто спросить что происходит – нужен артефакт для стейкхолдеров, который покажу и от меня отстанут;
- Решение должно быть кросс-платформенное. Связано со спецификой работы, так как за последние четыре года использовались следующие инструменты: бейскамп, джира, редмайн, асана, миро (не спрашивайте), пяток штук для рисования ганта, гитхаб доски, трелло и другие. Если инструмент окажется вендорлоком - я не смогу решение протащить в другой проект;
- Инструмент должен хранить задачи, которые вроде как надо бы сделать, но пока не понятно как, когда и нужно ли это вообще;

Дополнительные пожелания:
- Чем меньше элементов и информации, тем лучше. Т.е. сроки, таймлайны и прочее хотелось бы убрать. Этим пусть занимаются тимлиды с командами;
- Хочется иметь инструмент для собственной рефлексии:
  - Понимать на сколько изначальные планы отличаются от того, что получилось в конце эволюции;
  - Нужна ретроспектива, что бы быстро понимать как долго делаются задачи и замечать проблемы. Плюс понимать как сильно ошибался в начале и в конце работы (видеть как много добавилось нового во время работы)

### Почему project management tools не сработают

Может показаться, что под требования подойдет любой продукт для project planning/management. На деле, подобные инструменты только усложняют работу и связано это с тем, что списки задач не работают для высокоуровневого планирования.

Проблема тут в том, что задачи редко когда связаны последовательно между собой. В качестве примера можно привести «базовую» задачу по выносу кода из монолита в новый сервис. Если сильно не упарываться, то список шагов можно представить как такую последовательность: 

```
Сделать новый сервис с копией логики существующего модуля монолита

1. поднять новую базу данных
2. поднять болванку с пустым сервисом
3. настроить деплоймент
4. настроить observability (метрики, логи, etc)
5. настроить репликацию данных из монолита в новую базу данных
6. проверить, что данные валидны и соответствуют реальности
7. реализовать бизнес логику в сервисе
8. проверить, что бизнес логика работает корректно с данными
9. перевести трафик с монолита на новый сервис
10. проверить что итоговое решение работает корректно
```

Вроде кажется, что работа последовательна и тут нечего параллелить, достаточно сделать проекты под каждый шаг и фигачить пару месяцев.  Но если представить шаги как «граф», то оказывается, что есть как минимум три трека, в которых задачи могут быть распараллелены, а сам процесс не так линеен, как кажется на первый взгляд

{%
    include image.html
    url="/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-service-extraction-final.jpg"
    description="Тот же список по выносу логики из монолита, который теперь выглядит как граф, а не последовательные работы"
    altdescription="dbml: code and visualisation"
%}

В тех инстурментах, что я знаю или использовал (jira, asana, basecamp, clubhouse, redmine, любая kanban доска, etc) нельзя быстро понять связь между задачами. Т.е. настроить и посмотреть связанные задачи можно, но в голове придется рисовать картинку выше, что отнимает время и силы. А в больших проектах, где задействуются команды из разных отделов, подобные действия могут превратиться в дни анализа. Хотя не исключаю, что я не преисполнился мудростью и плохо знаю инструменты, так как не менеджер.

{%
    include image.html
    url="/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/jira-go-brrr.jpg"
    description="Подозреваю, что прошаренные менеджеры как-то так воспринимают этот текст"
    altdescription="dbml: code and visualisation"
%}

## Мой подход

В 2019 году, пока работал в toptal, попробовал схему с графом, которая прижилась и которую использую до сих пор. Идейно подход напоминает [DAG](https://en.wikipedia.org/wiki/Directed_acyclic_graph){:target="_blank"}, который используется как визуализатор задач в пайплайнах CI/CD или ETL. Единственное отличие, граф рисую руками, вместо использования `as a code` подхода.

{%
    include image.html
    url="/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/airflow-dag-visualizator.jpg"
    description="Airflow DAG visualizator, который «рисует» шаги data flow в виде графа, где визуально понятно какая задача за какой вызывается и какой статус у каждой задачи"
    altdescription="dbml: code and visualisation"
%}

Главный плюс подхода – работает в любом инструменте. Я чаще использую lucidchart, но можно взять draw.io или аналоги, возможно даже diagram as code подойдет (не пробовал). Главное, чтобы выполнялись следующие условия:

1. Можно рисовать квадраты разных цветов;
2. Есть возможность связывать стрелками квадраты между собой;
3. Можно добавлять отдельный элемент для комментариев (в идеале стикер);
4. Наличие отдельных вкладок для версионирования (об этом дальше);

Сам процесс работы с графом состоит из трех шагов:

1. Планирование;
2. Наблюдение;
3. «Рефлексия»;

Давайте, на примере выноса кода в отдельный сервис, пройдем по каждому из шагов

### Шаг 1: планирование
> Предупреждаю: скорее всего сам план будет не корректен, но у меня цель идею показать, а не «правильно» спланировать работу.

Первым делом придется понять что за задачи нужно выполнить. В примере выносом кода в отдельный сервис можно сразу сказать три задачи которые необходимо выполнить:
- Поднять новый и пустой сервис
- Перенести логику в сервис
- Перевести трафик с монолита на новый сервис

В виде графа это будет выглядеть следующим образом:

{%
    include image.html
    url="/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-step-1-base.jpg"
    description="Каждый шаг – отдельная нода графа, связи – показывают что за чем выполнять по плану"
    altdescription="dbml: code and visualisation"
%}

Дальше наступает этап анализа, когда оказывается, что каждый из трех шагов состоит из специфичных действий: поднять новый сервис включает в себя поднятие необходимой базы, инстанса приложения, создания репозитория, настройку CI/CD, observability. При этом, без observability перевод трафика не будет иметь смысл.

{%
    include image.html
    url="/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-step-1-first-improvements.jpg"
    description="Раскрываем «большие» задачи на конкретные шаги, которые необходимо выполнить"
    altdescription="dbml: code and visualisation"
%}

Когда будут +- понятные задачи, советую отдельно подумать о двух вещах: интеграции и валидации.

Под интеграции попадает все, что связывает два элемента вместе: вызов внешнего API, перенос данных из базы в базу, вызов API внутреннего сервиса, перенос данных из старой схемы в новую схему в рамках одной бд, наполнение данными нового сервиса/новой базы и так далее. Об интеграциях забывают в планировании, но как подсказывает практика, тут больше всего риска провалиться: сорвать срок, получить не консистентность и затянуть с работой. 

А под валидации попадает вся левая часть v-model: валидация адекватности данных, которые перенесли, валидация что решение работает, валидация что сервис правильно раскатался, валидация интеграций и так далее. Также как и в интеграциях, валидации забываются и тут много рисков/проблем, которые чаще выстреливают, чем нет.

{%
    include image.html
    url="/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-step-1-integration-and-validation.jpg"
    description="Белые квадраты – интеграции и валидации о которых забывают, но которые не менее важны, чем написание кода и деплой"
    altdescription="dbml: code and visualisation"
%}

Как сделаете план, важно согласовать шаги с командой. Тут два ключевых стейкхолдера: те, кто будут выполнять работу (чаще разработчики, тестировщики, дизайнеры и так далее) и менеджеры, которые будут выбивать ресурсы под работу. Возможно граф станет еще больше или часть задач изменится, это нормально. Важно, чтобы каждый согласился работать по представленному плану.
#### Советы
- Есть риск скатиться в дробление задач на супер мелкие куски. Не вижу ничего плохого в этом, особенно если опыта мало. Подобные задачи можно схлопнуть или выкинуть на ревью. Единственное исключение – низкоуровневые технические задачи, которые стоит оставлять только если задачи супер критичные для проекта. Если нет, лучше использовать чеклисты для валидации (например сделать чеклист для изменения схемы бд с шагами и проверками);
- **Всегда** (это важно) думайте о необходимых интеграциях и валидациях, без которых проект не запустится. Помните, что есть разница между сделать и заставить работать без ошибок;
- Согласование такой же необходимый шаг, как и создание графа. Если придти и с ноги сказать кто, что и как делать будет – велик риск саботажа. Плюс другие люди могут указать о том, что вы забыли добавить или что часть работы можно выкинуть;
- Один из возможных «smell-ов» по задачам – появление задачи, которая ни с чем не связана. Т.е. у задачи может быть либо входящая, либо исходящая связь (либо две сразу), но полное отсутствие стрелок является знаком, что что-то не так и стоит посмотреть внимательно (исключение – задачи в будущее, которые важно помнить, но непонятно когда и как их делать);

### Шаг 2: наблюдение

Нудный и в тоже время важный шаг. Каждый спринт встречаемся с исполнителями, проходим по каждой задачи из графа, оставляем комментарии и добавляем новые задачи, если оказалось что они нужны. Плюс отмечаем что было сделано и что в работе на момент ревью. Для этого использую цвета: зеленый – сделали, желтый – в работе, красный – отменили.

{%
    include image.html
    url="/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/real-example-full-graph.jpg"
    description="Реальный граф связанный с рефакторингом сервиса. Комментарии оставляю как стикер, тут нет стандартизации. К сожалению шакально по причине NDA, но идею по картинке понять можно"
    altdescription="dbml: code and visualisation"
%}

Тут важно сохранять прошлую версию графа отдельно. Для этого делаю копию, ставлю текущую дату (версию) и заполняю скопированный граф

{%
    include image.html
    url="/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/real-example-graph-versions.jpg"
    description="Каждая вкладка – новая версия графа, которая изменяется"
    altdescription="dbml: code and visualisation"
%}

Благодаря такому версионированию, можно ретроспективно посмотреть как долго задачи делаются, что добавилось нового и исследовать процесс выполнения работы.

{%
    include image.html
    url="https://leonardo.osnova.io/6c44e586-3769-4c22-4270-a326d823ea8c/-/format/mp4#t=0.1"
    description="В 2020 году, Самат [написал статью](https://vc.ru/services/151374-s-pomoshyu-diagramm-mozhno-obyasnit-chto-ugodno-tem-bolee-dlya-etogo-est-klassnye-instrumenty), где показывал граф выполнения работ (в самом низу), видео как раз из статьи"
    altdescription="dbml: code and visualisation"
%}

Кроме отметок по задачам, использую секцию «Проблемы/вопросы/комментарии», куда добавляю все, о чем говорят исполнители. В будущем секция помогает в анализе и ретро.

{%
    include image.html
    url="/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/real-example-pros-cons-ideas.jpg"
    description="Пример секции «Проблемы/вопросы/комментарии» из проекта выше. Красное – проблемы, зеленое – комментарии, желтым обозначаю вопросы"
    altdescription="dbml: code and visualisation"
%}

По итогу, получаем гибкий инструмент, который можно использовать для ответа «в каком статусе проект» и «почему долго делается ХХХ?!».

#### Советы

- Как я уже сказал - наблюдение важный шаг. Но при этом и сложный из-за регулярности и желания пропустить и забить. Советую хотя бы раз попробовать выполнить проект не забивая на этот шаг и после уже решать, подходит подход или нет;
- Версионирование графа – ключ к успеху, особенно для шага с анализом;
- Не бойтесь добавлять новые задачи. Невозможно сразу описать план идеально. В моей практике, в итоговой версии графа оказывается на ~40% больше задач, чем в изначальной версии;
- Секция с проблемами не обязательна, но помогает сохранить контекст на будущее;
- У каждого стейкхолдера должен быть доступ к графу в любое время. Разработчики смогут быстро посмотреть что делать дальше, а у бизнеса появится обсервабилити над проектом в любой необходимый момент времени;
- В теории, можно раз в неделю открывать «джиру» и отмечать самому что в работе, а что планируется. Но у такого подхода есть минус – шаги не просматриваются исполнителями и нет контакта, благодаря которому можно поговорить о косяках в планировании или проблемах в реализации;

### Шаг 3: «рефлексия»

Это опциональный пункт. Идея в том, что по завершению проекта, любят устраивать ретро. Если проект длится больше 6 месяцев – шансы вспомнить что было в начале нулевые. Но благодаря графу можно быстро посмотреть как долго делались задачи, выписать какие проблемы возникли (с решениями) и посмотреть на сколько ожидания разошлись с реальной работой.

## Advanced использование графа

Чтобы накидать ещё больше пользы в ответ, решил еще добавить секцию связанную с анализом. Тут будут идеи из личного опыта, поэтому не ждите хардскилового менеджмента.

### Поиск проблем

В секции с шагом планирования упоминались «висящие» задачи. Кроме этого есть еще один «smell». Связан он с ситуацией, когда задача блокирует другие задачи, например вот так:

{%
    include image.html
    url="/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-task-blocker.jpg"
    description="Центральная задача блокирует правые. При этом, центральная задача ждет левые"
    altdescription="dbml: code and visualisation"
%}

Проблема тут в том, что нельзя распараллелить выполнение работ из-за центрального блокера. Это не всегда плохо, но советую подумать, как можно блокер разбить на несколько задач, которые позволят разблокировать параллельность.

### Как сроки/ресурсы считать

Сразу скажу, делал такое 2 раза в жизни, но оба раза срабатывало. Идея в том, что сначала проставляется оценка задачам, после чего планируется, сколько команд надо для работы. В результате можно предположить сколько людей и в какой последовательности будут происходить работы. Благодаря чему заранее выбить капасити каждой команды и предположить сколько времени займет работа (немного точнее, чем просто «пальцем в небо»).

{%
    include image.html
    url="/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-resource-planning.jpg"
    description="Что бы вынести сервис из монолита нужно 4 команды (каждый цвет – отдельная команда), причем левые три команды могут работать параллельно, а последняя нужна только в самом конце и до реализации бизнес логики может отдыхать"
    altdescription="dbml: code and visualisation"
%}

Подход полезен в двух случаях: когда надо посчитать «пальцем в небо» стоимость и когда проект реализуется сразу несколькими командами и нужно кросс командное взаимодействие.

### Как понять, почему по срокам не укладывайтесь

Специально для ситуаций, когда бизнес не понимает, почему изначальный коммит был на полгода, а прошло уже 2 года и проект не приносит денег. Благодаря графу можно наглядно показать как увеличился пул задач или какие задачи долго висели в блоке. Судя по опыту, это выглядит намного нагляднее для не-менеджеров, чем графики «джиры».

Плюс, если за 2-3 спринта задачи только добавляются в граф, а прогресса нет – время бить тревогу и пинать менеджмент/бизнес, что проблемы начались.

### Используем реальный анализ графов

Так как это граф, можно применить научные методики анализа из теории графов. Но тему не раскручивал, поэтому оставлю идею для самостоятельного изучения. Если что-то придумаете, напишите пожалуйста, буду рад обсудить.
### Как использовать project management tools с таким графом

Если взять [идею conceptual/logical/physical data models](https://pepegramming.site/questions/data-model/#data-modelling){:target="_blank"}, то можно представить граф как концептуальную модель, PM tool как логическую, а реализацию в виде кода как физическую

{%
    include image.html
    url="/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/conceptual-logical-phisical-models.jpg"
    description="Наглядное сравниение каждой data model и планирования работы"
    altdescription="dbml: code and visualisation"
%}

Из этого сравнения получается, что есть условный «эпик», который описывается графом. Каждая нода графа – отдельный проект в «джире», а каждый таск из проекта – отдельный PR/MR, который на шаг ближе закрывает эпик.

Благодаря такому разделению, можно использовать viewpoints для каждого стейкхолдера: список задач для команды, гант диаграмму по эпику, статус проекта для бизнеса, задачи для конкретного разработчика и так далее.

А если используете [трассировку требований](https://habr.com/ru/articles/831922/){:target="_blank"}, сможете линковать между собой. Единственный минус подхода, для графа нет автоматизации.

## Плюсы и минусы использования графа для планирования
Начну с плюсов:

- Появляется хоть какая-то системность в планировании и выполнении проекта. Благодаря чему каждый из стейкхолдеров может рассматривать [либо подсистемы либо надсистемы](https://creatime.me/MediaLibrary/UchebnyeMaterialy-2/Stati/PodsistemyI){:target="_blank"} в зависимости от собственных интересов;
- Лично доволен таким подходом, за пять лет проблем не было;
- Когда проектов больше пяти – помогает быстро получить контекст в каком состоянии реализация каждого;
- Судя по опыту, бизнес любит такую наглядность. Разработчики страдают от того, что сложно хайлевел задачи декомпозировать и понять что за чем – поэтому декомпозицию можно обсудить заранее. Пару раз ребята говорили спасибо, ибо понимали что их дальше ждет и могли заранее подготовить код к будущей работе;
- Из-за концептуальности и простоты решения – супер гибкое решение. Выбираете удобный вам инструмент для диаграмм и работаете. Только помните, что в случае вайтбордов придется решить, как версионировать графы. Плюс, с добавлением трассировки требований, можно быстро делать кросс линки между задачами и другими артефактами работы;
- Концептуальный план делается быстро и легко правится. После можно сделать «логический» план в виде задач или эпиков в джире и сразу начать работать, вместо того, что бы тратить время на реализацию концептуального плана в PM tool;
- Хорошо показывает себя в проектах, где есть четкая цель, которая не поменяется через пол года и которую долго делать. Например, когда знаете, что надо вынести сервис, отрефакторить кусок кода или реализовать фичу с определенным DoD. Один раз сделали, знаете конец и дальше работаете, раз в спринт сверяясь;
- Судя по опыту, работает для ретро лучше, чем список задач из джиры (возможно ошибка выжившего). Связано с тем, что подход добавляет концепцию «журнала» связанного с проблемами, хорошими вещами и вопросами. После чего, на ретро, открываем нужный спринт и смотрим, что там происходило;
- Не совсем о подходе, но скорее в целом о полном плане работ: включается [мышление второго порядка](https://fs.blog/amateurs-professionals/){:target="_blank"}. Особенно, если план валидировать через результат каждого шага + вопроса "что произойдет после этого";

После плюсов может показаться, что инструмент серебряная пуля, но минусов у графа тоже много:

- К концу релиза начинается каша и велик риск забить на диаграмму. Нужен высокий уровень самоконтроля и постоянно пушить исполнителей. Из этого следует главный минус – без контроля и ревью, подход не работает;
- Не сработает, когда высокая неопределенность в работе. Т.е. когда сделав задачу, планы меняются и становятся другими, например сегодня выносите сервис, а завтра оказывается, что денег больше нет и надо гипотезы делать по две штуки в день;
- Это придуманный подход, его нет нигде. Поэтому допускаю проблемы с объяснением и обучением, так как нет описания. Т.е. кроме куска из курса о системах и этого текста, в интернете информации нет (если ошибаюсь и знаете аналоги, буду рад ссылке);
- Придется заморочиться с трассировкой требований, если нужна интеграция с проектной документацией. Это лишняя работа и цена;
- Подход придется продавать бизнесу, менеджерам и исполнителям работы. Продажа подхода – одна из причин, почему появился этот текст;
- Из инструментов – кривые плагины для конфлюенса и аналогов, либо делать руками. Если используете диаграммы - нет фильтрации по проектам/командам и автоматической генерации других viewpoints;
- Подход не о сроках и датах. Если сроки важны, придется либо делать отдельный viewpoint (например ганта), либо использовать другой инструмент;
- Менеджерам будет не хватать асайнов на людей, фильтрации и сроков/статусов;

## Выводы

Использование подобного графа оправданно, если необходим «концептуальный» уровень для планирования проектов, а условная «джира» не справляется. Так как подход максимально гибок, можно использовать любые инструменты для диаграмм или вайтбордов (можно даже лист бумаги и ручку взять). Важно помнить, что стоит делать квадраты похожими на проект из GTD и следить за связями. При этом, кроме работы над планом, стоит потратить время на регулярное обновление статуса по проекту, что в будущем окупится аналитикой и ретро.

Ну и еще раз напишу, что описанный подход планирования и слежения за проектами не единственный и не серебрянная пуля. Ну и помните главное правило: если устраивает текущая ситуация в компании – лучше ничего не трогать и не гнаться за новым подходом, ради подхода.

Кроме этого, если используете «концептуальный» вью в PM инструментах, буду рад, если поделитесь секретом в комментариях. А если захотите воспользоваться описанным выше подходом и останутся вопросы или захотите поделиться фидбеком – буду рад в два раза больше.

## Доп ссылки

Инструменты, представляющие работу над задачей в виде графа:

- [Intention](https://about.i.ntention.app){:target="_blank"}, работает на андроиде и в вебе (если понял правильно). [Обсуждение на ycombinator](https://news.ycombinator.com/item?id=22591311){:target="_blank"} тоже присутствует;
- [Приложение за которым долго слежу](https://eyen.fr/taskheat/){:target="_blank"} и от которого были большие ожидания для персональных проектов, но так и не зашло. Возможно попробую еще раз через пару лет. Работает только на apple устройствах и больше о персональных проектах, т.е. конкурент для things3/todois/ticktick/etc;
- [PM tool, о котором никогда не слышал](https://www.gameplan.global){:target="_blank"} (нашел, пока ответ писал). Кажется, что если используете что-то другое, переехать на «нонейм» решение будет сложно;
- [Плагин для редмайна](https://www.easyredmine.com/redmine-wbs-plugin){:target="_blank"} с похожей функциональностью;
- Два плагина для джиры с похожим функционалом: [первый](https://marketplace.atlassian.com/apps/1216207/issue-links-viewer){:target="_blank"} и [второй](https://whiteboards.io){:target="_blank"};

