---
layout: question
title: "Как перевести EventStorming модель в код"
categories: questions
published: true
tags:
  - event_storming
  - code
---

## Вопрос

<div class="question-text" markdown="1">
> Сделали EventStorming модель, а дальше ступор. Не понимаю как стикеры представить в коде. Пока выглядит так, что делаю двойную работу. Как выйти из тупика?
</div>

На данный вопрос можно было бы ответить одним предложением: «берем команды и события, переводим их в тест-кейсы и «болванки» с бизнес логикой, по полученным тест кейсам заполняем код «болванок», катим в прод». Но так как вопрос задают часто и абстрактный ответ не подойдет, постараюсь подробно описать как перевести Event Storming (далее ES) в код, какую пользу можно получить и как модель помогает в тестах.

Текст получился дискуссионный, так как не встречал «канона» и не знаю «как правильно». Поэтому ответ начну с длинного дисклеймера.

> В посте ниже будет пример того, как сам маплю модель на код. Поэтому, не факт, что описанный подход будет полезен, но постараюсь также пофантазировать, как это можно сделать в clean architecture, MVC фреймворках, приложениях с GraphQL и расскажу куда смотреть, если хотите каноничный [domain model pattern](https://martinfowler.com/eaaCatalog/domainModel.html){:target="_blank"}. 
> 
> Допускаю, что перегнул с детальностью и повторением одного и того же в ответе, но решил, что лучше подробно и с примерами, чем «берете стикеры и пишете код» или «вот гитхаб, смотрите сами».
> 
> Держите в голове, что ответ писался для того, чтобы донести 3 главные мысли:
> 
> 1. Модель помогает не только при использовании [domain model паттерна](https://martinfowler.com/eaaCatalog/domainModel.html){:target="_blank"} в коде (это который про value objects, entity, aggregates), но в и  других подходах, будь то MVC, использование сервис объектов, функциональные подходы и так далее;
> 2. Если уже используете ES – воспользуйтесь знаниями, добытыми из моделирования, вместо того, чтобы делать бизнес логику по своему, используя самостоятельно придуманные термины. Благодаря этому получите ubiquitous language о котором столько говорят и пишут;
> 3. Описанный подход стоит воспринимать как один из вариантов написания кода. Тестом можно вдохновиться, если не понимаете с чего начать. При этом, допускаю, что у вас может быт  другое представление о том, как реализация ES модели должна выглядеть – давайте обсуждать. Либо кидайте примеры с гитхаба, постараюсь сделать отдельную секцию с другими способами реализации;
> 
> Еще одно уточнение – примеры будут на псевдокоде [ruby](https://www.ruby-lang.org/en/){:target="_blank"}, который постараюсь упростить и не показывать никакой сложной или специфичной бизнес логики или уникальных деталей из языка/фреймворков. Это сделано, чтобы донести идею, а не написать идеальное приложение. Если возникнут вопросы или недопонимание – тоже пишите. А если захотите сделать примеры под другие языки – буду только рад и добавлю больше примеров в ответ.

## Что еще за EventStorming

Данная часть нужна для тех, кто в первый раз слышит про EventStorming. Если знаете что это такое и (или) применяете подход в работе – можно пропустить, тут только краткая справка, без откровений.

EventStorming [придумал Альберто Брандолини в 2012–2014 годах](https://blog.avanscoperta.it/2014/02/12/introducing-event-storming/){:target="_blank"}. Это воркшоп, идея которого заключается в том, чтобы запереть всех сотрудников, которые работают над системой, в одной комнате, дать им инструмент для выгрузки знаний из головы. А на выходе получить схематичное описание поведения системы, с которым согласен каждый участник данного мероприятия.

Важно уточнить, что это не технический воркшоп, тут важно определить доменную модель и поведение системы, а не обсудить в каком месте будет использоваться adapter паттерн или event sourcing.

Краеугольный камень модели из воркшопа – события, которые появляются в системе. Под событиями подразумевают результат любого действия, т.е. это глагол в прошедшем времени, которое появляется как результат выполнения системой бизнес команды, которую запускает либо актор, либо система автоматически реагирует на события запуском команд по условию. 

{%
    include image.html
    url="/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-concept-explonation.jpg"
    description="Модель того, как работает система в терминах EventStorming"
    altdescription=""
%}

Кроме этого, в ES выделяют три уровня детализации системы: **big picture**,  **process modeling** и **software design**. В ответе остановлюсь на process modelling.

{%
    include image.html
    url="/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/event-storming-levels.jpg"
    description="Уровни детализации в ES, в каждом используются свой набор стикеров и у каждого уровня собственные цели"
    altdescription=""
%}

Благодаря тому, что process modelling является графической визуализацией бизнес процессов, а не технических алгоритмов или кусков реализации в коде, EventStorming может помочь с последующей реализацией бизнес процессов в коде. Либо же сгенерировать код из модели, о чем тоже поговорим. А получив набор изолированных commands и queries – можно изолировать код, тем самым улучшить maintainability/modifiability и testability кодовой базы.

Если хотите подробнее разобраться как проводить ES, то на выбор либо [книга Альберто (не дописанная)](https://www.eventstorming.com/book/){:target="_blank"}, либо [первый урок курса, который писал](https://tough-roadway-bb5.notion.site/1-1-6adfeb2e07eb4269b5966ffb742d7fad#3ed1be8a4adf4dbc8320c00db41eac42){:target="_blank"}, либо [ссылки из интернета](https://habr.com/ru/companies/oleg-bunin/articles/537862/){:target="_blank"}, либо гугл.

## Мапим EventStorming на код

В качестве примера рассмотрим кусок выдуманной ES модели, который описывает часть интернет магазина: работу с корзиной, автоматическое пополнение склада, отчеты и часть работы сборщиков. 

{%
    include image.html
    url="/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-example.jpg"
    description="Пример с магазином, в котором собрал стикеры из process modelling"
    altdescription=""
%}

А в качестве структуры приложения буду использовать аналог layered стиля, состоящий из трех слоев:

- Транспортный слой, который является либо интерфейсом для различных видов клиентов (API/web/telegram/WS/etc), либо background processing (у рубистов это [sidekiq](https://github.com/sidekiq/sidekiq){:target="_blank"}, у питонистов с натяжкой [celery](https://github.com/celery/celery){:target="_blank"} и так далее), либо консьюмером для брокера сообщений;
- Слой с логикой, в которой будет реализация бизнес логики которую смоделировали в ES;
- Persistence слой, в котором кроме бд могут быть relations из datamapper паттерна или иные абстракции связанные с персистенсом;

{%
    include image.html
    url="/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/software-arch-breif-view.jpg"
    description="Три слоя, каждый слой отвечает за свою часть работы приложения. Транспортный вызывает контексты в которых реализована бизнес логика из ES. Например API для админки и для клиентов будут обращаться в одинаковый набор контекстов"
    altdescription=""
%}

В контексте изначального вопроса, о маппинге ES на код, интересует первые два слоя: логика и транспорт, при этом транспорт это не обязательно http запросы. Как пример: добавление товара в корзину можно  как через веб интерфейс, так и через HTTP API, либо через tg бота, либо вообще с помощью CLI. Из этого следует, что одну и туже бизнесовую логику, акторы могут вызвать используя подходящие по контексту виды транспорта. Т.е. описанная модель в ES будет работать для любых проектов: что тг ботов, что веба, что CLI инструментов, что асинхронных систем, что для вебсокетов и так далее.

### Commands

> Дальше по тексту будет использоваться термин команда, который в коде, в зависимости от языка и экосистемы может иметь другие значения. Для объяснения буду считать что бизнесовая команда мапится на бизнес логику, например сервис объект/операцию/юзкейс/команду.

Самое очевидное – команды. Это действия, совершает актор над системой, либо система автоматически выполняет как реакция на то, что произошло.

{%
    include image.html
    url="/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-only-commands.jpg"
    description="В нашем примере пять команд, четыре из которых вызываются двумя акторами, а одна команда автоматически срабатывает при успешном чекауте"
    altdescription=""
%}

Благодаря ES можно сразу назвать каждую из команд используя «общий язык» (Ubiquitous Language) найденный в процессе работы над EventStorming.

- Названия команд вокруг заказа, которые вызывает покупатель: `AddItemToOrder`, `RemoveItemFromOrder` и `Checkout`;
- Название команды пикера, который отмечает сборку заказов: `CollectOrder`;
- Название команды, которая автоматически заказывает недостающие продукты на склад: `RequestMissingProduct`;

Получив название для функции или объекта, делаем «болванку», в которой реализуется алгоритм действия.

```ruby
# название контекста
class ContextName
  class Command
    # название команды, которую мы обнаружили в ES модели
    class AddItemToCart
      def call(params)
        # тут условная реализация алгоритма добавления продукта в заказ
        order_repo.add_product(order_id, product_id, quantity)
      end
    end
  end
end
```

### Events

В случае реализации события в коде, можно предположить, что событием будет результат, который вернула команда. Т.е. если актор выполнил чекаут, получим заказ, который оформили:

```ruby
command = ContextName::Command::Checkout.new
# результат команды и будет событием, которое мы отобразили в ES
checked_out_order = command.call(params)
```

Если на полученное событие система не реагирует автоматически, то либо возвращаем результат актору как read model, либо делаем что надо.

Но, возникают ситуации, когда система реагирует на событие автоматическим запуском другой команды. В данном случае придется рассмотреть три случая:

- действие происходит в одном процессе (монолите) и можно вызвать команду на прямую;
- действие происходит в двух сервисах, но связь асинхронная;
- действие происходит в двух сервисах, но связь синхронная request-response;

Рассмотрим каждый на примере чекаута и дозаказа товаров.

{%
    include image.html
    url="/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-example-chain-of-events.jpg"
    description="Кусок модели, на котором рассмотрим как система автоматически запустит команду как реакцию на событие. О полиси поговорим в следующей части ответа"
    altdescription=""
%}

#### Ситуация 1: Когда весь код в монолите

{%
    include image.html
    url="/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-example-chain-of-events-monolith.jpg"
    description="Две команды в одном монолите, общаются прямым вызовом"
    altdescription=""
%}

Тут важно определить что за «событие» вернула команда. Если оформление не получилось, возвращаем результат покупателю, а если заказ оформился - вызываем другую команду из нужного контекста:

```ruby
command = ContextName::Command::Checkout.new
# результат команды и будет событием, которое мы отобразили в ES
result = command.call(params)

# получив результат, разбираемся, что это за "событие" и в случае успешного чекаута 

if result.order_checked_out?
  # если результат "Заказ оформлен" - мы вызываем следующую команду автоматически
  ContextName::Command::RequestMissingProduct.new.call(checked_out_order)
else
  # если результат "Заказ не оформлен" - ничего не делаем
end
```

#### Ситуация 2: Когда между сервисами асинхронное событийное взаимодействие

{%
    include image.html
    url="/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-example-chain-of-events-async.jpg"
    description="Каждая команда в своем сервисе, а связь между ними асинхронная"
    altdescription=""
%}

Во первых, получаем бонус: берем готовое название события, которое будет продьюситься из первого сервиса во второй (`OderCheckedOut`). И, [решив какой размер события нужен](https://pepegramming.site/questions/make-events-small/#хочу-короткие-сообщения-потому-что-так-принято){:target="_blank"}, отправляем событие в брокер.

Во вторых, коммуникация будет похожа на то, что было в первой ситуации, только вместо прямого вызова команды - отправляем событие в брокер, а из транспортного слоя консьюмера вызываем нужную команду:

```ruby
# В сервисе продьюсере
if checked_out_order.success?
  # если результат "Заказ оформлен" - мы отправляем событие в брокер, после чего оно консьюмится и вызывается следующая команда
  broker.produce(
    topic: 'shop',
    event_name: 'OderCheckedOut',
    event_data: checked_out_order
  )
else
  # если результат "Заказ не оформлен" - ничего не делаем
end

# В сервисе консьюмере
class Transport
  class BrokerConsumer
    def consume(event)
      case event.name
      when 'OderCheckedOut'
        ContextName::Command::RequestMissingProduct.new.call(event.checked_out_order)
      when '...'
        # ...
      end
    end
  end
end
```

#### Ситуация 3: Когда между сервисами синхронное request-response взаимодействие

{%
    include image.html
    url="/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-example-chain-of-events-sync.jpg"
    description="Опять два сервиса для двух команд, но теперь связь синхронная (http, rpc, etc)"
    altdescription=""
%}

Реализация аналогична первым двум ситуациям, только связь синхронная: получаем результат, определяем что за «событие», дергаем сервис через клиентскую библиотеку, либо на прямую по эндпоинту. Если используется RPC – название процедур будут названием команд. Идейно выглядит следующим образом:

```ruby
if checked_out_order.success?
  # если результат "Заказ оформлен" - мы вызываем команду "Заказать недостающие товары у поставщика" в складском сервисе
  result = warehouse_service.request_product(checked_out_order)
  # в данном случае результатом вызова будет событие "товары заказаны" или любое другое, которое было указано в es
else
  # если результат "Заказ не оформлен" - ничего не делаем
end
```

### Actors

Так как акторы это те, кто работают с системой, то ES поможет определиться с набором ролей или UI, который необходим приложению.

Для этого стоит выписать каждого актора, который будет взаимодействовать с системой, после чего можно под каждого сделать уникальный UI со необходимым набором действий (если требуется).

{%
    include image.html
    url="/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-example.jpg"
    description="В рассматриваемом примере 3 актора: покупатель, сотрудник склада и маркетолог. Следовательно стоит подумать о трех видах UI, для каждого из акторов"
    altdescription=""
%}

Кроме этого, информацию об акторах можно использовать для работы над авторизацией: один актор == одна роль (если используется RBAC). А после определения ролей можно определить кто какое действие над системой может выполнить.

### Policies

Полиси (фиолетовый стикер) – условие, при котором система автоматически запустит команду, как реакцию на событие. Т.е. если для выполнения автоматического действия надо чтобы не только событие произошло, но и было удовлетворено требуемое условие.

Я знаю и использую два варианта реализации полиси в коде:
- Когда полиси реализуется вне кода команды;
- Когда полиси реализуется в коде команды;

Если для условия надо ходить в бд или данных из события не хватает – выбираю первый. Если события хватает и нет необходимости в походе в БД – выбираю второй.

_**Дополнение:** существует еще один вариант, когда для полиси делается как доп абстракция, которая вызывается перед командой. Но кажется, что это уже будет перебор, хотя такой вариант тоже допускаю, но в статье рассматривать не буду._

#### Ситуация 1: Когда полиси реализуется вне команды

Вернемся в пример, когда результат одной команды вызывает другую команду. 

```ruby
if checked_out_order.success?
  # если результат "Заказ оформлен" - мы вызываем следующую команду автоматически
  ContextName::Command::RequestMissingProduct.new.call(checked_out_order)
else
  # если результат "Заказ не оформлен" - ничего не делаем
end
```

Тут стоит проверить, хватает ли на складе продуктов, если да - ничего делать не надо, а если нет - придется дозаказывать. Если полиси вызывается вне команды, то условие придется реализовывать перед вызовом команды (например в транспортном слое):

```ruby
if checked_out_order.success?
  # если продуктов осталось меньше N - вызываем заказ недостающих товаров
  # если товаров больше N - ничего не делаем и не вызываем команду
  product_count = warehouse.count_of_product(checked_out_order.product_id)
  if product_count < N
    ContextName::Command::RequestMissingProduct.new.call(checked_out_order)
  end
else
  # если результат "Заказ не оформлен" - ничего не делаем
end
```

В данном примере используется прямой вызов куска кода, но давайте рассмотрим вариант распределенной системы с 2+ сервисами.
#### Ситуация 1.2: Когда система распределенная

Так как полиси относится к команде, то логичнее делать команда в сервисе, к которому относится команда.

{%
    include image.html
    url="/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-example-chain-of-events-async.jpg"
    description="Я использовал картинку с асинхронной коммуникацией, но в синхронной будет тоже самое"
    altdescription=""
%}

В этом случае условие из полиси придется реализовывать в консьюмере (или в экшене контроллера для синхронного вызова).

```ruby
# В сервисе консьюмере
class Transport
  class BrokerConsumer
    def consume(event)
      case event.name
      when 'OderCheckedOut'
        if product_count < N
          command = ContextName::Command::RequestMissingProduct.new
          command.call(event.checked_out_order)
        end
      when '...'
        # ...
      end
    end
  end
end

```

#### Ситуация 2: Когда полиси реализуется в команде

В случае, когда полиси реализуется как часть команды – в начале команды делаем проверку:

```ruby
class ContextName
  class Command
    class RequestMissingProduct
      def call(order)
        # наше полиси - если товара осталось меньше N на складе - дозаказываем
        count_of_product = warehouse_repo.product_count(order.product_id)

        if count_of_product < N
          # реализация алгоритма заказа доп продуктов в магазин
        else
          # сразу отдаем результат, что мол все ок и ничего делать не надо, т.е. мы не вызовем команду
        end
      end
    end
  end
end
```

  Единственное, тут возникает вопрос, что такая команда возвращать должна. Для асинхронного вызова скипается код, а для синхронного – failure результат, который говорит, что ничего не произошло. Но тогда детали имплементации вырываются вне команды, что может говорить о текущих абстракциях. Поэтому иногда стоит возвращать что-то в духе «что надо – дозаказали».
### External systems

С точки зрения имплементации в коде – вызываем из команды нужную внешнюю систему и работаем с полученным результатом. Где результатом будет событие, которое внешняя система генерирует в результате работы.

{%
    include image.html
    url="/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-example-external-system-with-system-event.jpg"
    description="Красным маркером показал событие, которое вернется обратно в команду при синхронном вызове внешней системы"
    altdescription=""
%}

В коде вызов выглядит следующим образом:

```ruby
class ContextName
  class Command
    class RequestMissingProduct
      def call(params)
        # реализация алгоритма заказа доп продуктов в магазин
        
        # в данном случае мы делаем запрос во внешнюю систему вендора, у которого заказываем товар
        # а request_status будет «событием», которое возвращает внешняя система
        request_status = Vendor::HTTP::Client.request_product(product_id, quantity)
        # продолжение реализации алгоритма заказа доп продуктов в магазин
      end
    end
  end
end
```

### Read models

Рид модель (зеленый стикер) – данные, которые нужны актору, чтобы принять решение о взаимодействии с системой. Например, не получив актуальную информацию по корзине (товарам и итоговой стоимости) – будет сложно принять решение, оформлять заказ или нет. А не зная информацию о товаре, будет трудно понять, стоит товар добавить в заказ или нет.

Тут три ситуации, которые рассмотрим:
- когда актору нужна информация из того же монолита, где вызывается команда и данных из события хватает;
- когда актору нужна информация из того же монолита, где вызывается команда, но данных из события не хватает и нужно «дообогащение»;
- когда актор взаимодействует с рид моделью из другого сервиса;

_**Дополнение:** в [CQR/CQRS присутствуют ограничения на возвращаемый результат командой](https://vladikk.com/2017/03/20/tackling-complexity-in-cqrs/){:target="_blank"}, а данные должны подтягиваться из query. Так как мы не говорим о каноничной реализации паттерна, то я допускаю вариант с получением рид модели из события команды, как популярный. Если планируете реализовывать паттерн – первую ситуацию можно проигнорить._
#### Ситуация 1: Когда рид модель нужна в монолите и данных из события хватает

Кажется, что распространенный случай. Например, в «оформление заказа» можно предположить, что события с результатом оформления заказа хватит, чтобы фронтенд смог, используя изначальный заказ, сделать страницу чекаута.

Т.е. в коде возвращаем результат:

```ruby
def http_action
  command = ContextName::Command::Checkout.new
  # результат команды и будет событием, которое мы отобразили в ES
  result = command.call(params)

  # используем результат команды, чтобы показать его как рид модель
  render: result
end
```

А в UI, используя результат, делаем полноценную read model со статусом и наполнением заказа из информации, что осталась на фронте

{%
    include image.html
    url="/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-example-read-model-as-response.jpg"
    description="Информацию о статусе заказа можно получить из события «заказ оформлен», а информацию о заказе можно либо получить из фронтового стейта, либо передать  информацию как часть события «заказ оформился»"
    altdescription=""
%}

#### Ситуация 2: Когда рид модель нужна в монолите, но данных не хватает

Если актору нужно получить данные, которые не вытащить из события, придется как минимум сходить в базу данных. Для этого я добавляю отдельную абстракцию `query`, в которой происходит получение данных. Не обязательно использовать `query` как название, это личная привычка.

```ruby
class ContextName
  class Query
    class ShowOrder
      def call(params)
        # любое получение данных, которые надо показать актору, в нашем случае - показ заказа перед чекаутом
        db.select(order_id)
      end
    end
  end
end

```

Пример простой, поэтому query может показаться избыточной абстракцией. Но если добавить фильтрацию, показ данных под роль или сложный поиск с дообогащением из другой БД, абстракция поможет изолировать получение данных.

#### Ситуация 3: Когда данные для рид модели нужны в другом сервисе

Тут главный вопрос, какой подход в коммуникации использовать. Сам предпочитаю использовать модель коммуникаций, описанный в "[Building microservices](https://www.oreilly.com/library/view/building-microservices-2nd/9781492034018/){:target="_blank"}" (Chapter 4. Microservices Communication Styles, Styles of Microserivces Commuinication). Поэтому распишу что делать для каждого из трех подходов: request-response, event-driven и common data.

{%
    include image.html
    url="/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/communication-types.jpg"
    description="Модель видов коммуникации в распределенных системах, которую использую для разделения коммуникаций в распределенных системах"
    altdescription=""
%}

##### Request-response

Тут два варианта:
- Либо данные отправляются как запрос в сервис которому данные нужны. В этом случае сервис потребитель сохраняет данные локально, а потом использует когда надо;
- Либо сервис, которому нужны данные, запрашивает данные из сервиса с командой/событием;

{%
    include image.html
    url="/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/query-req-res-communication.jpg"
    description="В первом случае данные отдаются в место, где данные потребуются, во втором – запрашиваются из места, где данные нужны"
    altdescription=""
%}

Единственное, убедитесь, что с static и stamp coupling все ок.

##### Event-driven

Cервис отправляет асинхронное событие, после чего событие консьюмится в сервисе, где нужны данные и либо сохраняется для дальнейшего использования, либо используется сразу.

{%
    include image.html
    url="/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/query-event-driven-communication.jpg"
    description="Продьюсится событие, которое обрабатывается сервисом потребителем и сохраняется в БД. После чего, рид модель достает нужные данные из базы"
    altdescription=""
%}

##### Common data

Сервисы используют общий персистенс, после чего, сервис достает необходимые данные из общей базы:

{%
    include image.html
    url="/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/query-common-data-communication.jpg"
    description="Сервис потребитель даже не будет знать откуда данные взялись"
    altdescription=""
%}


## Варианты реализации в других подходах

Так как понимаю, что вариант написания кода выше может отличаться от того, что принято в других проектах или языке/фреймворке, то опишу как бы реализовывал маппинг ES в код для каждого из «популярных» способов.

### Генерация кода по ES модели

Если самому писать код по ES моделе лень, можно попробовать воспользоваться генератором. Единственная проблема – работает только с джавой и котлином (для других экосистем решений не знаю). Для этого можно воспользоваться [xoom-designer](https://docs.vlingo.io/xoom-designer#modeling-with-the-xoom-designer){:target="_blank"}, который сгенерирует проект с нужными абстракциями.

Плюс, слышал лайфхак связанный с archimate (лично не проверял). Для этого придется [реализовать ES модель в archimate](https://dckms.github.io/system-architecture/emacsway/it/ddd/ddd-in-practice/event-storming/archi.html){:target="_blank"}. После можно будет сделать экспорт модели в csv файл, а полученный файл использовать для проверки тестов, кода и для fitness functions.

### MVC

В отличии от кода, который написал выше, в MVC абстракций меньше: model, view, controller. Так как редко видел чистые MVC проекты, добавлю еще две абстракции: service и query объекты.

- **Read model** – три возможных варианта: реализация логики в контроллере (GET запросы) (о «качестве» кода не говорим), реализация логики как метода модели и отдельный query object;
- **Команда** – три варианта, аналогичных read model: реализация в контроллере (POST, PUT, PATCH, DESTROY запросы), реализация в модели и service object;
  - Вызовы между командами делаются аналогично примеру выше;
- **Внешние системы** – никакого отличия от примера выше;
- **Полиси** – аналогично примеру выше;

В случае MVC фреймворков стоит учитывать, что бизнес логика и транспортный слой разделены (даже без явного указания этого в коде). Т.е. помнить, что экшен =/= команде, просто нет явной границы между командой и транспортом в реализации.

### Clean architecture

Держите в голове, что я не эксперт в clean architecture, поэтому могут быть ошибки. Но, в моей голове, выглядит маппинг следующим образом:

- **Read model** – располагается в infrastructure layer, если правильно концепт понимаю;
- **Команда** – use-case. Название для use-case берем из названия команд;
  - Вызовы между командами делаются аналогично примеру из основной части ответа;
- **Внешние системы** – из use-case;
- **Полиси** – аналогично примеру из основной части ответа;

### GraphQL

Так как GraphQL разделяет query и mutation (команды) по дефолту, то можно не думать:

- **Read model** – query. Единственное, стоит подумать о том, какие акторы какую часть схемы будут видеть (либо авторизацию сделать под актора, либо отдельную схему под каждого из акторов)
- **Команда** – mutation. Причем названия мутаций берем из названий команд
- **Внешние системы** – аналогично примеру из основной части ответа;
- **Полиси** – скорее всего – только часть мутации (если есть варианты лучше - пишите);

### Domain model pattern

Если используете в проекте [domain model pattern](https://martinfowler.com/eaaCatalog/domainModel.html){:target="_blank"}, то советую посмотреть [статью из интернета о том, как замапить EventStorming на domain model](https://ibm-cloud-architecture.github.io/refarch-eda/methodology/domain-driven-design/){:target="_blank"}. Либо почитать [Learning DDD](https://www.oreilly.com/library/view/learning-domain-driven-design/9781098100124/){:target="_blank"}, где в справочных материалах [приводился пример маппинга](https://github.com/vladikk/learning-ddd/tree/main/wolfdesk/eventually-wolfdesk/eventually){:target="_blank"}.

## Бонус: тестирование 

Дисклеймер: в данном случае будет только о black box testing. В случае, когда тестируется реализация, а не поведение, ES модель вряд-ли поможет, кроме как названиями команд/событий.

Тут можно сослаться на Альберто, который [приводил пример, как из ES мапить на BDD](https://www.youtube.com/live/v4xLxmpAFdI?t=3090){:target="_blank"}. Но, ES подойдет и в «обычном» тестировании, так как уже готово описание поведения. Т.е. описание того, что должны делать команды и список результатов. Это поможет в black box тестах команд, так как можно сразу понять кто и что будет вызывать и какой результат должен получится. При этом, названия тестов уже готовы, достаточно реализацию теста написать и понять контексты, в которых происходит то или иное событие.

Давайте на примере оформления заказа.

{%
    include image.html
    url="/public/images/questions/2024-10-11-how-to-map-eventstorming-to-code/es-checkout-example.jpg"
    description="Пример чекаута, который возвращает разные результаты, в зависимости от контекста"
    altdescription=""
%}

На момент создания ES, мы знаем над чем происходит действие (заказ), кто выполняет действие (покупатель) и какой результат ожидается (ок, либо проблемы). На основе этой информации уже можно сделать болванку для тестов:

```ruby
describe "Order" do
  # контекст в котором все ок придется определить самому
  context "when purchaser ..." do
    it "check out process completed without issues" do
      # реализация теста
    end
  end

  # контекст в оформление заказа фейлится придется определить самому
  context "when purchaser ..." do
    it "check out process failed " do
      # реализация теста
    end
  end
end
```

Останется только понять контекст в котором происходит каждое из событий и написать реализацию теста.

При этом, каждая бизнесовая команда будет содержать уникальный набор тестов в собственном файле, что позволит изолировать тесты. И никто не мешает сначала сделать EventStorming, после написать тесты, потом «сгенерировать» болванки команд, а в конце написать реализацию команды и отрефакторить полученный код. Т.е. использовать TDD/BDD подход в написании кода.

## Итоги

Используя ES можно разделить «думать» и «делать»: сначала думаем о бизнесовом процессе с названиями и определяем связи. После – занимаемся реализацией бизнесового процесса в коде и «заполняем» алгоритмами реализации и вызовом [моделей о которых думаем в момент реализации концептуальной модели данных](https://pepegramming.site/questions/data-model/#случай-1-проект-только-в-голове-и-хочется-понять-как-связаны-данные-между-собой){:target="_blank"}.

Благодаря такому подходу, получаем плюсы от использования ES в написании кода:

- Уменьшение когнитивной нагрузки, за счет того, что придется меньше думать об общем и можно будет сфокусироваться на частном (реализации команд);
- Получение «карты» процессов в системе со связями. Если понадобиться что-то исправить, можно быстро найти нужный кусок в ES и после, по названию команды, найти нужное место в коде;
- Использование ubiquitous language из DDD в коде, вместо придумывания терминов, которые потом придется объяснять бизнесу (либо наоборот переводить термины бизнеса на код);

Но и минусы присутствуют, связанные с ES моделью:

- Придется постоянно держать актуальную версию ES модели, что может быть затруднительно для стартапов или для компаний, где нет ответственного человека или нет интереса в поддержке моделей сотрудниками;
- Придется перестраивать процессы и сначала проектировать бизнес процесс, после чего уже писать код, что не сработает для гипотез и RnD, где сначала делают, потом думают (это норм);
- Придется каким-то образом верифицировать, что код и ES модель консистентны, в 99% случаев в ручную;

В конце напишу чеклист, которым пользуюсь, когда надо написать код по ES модели:

1. Сделать бизнес объекты под каждую команду, где название будет такое же, как название команды;
2. Сделать эндпоинты для каждой команды, которыми будут пользоваться акторы. При этом определить, как будут акторы разграничиваться в рамках транспорта (аунтификация, различные UI);
3. Разобраться с коммуникациями между командами: сделать эндпоинты/процедуры, создать необходимые топики/очереди;
4. Подготовить black box тесты для каждой команды. Подумать в каких контекстах появится каждое из возможных событий;
5. Реализовать логику команд. Добавить вызов внешних систем и (или) полиси;
6. Проверить, что код работает как требуется и радоваться жизни;

Если используете другой подход маппинга - буду рад, если расскажите, я дополню статью. Ну и делитесь личным опытом в комментарии, добавлю в ответ.

## Доп ссылки

- [en] Статья от разработчиков cucumber (тест фреймворк для BDD), в которой [описывается как концепции из ддд (точнее из event mapping) перевести в тест кейсы](https://cucumber.io/blog/bdd/bdd-with-event-mapping/){:target="_blank"}. В случае с ES подход аналогичен.

- [en] Пять репозиториев с кодом, который был написан (надеюсь) с использованием EventStorming:
  - [github.com/ddd-by-examples/library](https://github.com/ddd-by-examples/library){:target="_blank"}
  - [github.com/m-khooryani/OverCloudAirways-DDD-sample](https://github.com/m-khooryani/OverCloudAirways-DDD-sample){:target="_blank"}
  - [github.com/mkejeiri/Domain-Driven-Design](https://github.com/mkejeiri/Domain-Driven-Design){:target="_blank"}
  - [github.com/ddd-by-examples/factory](https://github.com/ddd-by-examples/factory){:target="_blank"}
  - [github.com/mgce/modular-monolith-nodejs](https://github.com/mgce/modular-monolith-nodejs){:target="_blank"}

- [en] Еще один пример [перевода EventStorming в код](https://github.com/ContextMapper/contextmapper.github.io/blob/master/_docs/tutorials/event-storming.md){:target="_blank"}. Для примера используется джава (если правильно распарсил).

- [en] Статья не об ES, но о том, как в целом [как используя концепции тактического и стратегического DDD для написания кода](https://ibm-cloud-architecture.github.io/refarch-eda/methodology/domain-driven-design/){:target="_blank"}. EventStorming тоже присутствует.

- [en] Репозиторий с [кодом на руби, который сделал для воркшопа](https://github.com/davydovanton/layerd-arch-style-with-dry-example/tree/master/contexts){:target="_blank"}. Можно посмотреть как описанный подход работает в плюс-минус рабочем коде
